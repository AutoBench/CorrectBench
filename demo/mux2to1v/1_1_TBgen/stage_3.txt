############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
1. Your task is to write a verilog testbench for an verilog RTL module code (we call it as "DUT", device under test). The information we have is the problem description that guides student to write the RTL code (DUT) and the header of the "DUT". Our target is to generate the verilog testbench for the DUT. This testbench can check if the DUT in verilog satisfies all technical requirements of the problem description.
2. you are in stage 3; in this stage, please give me the core rules of an ideal DUT. you should give these rules in python. (For convenience, you can use binary or hexadecimal format in python, i.e. 0b0010 and 0x1a). Later we will use these ideal rules to generate expected values in each test scenario. currently you must only generate the core part of the rules. the input of these rules should be related to the test vectors from test scenario. the rule should give the expected values under test vectors. You don't need to consider the control signals like clk or reset, unless the core rules of this task are about these signals. You can use numpy, scipy or other third party python libraries to help you write the rules. Please import them if you need. 
3. your information is:
RTL circuit problem description:
Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.
RTL testbench specification:
{
  "important data": "",
  "technical specifications": [
    "1. The DUT is a 2-1 multiplexer module.",
    "2. The module header specifies the inputs and outputs as follows:",
    "   - Input: 'a' which is a 100-bit vector.",
    "   - Input: 'b' which is a 100-bit vector.",
    "   - Input: 'sel' which is a 1-bit selector.",
    "   - Output: 'out' which is a 100-bit vector.",
    "3. Functional requirement: When 'sel' is 0, 'out' should reflect the value of 'a'. When 'sel' is 1, 'out' should reflect the value of 'b'."
  ]
}
DUT header:
module top_module (
	input [99:0] a,
	input [99:0] b,
	input sel,
	output [99:0] out
);

test scenario: (please note the test vectors below, it will help you determine the input parameters of the rules)
{
  "scenario 1": "Set sel=0, apply all zeros to both a and b.",
  "scenario 2": "Set sel=0, apply all ones to a and all zeros to b.",
  "scenario 3": "Set sel=0, apply alternating 1s and 0s starting with 1 to a, and apply alternating 0s and 1s starting with 0 to b.",
  "scenario 4": "Set sel=0, apply a random 100-bit pattern to a and a different random 100-bit pattern to b.",
  "scenario 5": "Set sel=0, apply a pattern where the first half of a is all 1s and the second half is all 0s, do the reverse pattern for b.",
  "scenario 6": "Set sel=1, apply all zeros to both a and b.",
  "scenario 7": "Set sel=1, apply all zeros to a and all ones to b.",
  "scenario 8": "Set sel=1, apply alternating 1s and 0s starting with 0 to a, and apply alternating 0s and 1s starting with 1 to b.",
  "scenario 9": "Set sel=1, apply a random 100-bit pattern to a and a different random 100-bit pattern to b.",
  "scenario 10": "Set sel=1, apply a pattern where the first half of a is all 0s and the second half is all 1s, do the reverse pattern for b.",
  "scenario 11": "Change sel from 0 to 1 and back to 0 during consecutive clock cycles while maintaining static inputs a and b.",
  "scenario 12": "Change sel from 1 to 0 and back to 1 during consecutive clock cycles with static inputs a and b.",
  "scenario 13": "Rapidly toggle sel between 0 and 1 for several consecutive clock cycles with random inputs a and b."
}
your response should only contain python code. For convenience, you can use binary or hexadecimal format in python. For example: 0b0010 and 0x1a


########## assistant ##########
```python
import numpy as np

def ideal_dut(sel, a, b):
    """
    Core rule function for the ideal DUT (2-1 multiplexer).
    
    Parameters:
    sel (int): Selector input (0 or 1).
    a (int): 100-bit input vector.
    b (int): 100-bit input vector.
    
    Returns:
    int: Expected 100-bit output vector based on the value of 'sel'.
    """
    # Ensure inputs a and b are each 100 bits long
    assert 0 <= a < (1 << 100), "Input 'a' must be a 100-bit integer."
    assert 0 <= b < (1 << 100), "Input 'b' must be a 100-bit integer."
    assert sel in [0, 1], "Input 'sel' must be either 0 or 1."
    
    # Return 'a' if sel is 0, 'b' if sel is 1
    if sel == 0:
        return a
    else:
        return b

# Example usage based on test scenarios
a_all_zero = 0b0
b_all_zero = 0b0

a_all_one = (1 << 100) - 1
b_all_one = (1 << 100) - 1

a_alternating_1 = int('10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010', 2)
b_alternating_0 = int('01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101', 2)

# Scenario 1: sel=0, all zeros
out_scenario_1 = ideal_dut(0, a_all_zero, b_all_zero)

# Scenario 2: sel=0, all ones for 'a', zeros for 'b'
out_scenario_2 = ideal_dut(0, a_all_one, b_all_zero)

# Scenario 3: sel=0, alternating 1s for 'a'
out_scenario_3 = ideal_dut(0, a_alternating_1, b_alternating_0)

# Test function will use these scenarios and compare with expected output for verification
# You can continue for other scenarios similarly
```

