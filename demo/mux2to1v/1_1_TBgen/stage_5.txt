############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########

1. background: Your task is to verify the functional correctness of a verilog RTL module code (we call it as "DUT", device under test). Our plan is to first export the signals (input and output) of the DUT under test scenarios. Then, we will use a python script to check the correctness of DUT.
2. You are in the last stage. In this stage, we already export the signals of DUT. The signals of DUT are in the format below: (the signal names are real, but the values are just for example)
[{'scenario': 1, 'a': 1, 'b': 1, 'sel': 1, 'out': 1}, {'scenario': 1, 'a': 1, 'b': 1, 'sel': 1, 'out': 1}, {'scenario': 1, 'a': 1, 'b': 1, 'sel': 1, 'out': 1}]
The input signals are all in decimal format. The "scenario" is not DUT's signal but to tell you the current scenario index.
3. Your current task is: write a python class "GoldenDUT". This python class can represent the golden DUT (the ideal one). In your "GoldenDUT", you should do the following things:
- a. Write a method "def __init__(self)". Set the inner states/values of the golden DUT. The "__init__" method has no input parameters except "self".
- b. Write a method "def load(self, signal_vector)". This method is to load the important input signals and get the expected output signals. it should return the expected output values. It can call other methods to help computing the expected output. It will be called by other inner methods later.
- c. Write a method "def check(self, signal_vector)". This method is to call "load" to get the expected output values, and compare them with output signals from DUT. It should return True or False only. It can call other methods to help checking.
- d. write other methods you need, they can be called by "__init__", "load" or "check".
- e. the input of "load" and "check" is the signal vector. The signal vector is a dictionary, the key is the signal name, the value is the signal value.
You can use binary (like 0x1101), hexadecimal (like 0x1a) or normal number format in python. But the signal vector input to GoldenDUT is always in decimal format 
4. You have the information below to help you check the correctness of DUT:

RTL circuit problem description:
Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.
Checker specification:
{
  "important data": "",
  "technical specifications": [
    "1. The DUT is a 2-1 multiplexer module.",
    "2. The module header specifies the inputs and outputs as follows:",
    "   - Input: 'a' which is a 100-bit vector.",
    "   - Input: 'b' which is a 100-bit vector.",
    "   - Input: 'sel' which is a 1-bit selector.",
    "   - Output: 'out' which is a 100-bit vector.",
    "3. Functional requirement: When 'sel' is 0, 'out' should reflect the value of 'a'. When 'sel' is 1, 'out' should reflect the value of 'b'."
  ]
}
Here is the basic rules in python for the module. It is generated in previous stage. You can use it as a reference, but you should write your own python script. This is just for your better understanding:
import numpy as np

def ideal_dut(sel, a, b):
    """
    Core rule function for the ideal DUT (2-1 multiplexer).
    
    Parameters:
    sel (int): Selector input (0 or 1).
    a (int): 100-bit input vector.
    b (int): 100-bit input vector.
    
    Returns:
    int: Expected 100-bit output vector based on the value of 'sel'.
    """
    # Ensure inputs a and b are each 100 bits long
    assert 0 <= a < (1 << 100), "Input 'a' must be a 100-bit integer."
    assert 0 <= b < (1 << 100), "Input 'b' must be a 100-bit integer."
    assert sel in [0, 1], "Input 'sel' must be either 0 or 1."
    
    # Return 'a' if sel is 0, 'b' if sel is 1
    if sel == 0:
        return a
    else:
        return b

# Example usage based on test scenarios
a_all_zero = 0b0
b_all_zero = 0b0

a_all_one = (1 << 100) - 1
b_all_one = (1 << 100) - 1

a_alternating_1 = int('10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010', 2)
b_alternating_0 = int('01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101', 2)

# Scenario 1: sel=0, all zeros
out_scenario_1 = ideal_dut(0, a_all_zero, b_all_zero)

# Scenario 2: sel=0, all ones for 'a', zeros for 'b'
out_scenario_2 = ideal_dut(0, a_all_one, b_all_zero)

# Scenario 3: sel=0, alternating 1s for 'a'
out_scenario_3 = ideal_dut(0, a_alternating_1, b_alternating_0)

# Test function will use these scenarios and compare with expected output for verification
# You can continue for other scenarios similarly



[IMPORTANT] Your current task is: write a python class "GoldenDUT". This python class can represent the golden DUT (the ideal one). In your "GoldenDUT", you should do the following things:
- a. Write a method "def __init__(self)". Set the inner states/values of the golden DUT. The "__init__" method has no input parameters except "self".
- b. Write a method "def load(self, signal_vector)". This method is to load the important input signals and get the expected output signals. it should return the expected output values. It can call other methods to help computing the expected output. It will be called by other inner methods later.
- c. Write a method "def check(self, signal_vector)". This method is to call "load" to get the expected output values, and compare them with output signals from DUT. It should return True or False only. It can call other methods to help checking.
- d. write other methods you need, they can be called by "__init__", "load" or "check".
- e. the input of "load" and "check" is the signal vector. The signal vector is a dictionary, the key is the signal name, the value is the signal value.
You can use binary (like 0x1101), hexadecimal (like 0x1a) or normal number format in python. But the signal vector input to GoldenDUT is always in decimal format
Optional: You can also use functions from numpy and scipy to help you check the correctness of DUT.
you can use binary (like 0b1011), hexadeciaml (like 0x1a) or normal number format in python for convenience. 
please only generate the python codes, no other words.



########## assistant ##########
```python
class GoldenDUT:
    def __init__(self):
        # No inner states are necessarily kept for this simple function
        pass

    def load(self, signal_vector):
        # Extract input signals from the signal vector
        a = signal_vector['a']
        b = signal_vector['b']
        sel = signal_vector['sel']
        
        # Compute the expected output based on the selector `sel`
        return self._compute_expected_output(a, b, sel)

    def check(self, signal_vector):
        # Get the expected output by loading the current input signal vector
        expected_out = self.load(signal_vector)
        
        # Compare with DUT output
        actual_out = signal_vector['out']
        
        # Return True if the outputs match; otherwise, False
        return expected_out == actual_out

    def _compute_expected_output(self, a, b, sel):
        # Ensure inputs 'a' and 'b' are each 100 bits long
        assert 0 <= a < (1 << 100), "Input 'a' must be a 100-bit integer."
        assert 0 <= b < (1 << 100), "Input 'b' must be a 100-bit integer."
        assert sel in [0, 1], "Input 'sel' must be either 0 or 1."

        # Return 'a' if sel is 0, 'b' if sel is 1
        if sel == 0:
            return a
        else:
            return b
```


