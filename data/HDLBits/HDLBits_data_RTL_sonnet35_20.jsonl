{"task_id": "mux2to1v", "llmgen_RTL": ["module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n    \n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"]}
{"task_id": "m2014_q6b", "llmgen_RTL": ["module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case ({y, w})\n            4'b0000: Y2 = 0;\n            4'b0001: Y2 = 0;\n            4'b0010: Y2 = 0;\n            4'b0011: Y2 = 1;\n            4'b0100: Y2 = 0;\n            4'b0101: Y2 = 1;\n            4'b0110: Y2 = 1;\n            4'b0111: Y2 = 0;\n            4'b1000: Y2 = 1;\n            4'b1001: Y2 = 1;\n            4'b1010: Y2 = 0;\n            4'b1011: Y2 = 1;\n            default: Y2 = 0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = w ? 1'b0 : 1'b0; // A\n            3'b001: Y2 = w ? 1'b1 : 1'b0; // B\n            3'b010: Y2 = w ? 1'b1 : 1'b0; // C\n            3'b011: Y2 = w ? 1'b0 : 1'b1; // D\n            3'b100: Y2 = w ? 1'b1 : 1'b1; // E\n            3'b101: Y2 = w ? 1'b1 : 1'b0; // F\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = w ? 1'b0 : 1'b0;  // State A\n            3'b001: Y2 = w ? 1'b1 : 1'b0;  // State B\n            3'b010: Y2 = w ? 1'b1 : 1'b1;  // State C\n            3'b011: Y2 = w ? 1'b0 : 1'b1;  // State D\n            3'b100: Y2 = w ? 1'b1 : 1'b1;  // State E\n            3'b101: Y2 = w ? 1'b1 : 1'b0;  // State F\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = w ? 1'b0 : 1'b0;  // A\n            3'b001: Y2 = w ? 1'b1 : 1'b0;  // B\n            3'b010: Y2 = w ? 1'b1 : 1'b0;  // C\n            3'b011: Y2 = w ? 1'b0 : 1'b1;  // D\n            3'b100: Y2 = w ? 1'b1 : 1'b1;  // E\n            3'b101: Y2 = w ? 1'b1 : 1'b0;  // F\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0;  // State A\n            3'b001: Y2 = w;     // State B\n            3'b010: Y2 = w;     // State C\n            3'b011: Y2 = 1'b1;  // State D\n            3'b100: Y2 = 1'b1;  // State E\n            3'b101: Y2 = 1'b0;  // State F\n            default: Y2 = 1'b0; // Default case\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case ({y, w})\n            4'b0000: Y2 = 0; // A->B\n            4'b0001: Y2 = 0; // A->A\n            4'b0010: Y2 = 0; // B->C\n            4'b0011: Y2 = 1; // B->D\n            4'b0100: Y2 = 1; // C->E\n            4'b0101: Y2 = 1; // C->D\n            4'b0110: Y2 = 1; // D->F\n            4'b0111: Y2 = 0; // D->A\n            4'b1000: Y2 = 1; // E->E\n            4'b1001: Y2 = 1; // E->D\n            4'b1010: Y2 = 0; // F->C\n            4'b1011: Y2 = 1; // F->D\n            default: Y2 = 0; // Undefined states\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case ({y, w})\n            4'b0000: Y2 = 0; // A->B\n            4'b0001: Y2 = 0; // A->A\n            4'b0010: Y2 = 0; // B->C\n            4'b0011: Y2 = 1; // B->D\n            4'b0100: Y2 = 1; // C->E\n            4'b0101: Y2 = 1; // C->D\n            4'b0110: Y2 = 1; // D->F\n            4'b0111: Y2 = 0; // D->A\n            4'b1000: Y2 = 1; // E->E\n            4'b1001: Y2 = 1; // E->D\n            4'b1010: Y2 = 0; // F->C\n            4'b1011: Y2 = 1; // F->D\n            default: Y2 = 0; // Default case\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n\talways @(*) begin\n\t\tcase ({y, w})\n\t\t\t4'b0000: Y2 = 0;\n\t\t\t4'b0001: Y2 = 0;\n\t\t\t4'b0010: Y2 = 0;\n\t\t\t4'b0011: Y2 = 1;\n\t\t\t4'b0100: Y2 = 0;\n\t\t\t4'b0101: Y2 = 1;\n\t\t\t4'b0110: Y2 = 1;\n\t\t\t4'b0111: Y2 = 0;\n\t\t\t4'b1000: Y2 = 1;\n\t\t\t4'b1001: Y2 = 1;\n\t\t\t4'b1010: Y2 = 0;\n\t\t\t4'b1011: Y2 = 1;\n\t\t\tdefault: Y2 = 0;\n\t\tendcase\n\tend\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = w ? 1'b0 : 1'b0;  // State A\n            3'b001: Y2 = w ? 1'b1 : 1'b0;  // State B\n            3'b010: Y2 = w ? 1'b1 : 1'b1;  // State C\n            3'b011: Y2 = w ? 1'b0 : 1'b1;  // State D\n            3'b100: Y2 = w ? 1'b1 : 1'b1;  // State E\n            3'b101: Y2 = w ? 1'b1 : 1'b0;  // State F\n            default: Y2 = 1'b0;  // Default case\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case ({y, w})\n            4'b0000: Y2 = 0;\n            4'b0001: Y2 = 0;\n            4'b0010: Y2 = 0;\n            4'b0011: Y2 = 1;\n            4'b0100: Y2 = 0;\n            4'b0101: Y2 = 1;\n            4'b0110: Y2 = 1;\n            4'b0111: Y2 = 0;\n            4'b1000: Y2 = 1;\n            4'b1001: Y2 = 1;\n            4'b1010: Y2 = 0;\n            4'b1011: Y2 = 1;\n            default: Y2 = 0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0;  // State A\n            3'b001: Y2 = w;     // State B\n            3'b010: Y2 = w;     // State C\n            3'b011: Y2 = 1'b1;  // State D\n            3'b100: Y2 = 1'b1;  // State E\n            3'b101: Y2 = 1'b0;  // State F\n            default: Y2 = 1'b0; // Default case\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0;  // State A\n            3'b001: Y2 = w;  // State B\n            3'b010: Y2 = w;  // State C\n            3'b011: Y2 = 0;  // State D\n            3'b100: Y2 = 0;  // State E\n            3'b101: Y2 = 0;  // State F\n            default: Y2 = 0; // Default case\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case ({y, w})\n            4'b000_0: Y2 = 0; // A to B\n            4'b000_1: Y2 = 0; // A to A\n            4'b001_0: Y2 = 0; // B to C\n            4'b001_1: Y2 = 1; // B to D\n            4'b010_0: Y2 = 1; // C to E\n            4'b010_1: Y2 = 1; // C to D\n            4'b011_0: Y2 = 1; // D to F\n            4'b011_1: Y2 = 0; // D to A\n            4'b100_0: Y2 = 1; // E to E\n            4'b100_1: Y2 = 1; // E to D\n            4'b101_0: Y2 = 0; // F to C\n            4'b101_1: Y2 = 1; // F to D\n            default: Y2 = 0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case ({y, w})\n            4'b0000: Y2 = 0; // A to B\n            4'b0001: Y2 = 0; // A to A\n            4'b0010: Y2 = 0; // B to C\n            4'b0011: Y2 = 1; // B to D\n            4'b0100: Y2 = 1; // C to E\n            4'b0101: Y2 = 1; // C to D\n            4'b0110: Y2 = 1; // D to F\n            4'b0111: Y2 = 0; // D to A\n            4'b1000: Y2 = 1; // E to E\n            4'b1001: Y2 = 1; // E to D\n            4'b1010: Y2 = 0; // F to C\n            4'b1011: Y2 = 1; // F to D\n            default: Y2 = 0; // Default case\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n\talways @(*) begin\n\t\tcase({y, w})\n\t\t\t4'b0000: Y2 = 0; // A->B\n\t\t\t4'b0001: Y2 = 0; // A->A\n\t\t\t4'b0010: Y2 = 0; // B->C\n\t\t\t4'b0011: Y2 = 1; // B->D\n\t\t\t4'b0100: Y2 = 1; // C->E\n\t\t\t4'b0101: Y2 = 1; // C->D\n\t\t\t4'b0110: Y2 = 1; // D->F\n\t\t\t4'b0111: Y2 = 0; // D->A\n\t\t\t4'b1000: Y2 = 1; // E->E\n\t\t\t4'b1001: Y2 = 1; // E->D\n\t\t\t4'b1010: Y2 = 0; // F->C\n\t\t\t4'b1011: Y2 = 1; // F->D\n\t\t\tdefault: Y2 = 0;\n\t\tendcase\n\tend\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0; // State A\n            3'b001: Y2 = w;    // State B\n            3'b010: Y2 = w;    // State C\n            3'b011: Y2 = 1'b0; // State D\n            3'b100: Y2 = 1'b1; // State E\n            3'b101: Y2 = 1'b0; // State F\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case(y)\n            3'b000: Y2 = w ? 1'b0 : 1'b0; // A\n            3'b001: Y2 = w ? 1'b1 : 1'b0; // B\n            3'b010: Y2 = w ? 1'b1 : 1'b0; // C\n            3'b011: Y2 = w ? 1'b0 : 1'b1; // D\n            3'b100: Y2 = w ? 1'b1 : 1'b1; // E\n            3'b101: Y2 = w ? 1'b1 : 1'b0; // F\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case ({y, w})\n            4'b0000, 4'b0001, 4'b0010, 4'b0011, 4'b0100, 4'b0101: Y2 = 0;\n            4'b0110, 4'b0111: Y2 = 1;\n            4'b1000, 4'b1001: Y2 = 0;\n            4'b1010, 4'b1011: Y2 = 1;\n            default: Y2 = 0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case ({y, w})\n            4'b0000: Y2 = 0;\n            4'b0001: Y2 = 0;\n            4'b0010: Y2 = 0;\n            4'b0011: Y2 = 1;\n            4'b0100: Y2 = 0;\n            4'b0101: Y2 = 1;\n            4'b0110: Y2 = 1;\n            4'b0111: Y2 = 0;\n            4'b1000: Y2 = 1;\n            4'b1001: Y2 = 1;\n            4'b1010: Y2 = 0;\n            4'b1011: Y2 = 1;\n            default: Y2 = 0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = w ? 1'b0 : 1'b0;  // A\n            3'b001: Y2 = w ? 1'b1 : 1'b0;  // B\n            3'b010: Y2 = w ? 1'b1 : 1'b0;  // C\n            3'b011: Y2 = w ? 1'b0 : 1'b1;  // D\n            3'b100: Y2 = w ? 1'b1 : 1'b0;  // E\n            3'b101: Y2 = w ? 1'b1 : 1'b0;  // F\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "ringer", "llmgen_RTL": ["module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule"]}
{"task_id": "alwaysblock1", "llmgen_RTL": ["module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\n\tassign out_assign = a & b;\n\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\n    assign out_assign = a & b;\n\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\n    assign out_assign = a & b;\n\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\n\tassign out_assign = a & b;\n\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\n    assign out_assign = a & b;\n\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\n\tassign out_assign = a & b;\n\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\n\tassign out_assign = a & b;\n\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\nassign out_assign = a & b;\n\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule"]}
{"task_id": "zero", "llmgen_RTL": ["module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\n    assign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n    assign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\n    assign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\n    assign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero\n);\n\n\tassign zero = 1'b0;\n\nendmodule", "module top_module(\n\toutput zero);\n\n\tassign zero = 1'b0;\n\nendmodule"]}
{"task_id": "circuit7", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clk) begin\n        if (a == 0 && state == 0)\n            q <= 1;\n        else if (a == 1 && state == 0)\n            q <= 0;\n        \n        state <= a;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    reg prev_a;\n\n    always @(posedge clk) begin\n        if (a && !prev_a)\n            q <= 0;\n        else if (!a && !prev_a)\n            q <= 1;\n        \n        prev_a <= a;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    reg prev_a;\n\n    always @(posedge clk) begin\n        if (a == 1'b0 && prev_a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && prev_a == 1'b1)\n            q <= 1'b0;\n        \n        prev_a <= a;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    reg prev_a;\n\n    always @(posedge clk) begin\n        if (a == 1'b0 && prev_a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && prev_a == 1'b1)\n            q <= 1'b0;\n        \n        prev_a <= a;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\nreg prev_a;\n\nalways @(posedge clk) begin\n    if (a == 1'b0 && prev_a == 1'b0)\n        q <= 1'b1;\n    else if (a == 1'b1 && prev_a == 1'b1)\n        q <= 1'b0;\n    \n    prev_a <= a;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    reg prev_a;\n\n    always @(posedge clk) begin\n        if (a == 1'b0 && prev_a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && prev_a == 1'b1)\n            q <= 1'b0;\n        \n        prev_a <= a;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    reg q_next;\n\n    always @(*) begin\n        if (a == 1'b0)\n            q_next = 1'b1;\n        else\n            q_next = 1'b0;\n    end\n\n    always @(posedge clk) begin\n        q <= q_next;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b0)\n            q <= 1'b1;\n        else if (a == 1'b1 && q == 1'b1)\n            q <= 1'b0;\n    end\n\nendmodule"]}
{"task_id": "ece241_2014_q5a", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput reg z\n);\n\nreg [1:0] state, next_state;\nparameter INIT = 2'b00, COPY = 2'b01, COMP = 2'b10;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= INIT;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        INIT: next_state = x ? COPY : INIT;\n        COPY: next_state = COMP;\n        COMP: next_state = COMP;\n        default: next_state = INIT;\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        INIT: z = x;\n        COPY: z = x;\n        COMP: z = ~x;\n        default: z = x;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    reg z_reg;\n    \n    parameter INIT = 2'b00,\n              COPY = 2'b01,\n              FLIP = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            INIT: next_state = COPY;\n            COPY: next_state = (x) ? FLIP : COPY;\n            FLIP: next_state = FLIP;\n            default: next_state = INIT;\n        endcase\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            z_reg <= 0;\n        else begin\n            case (state)\n                INIT: z_reg <= 0;\n                COPY: z_reg <= x;\n                FLIP: z_reg <= ~x;\n            endcase\n        end\n    end\n\n    assign z = z_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\nreg [1:0] state, next_state;\nreg z_reg;\n\nparameter IDLE = 2'b00;\nparameter COPY = 2'b01;\nparameter FLIP = 2'b10;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: next_state = COPY;\n        COPY: next_state = (x) ? FLIP : COPY;\n        FLIP: next_state = FLIP;\n        default: next_state = IDLE;\n    endcase\nend\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        z_reg <= 0;\n    else begin\n        case (state)\n            IDLE: z_reg <= 0;\n            COPY: z_reg <= x;\n            FLIP: z_reg <= ~x;\n        endcase\n    end\nend\n\nassign z = z_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter INIT = 2'b00, COPY = 2'b01, FLIP = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            INIT: next_state = x ? COPY : INIT;\n            COPY: next_state = FLIP;\n            FLIP: next_state = FLIP;\n            default: next_state = INIT;\n        endcase\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            z <= 0;\n        else begin\n            case (state)\n                INIT: z <= x;\n                COPY: z <= x;\n                FLIP: z <= ~x;\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter IDLE = 2'b00, COPY = 2'b01, FLIP = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = COPY;\n            COPY: next_state = (x) ? FLIP : COPY;\n            FLIP: next_state = FLIP;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            z <= 0;\n        else begin\n            case (state)\n                IDLE: z <= 0;\n                COPY: z <= x;\n                FLIP: z <= ~x;\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\nreg [1:0] state, next_state;\nreg z_reg;\n\nparameter IDLE = 2'b00,\n          COPY = 2'b01,\n          COMPLEMENT = 2'b10;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: next_state = COPY;\n        COPY: next_state = (x) ? COMPLEMENT : COPY;\n        COMPLEMENT: next_state = COMPLEMENT;\n        default: next_state = IDLE;\n    endcase\nend\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        z_reg <= 1'b0;\n    else begin\n        case (state)\n            IDLE: z_reg <= 1'b0;\n            COPY: z_reg <= x;\n            COMPLEMENT: z_reg <= ~x;\n            default: z_reg <= 1'b0;\n        endcase\n    end\nend\n\nassign z = z_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput reg z\n);\n\n    reg state;\n    parameter COPY = 1'b0, FLIP = 1'b1;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= COPY;\n            z <= 0;\n        end else begin\n            case (state)\n                COPY: begin\n                    z <= x;\n                    if (x)\n                        state <= FLIP;\n                end\n                FLIP: begin\n                    z <= ~x;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\nreg [1:0] state, next_state;\nreg z_reg;\n\nparameter IDLE = 2'b00,\n          COPY = 2'b01,\n          COMPLEMENT = 2'b10;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: next_state = COPY;\n        COPY: next_state = (x) ? COMPLEMENT : COPY;\n        COMPLEMENT: next_state = COMPLEMENT;\n        default: next_state = IDLE;\n    endcase\nend\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        z_reg <= 1'b0;\n    else begin\n        case (state)\n            IDLE: z_reg <= 1'b0;\n            COPY: z_reg <= x;\n            COMPLEMENT: z_reg <= ~x;\n            default: z_reg <= 1'b0;\n        endcase\n    end\nend\n\nassign z = z_reg;\n\nendmodule", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    reg state;\n    parameter COPY = 1'b0, INVERT = 1'b1;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= COPY;\n            z <= 0;\n        end else begin\n            case (state)\n                COPY: begin\n                    z <= x;\n                    if (x)\n                        state <= INVERT;\n                end\n                INVERT: begin\n                    z <= ~x;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    reg z_reg;\n    \n    parameter IDLE = 2'b00,\n              COPY = 2'b01,\n              FLIP = 2'b10;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            IDLE: next_state = COPY;\n            COPY: next_state = (x) ? FLIP : COPY;\n            FLIP: next_state = FLIP;\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            z_reg <= 1'b0;\n        else begin\n            case (state)\n                IDLE: z_reg <= 1'b0;\n                COPY: z_reg <= x;\n                FLIP: z_reg <= ~x;\n            endcase\n        end\n    end\n    \n    assign z = z_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\nreg state, next_state;\nreg z_reg;\n\nparameter COPY = 1'b0;\nparameter FLIP = 1'b1;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= COPY;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        COPY: next_state = (x == 1) ? FLIP : COPY;\n        FLIP: next_state = FLIP;\n    endcase\nend\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        z_reg <= 1'b0;\n    else\n        case (state)\n            COPY: z_reg <= x;\n            FLIP: z_reg <= ~x;\n        endcase\nend\n\nassign z = z_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    reg z_reg;\n    \n    parameter IDLE = 2'b00,\n              COPY = 2'b01,\n              COMP = 2'b10;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            IDLE: next_state = COPY;\n            COPY: next_state = (x) ? COMP : COPY;\n            COMP: next_state = COMP;\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            z_reg <= 0;\n        else begin\n            case (state)\n                IDLE: z_reg <= 0;\n                COPY: z_reg <= x;\n                COMP: z_reg <= ~x;\n            endcase\n        end\n    end\n    \n    assign z = z_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg z;\n    reg state;\n    \n    parameter COPY = 1'b0, COMPLEMENT = 1'b1;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= COPY;\n            z <= 0;\n        end else begin\n            case (state)\n                COPY: begin\n                    z <= x;\n                    if (x == 1'b1)\n                        state <= COMPLEMENT;\n                end\n                COMPLEMENT: begin\n                    z <= ~x;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\nreg z;\nreg state;\n\nparameter COPY = 1'b0;\nparameter FLIP = 1'b1;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= COPY;\n        z <= 1'b0;\n    end else begin\n        case (state)\n            COPY: begin\n                z <= x;\n                if (x)\n                    state <= FLIP;\n            end\n            FLIP: begin\n                z <= ~x;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\nreg state, next_state;\nreg output_bit;\n\nparameter COPY = 1'b0, INVERT = 1'b1;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= COPY;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        COPY: next_state = x ? INVERT : COPY;\n        INVERT: next_state = INVERT;\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        COPY: output_bit = x;\n        INVERT: output_bit = ~x;\n    endcase\nend\n\nassign z = output_bit;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput reg z\n);\n\n    reg state;\n    parameter COPY = 1'b0, COMPLEMENT = 1'b1;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= COPY;\n            z <= 0;\n        end else begin\n            case (state)\n                COPY: begin\n                    z <= x;\n                    if (x)\n                        state <= COMPLEMENT;\n                end\n                COMPLEMENT: begin\n                    z <= ~x;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput reg z\n);\n\nreg state;\nparameter COPY = 1'b0, FLIP = 1'b1;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= COPY;\n        z <= 0;\n    end else begin\n        case (state)\n            COPY: begin\n                z <= x;\n                if (x)\n                    state <= FLIP;\n            end\n            FLIP: begin\n                z <= ~x;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    reg z_reg;\n\n    parameter IDLE = 2'b00,\n              COPY = 2'b01,\n              FLIP = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = COPY;\n            COPY: next_state = (x) ? FLIP : COPY;\n            FLIP: next_state = FLIP;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            z_reg <= 0;\n        else begin\n            case (state)\n                IDLE: z_reg <= 0;\n                COPY: z_reg <= x;\n                FLIP: z_reg <= ~x;\n            endcase\n        end\n    end\n\n    assign z = z_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    reg z_reg;\n    \n    parameter IDLE = 2'b00;\n    parameter COPY = 2'b01;\n    parameter COMPLEMENT = 2'b10;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            IDLE: next_state = COPY;\n            COPY: begin\n                if (x)\n                    next_state = COMPLEMENT;\n                else\n                    next_state = COPY;\n            end\n            COMPLEMENT: next_state = COMPLEMENT;\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            z_reg <= 1'b0;\n        else begin\n            case (state)\n                IDLE: z_reg <= 1'b0;\n                COPY: z_reg <= x;\n                COMPLEMENT: z_reg <= ~x;\n                default: z_reg <= 1'b0;\n            endcase\n        end\n    end\n    \n    assign z = z_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput reg z\n);\n\n\tlocalparam INIT = 2'b00;\n\tlocalparam COPY = 2'b01;\n\tlocalparam COMP = 2'b10;\n\n\treg [1:0] state, next_state;\n\treg first_one;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= INIT;\n\t\t\tfirst_one <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == COPY && x == 1)\n\t\t\t\tfirst_one <= 1;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tINIT: next_state = COPY;\n\t\t\tCOPY: next_state = (x == 1 && !first_one) ? COMP : COPY;\n\t\t\tCOMP: next_state = COMP;\n\t\t\tdefault: next_state = INIT;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tINIT: z = 0;\n\t\t\tCOPY: z = x;\n\t\t\tCOMP: z = ~x;\n\t\t\tdefault: z = 0;\n\t\tendcase\n\tend\n\nendmodule"]}
{"task_id": "fsm3", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\treg [1:0] state, next_state;\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\t\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\nreg [1:0] state, next_state;\n\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        A: next_state = in ? B : A;\n        B: next_state = in ? B : C;\n        C: next_state = in ? D : A;\n        D: next_state = in ? B : C;\n        default: next_state = A;\n    endcase\nend\n\nassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\treg [1:0] state, next_state;\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\t\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n\tend\n\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\treg [1:0] state, next_state;\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\t\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule"]}
{"task_id": "vector2", "llmgen_RTL": ["module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule", "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n\tassign out[31:24] = in[7:0];\n\tassign out[23:16] = in[15:8];\n\tassign out[15:8] = in[23:16];\n\tassign out[7:0] = in[31:24];\n\nendmodule"]}
{"task_id": "m2014_q4c", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\nalways_ff @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule"]}
{"task_id": "mt2015_q4a", "llmgen_RTL": ["module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\tassign z = (x ^ y) & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\tassign z = (x ^ y) & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\tassign z = (x ^ y) & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\tassign z = (x ^ y) & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\tassign z = (x ^ y) & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\twire xor_out;\n\n\tassign xor_out = x ^ y;\n\tassign z = xor_out & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\tassign z = (x ^ y) & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_out;\n\t\n\tassign xor_out = x ^ y;\n\tassign z = xor_out & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_out;\n\t\n\tassign xor_out = x ^ y;\n\tassign z = xor_out & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (x ^ y) & x;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire xor_result;\n\t\n\tassign xor_result = x ^ y;\n\tassign z = xor_result & x;\n\nendmodule"]}
{"task_id": "shift18", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};                 // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};                 // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};                // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};           // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};           // Left shift by 1\n                2'b01: q <= {q[55:0], 8'b0};           // Left shift by 8\n                2'b10: q <= {q[63], q[63:1]};          // Arithmetic right shift by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]};     // Arithmetic right shift by 8\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};        // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};        // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};       // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};  // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};           // Left shift by 1\n                2'b01: q <= {q[55:0], 8'b0};           // Left shift by 8\n                2'b10: q <= {q[63], q[63:1]};          // Right shift by 1 (arithmetic)\n                2'b11: q <= {{8{q[63]}}, q[63:8]};     // Right shift by 8 (arithmetic)\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};        // shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};        // shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};       // arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};  // arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};  // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};  // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};           // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};           // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};          // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};     // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};          // shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};          // shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};         // arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};    // arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};  // Left shift by 1\n                2'b01: q <= {q[55:0], 8'b0};  // Left shift by 8\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic right shift by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic right shift by 8\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};          // Left shift by 1\n                2'b01: q <= {q[55:0], 8'b0};          // Left shift by 8\n                2'b10: q <= {q[63], q[63:1]};         // Arithmetic right shift by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]};    // Arithmetic right shift by 8\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};         // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};         // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};        // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};   // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};  // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};  // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};           // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};           // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};          // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};     // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};         // Left shift by 1\n                2'b01: q <= {q[55:0], 8'b0};         // Left shift by 8\n                2'b10: q <= {q[63], q[63:1]};        // Arithmetic right shift by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]};   // Arithmetic right shift by 8\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};          // Left shift by 1\n                2'b01: q <= {q[55:0], 8'b0};          // Left shift by 8\n                2'b10: q <= {q[63], q[63:1]};         // Arithmetic right shift by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]};    // Arithmetic right shift by 8\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};           // Left shift by 1\n                2'b01: q <= {q[55:0], 8'b0};           // Left shift by 8\n                2'b10: q <= {q[63], q[63:1]};          // Arithmetic right shift by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]};     // Arithmetic right shift by 8\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};  // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};  // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};          // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};          // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};         // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};    // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};  // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0};  // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};  // Left shift by 1\n                2'b01: q <= {q[55:0], 8'b0};  // Left shift by 8\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic right shift by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic right shift by 8\n            endcase\n        end\n    end\n\nendmodule"]}
{"task_id": "ece241_2013_q8", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    \n    parameter S0 = 2'b00,\n              S1 = 2'b01,\n              S2 = 2'b10;\n    \n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        \n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    \n    parameter S0 = 2'b00;\n    parameter S1 = 2'b01;\n    parameter S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        \n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (~aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] current_state, next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(*) begin\n        z = (current_state == S2) && x;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    \n    parameter S0 = 2'b00,\n              S1 = 2'b01,\n              S2 = 2'b10;\n    \n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: if (x) next_state = S1;\n            S1: if (!x) next_state = S2;\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n\treg [1:0] state, next_state;\n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: next_state = x ? S1 : S0;\n\t\t\tS1: next_state = x ? S1 : S2;\n\t\t\tS2: next_state = x ? S1 : S0;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tz = (state == S2) && x;\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: if (x) next_state = S1;\n            S1: if (!x) next_state = S2;\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end else begin\n                    next_state = S0;\n                end\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] current_state, next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(*) begin\n        z = (current_state == S2 && x == 1);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: if (x) next_state = S1;\n            S1: if (!x) next_state = S2;\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] current_state, next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = current_state;\n        z = 1'b0;\n        case (current_state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                end\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule"]}
{"task_id": "m2014_q6", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    localparam A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\nreg [2:0] state, next_state;\nparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        A: next_state = w ? A : B;\n        B: next_state = w ? D : C;\n        C: next_state = w ? D : E;\n        D: next_state = w ? A : F;\n        E: next_state = w ? D : E;\n        F: next_state = w ? D : C;\n        default: next_state = A;\n    endcase\nend\n\nassign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    reg [2:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n\tparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\treg [2:0] state, next_state;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = w ? A : B;\n\t\t\tB: next_state = w ? D : C;\n\t\t\tC: next_state = w ? D : E;\n\t\t\tD: next_state = w ? A : F;\n\t\t\tE: next_state = w ? D : E;\n\t\t\tF: next_state = w ? D : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    reg [2:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule"]}
{"task_id": "fsm_ps2data", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\nreg [1:0] state;\nreg [1:0] byte_count;\nreg [23:0] message_buffer;\n\nlocalparam IDLE = 2'b00;\nlocalparam RECEIVE = 2'b01;\nlocalparam COMPLETE = 2'b10;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n        byte_count <= 2'b00;\n        message_buffer <= 24'b0;\n        done <= 1'b0;\n        out_bytes <= 24'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                done <= 1'b0;\n                if (in[3]) begin\n                    state <= RECEIVE;\n                    byte_count <= 2'b01;\n                    message_buffer[23:16] <= in;\n                end\n            end\n            RECEIVE: begin\n                if (byte_count == 2'b01) begin\n                    message_buffer[15:8] <= in;\n                    byte_count <= 2'b10;\n                end else if (byte_count == 2'b10) begin\n                    message_buffer[7:0] <= in;\n                    state <= COMPLETE;\n                end\n            end\n            COMPLETE: begin\n                out_bytes <= message_buffer;\n                done <= 1'b1;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] buffer;\n    reg [1:0] byte_count;\n\n    localparam IDLE = 2'b00, COLLECT = 2'b01, FINISH = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            buffer <= 24'b0;\n            byte_count <= 2'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == COLLECT) begin\n                buffer <= {buffer[15:0], in};\n                byte_count <= byte_count + 1'b1;\n            end\n            if (state == FINISH) begin\n                out_bytes <= buffer;\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? COLLECT : IDLE;\n            COLLECT: begin\n                if (byte_count == 2'b10)\n                    next_state = FINISH;\n                else\n                    next_state = COLLECT;\n            end\n            FINISH: next_state = (in[3]) ? COLLECT : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] message;\n    reg [1:0] byte_count;\n\n    parameter IDLE = 2'b00, COLLECT = 2'b01, FINISH = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            message <= 24'b0;\n            byte_count <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == COLLECT) begin\n                message <= {message[15:0], in};\n                byte_count <= byte_count + 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? COLLECT : IDLE;\n            COLLECT: next_state = (byte_count == 2'b10) ? FINISH : COLLECT;\n            FINISH: next_state = (in[3]) ? COLLECT : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    assign done = (state == FINISH);\n    assign out_bytes = (state == FINISH) ? message : 24'bx;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state;\n    reg [1:0] byte_count;\n    reg [23:0] message;\n\n    localparam IDLE = 2'b00;\n    localparam COLLECT = 2'b01;\n    localparam FINISH = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_count <= 0;\n            message <= 0;\n            done <= 0;\n            out_bytes <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (in[3]) begin\n                        state <= COLLECT;\n                        byte_count <= 1;\n                        message[23:16] <= in;\n                    end\n                end\n\n                COLLECT: begin\n                    if (byte_count == 1) begin\n                        message[15:8] <= in;\n                        byte_count <= 2;\n                    end else if (byte_count == 2) begin\n                        message[7:0] <= in;\n                        state <= FINISH;\n                    end\n                end\n\n                FINISH: begin\n                    out_bytes <= message;\n                    done <= 1;\n                    state <= IDLE;\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state;\n    reg [1:0] byte_count;\n    reg [23:0] message;\n\n    localparam IDLE = 2'b00;\n    localparam COLLECT = 2'b01;\n    localparam COMPLETE = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_count <= 2'b00;\n            message <= 24'b0;\n            done <= 1'b0;\n            out_bytes <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 1'b0;\n                    if (in[3]) begin\n                        state <= COLLECT;\n                        byte_count <= 2'b01;\n                        message[23:16] <= in;\n                    end\n                end\n                COLLECT: begin\n                    if (byte_count == 2'b01) begin\n                        message[15:8] <= in;\n                        byte_count <= 2'b10;\n                    end else if (byte_count == 2'b10) begin\n                        message[7:0] <= in;\n                        state <= COMPLETE;\n                    end\n                end\n                COMPLETE: begin\n                    out_bytes <= message;\n                    done <= 1'b1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\nreg [1:0] state;\nreg [7:0] byte1, byte2;\n\nparameter IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n        done <= 0;\n        out_bytes <= 24'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                done <= 0;\n                if (in[3]) begin\n                    state <= BYTE1;\n                    byte1 <= in;\n                end\n            end\n            BYTE1: begin\n                state <= BYTE2;\n                byte2 <= in;\n            end\n            BYTE2: begin\n                state <= BYTE3;\n                out_bytes <= {byte1, byte2, in};\n            end\n            BYTE3: begin\n                done <= 1;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] message;\n    reg [1:0] byte_count;\n\n    parameter IDLE = 2'b00, COLLECT = 2'b01, DONE = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            message <= 24'b0;\n            byte_count <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == COLLECT) begin\n                message <= {message[15:0], in};\n                byte_count <= byte_count + 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? COLLECT : IDLE;\n            COLLECT: begin\n                if (byte_count == 2'b10)\n                    next_state = DONE;\n                else\n                    next_state = COLLECT;\n            end\n            DONE: next_state = (in[3]) ? COLLECT : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    assign done = (state == DONE);\n    assign out_bytes = (state == DONE) ? message : 24'bx;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] buffer;\n    reg [1:0] byte_count;\n\n    localparam IDLE = 2'b00, RECEIVE = 2'b01, COMPLETE = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            buffer <= 24'b0;\n            byte_count <= 2'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == RECEIVE) begin\n                buffer <= {buffer[15:0], in};\n                byte_count <= byte_count + 1'b1;\n            end\n            if (state == COMPLETE) begin\n                out_bytes <= buffer;\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? RECEIVE : IDLE;\n            RECEIVE: begin\n                if (byte_count == 2'b10)\n                    next_state = COMPLETE;\n                else\n                    next_state = RECEIVE;\n            end\n            COMPLETE: next_state = (in[3]) ? RECEIVE : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state;\n    reg [7:0] byte1, byte2;\n\n    localparam IDLE = 2'b00;\n    localparam BYTE1 = 2'b01;\n    localparam BYTE2 = 2'b10;\n    localparam BYTE3 = 2'b11;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n            out_bytes <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (in[3]) begin\n                        state <= BYTE1;\n                        byte1 <= in;\n                    end\n                end\n                BYTE1: begin\n                    state <= BYTE2;\n                    byte2 <= in;\n                end\n                BYTE2: begin\n                    state <= BYTE3;\n                    out_bytes <= {byte1, byte2, in};\n                end\n                BYTE3: begin\n                    done <= 1;\n                    state <= IDLE;\n                    if (in[3]) begin\n                        state <= BYTE1;\n                        byte1 <= in;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state;\n    reg [7:0] byte1, byte2;\n    \n    localparam IDLE = 2'b00;\n    localparam BYTE1 = 2'b01;\n    localparam BYTE2 = 2'b10;\n    localparam BYTE3 = 2'b11;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n            out_bytes <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (in[3]) begin\n                        state <= BYTE1;\n                        byte1 <= in;\n                    end\n                end\n                BYTE1: begin\n                    state <= BYTE2;\n                    byte2 <= in;\n                end\n                BYTE2: begin\n                    state <= BYTE3;\n                    out_bytes <= {byte1, byte2, in};\n                end\n                BYTE3: begin\n                    done <= 1;\n                    state <= IDLE;\n                    if (in[3]) begin\n                        state <= BYTE1;\n                        byte1 <= in;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [7:0] byte1, byte2;\n    \n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_bytes <= 24'b0;\n            done <= 1'b0;\n            byte1 <= 8'b0;\n            byte2 <= 8'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                BYTE1: byte1 <= in;\n                BYTE2: byte2 <= in;\n                BYTE3: begin\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1'b1;\n                end\n                default: done <= 1'b0;\n            endcase\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = (in[3]) ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state;\n    reg [1:0] byte_count;\n    reg [23:0] message_buffer;\n\n    localparam IDLE = 2'b00, RECEIVE = 2'b01, COMPLETE = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_count <= 2'b00;\n            message_buffer <= 24'b0;\n            done <= 1'b0;\n            out_bytes <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 1'b0;\n                    if (in[3]) begin\n                        state <= RECEIVE;\n                        byte_count <= 2'b01;\n                        message_buffer[23:16] <= in;\n                    end\n                end\n                RECEIVE: begin\n                    if (byte_count == 2'b01) begin\n                        message_buffer[15:8] <= in;\n                        byte_count <= 2'b10;\n                    end else if (byte_count == 2'b10) begin\n                        message_buffer[7:0] <= in;\n                        state <= COMPLETE;\n                    end\n                end\n                COMPLETE: begin\n                    out_bytes <= message_buffer;\n                    done <= 1'b1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] buffer;\n    reg [1:0] byte_count;\n\n    localparam IDLE = 2'b00, COLLECT = 2'b01, FINISH = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            buffer <= 24'b0;\n            byte_count <= 2'b0;\n            done <= 1'b0;\n            out_bytes <= 24'b0;\n        end else begin\n            state <= next_state;\n            if (state == COLLECT) begin\n                buffer <= {buffer[15:0], in};\n                byte_count <= byte_count + 1'b1;\n            end\n            if (state == FINISH) begin\n                out_bytes <= buffer;\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? COLLECT : IDLE;\n            COLLECT: begin\n                if (byte_count == 2'b10)\n                    next_state = FINISH;\n                else\n                    next_state = COLLECT;\n            end\n            FINISH: next_state = (in[3]) ? COLLECT : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] message;\n    reg [1:0] byte_count;\n\n    localparam IDLE = 2'b00;\n    localparam COLLECT = 2'b01;\n    localparam FINISH = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            message <= 24'b0;\n            byte_count <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == COLLECT) begin\n                message <= {message[15:0], in};\n                byte_count <= byte_count + 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? COLLECT : IDLE;\n            COLLECT: next_state = (byte_count == 2'b10) ? FINISH : COLLECT;\n            FINISH: next_state = (in[3]) ? COLLECT : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    assign done = (state == FINISH);\n    assign out_bytes = (state == FINISH) ? message : 24'bx;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state;\n    reg [1:0] byte_count;\n    reg [23:0] message_buffer;\n\n    localparam IDLE = 2'b00;\n    localparam COLLECT = 2'b01;\n    localparam DONE = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_count <= 2'b00;\n            message_buffer <= 24'b0;\n            done <= 1'b0;\n            out_bytes <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 1'b0;\n                    if (in[3]) begin\n                        state <= COLLECT;\n                        byte_count <= 2'b01;\n                        message_buffer[23:16] <= in;\n                    end\n                end\n                COLLECT: begin\n                    if (byte_count == 2'b01) begin\n                        message_buffer[15:8] <= in;\n                        byte_count <= 2'b10;\n                    end else if (byte_count == 2'b10) begin\n                        message_buffer[7:0] <= in;\n                        state <= DONE;\n                    end\n                end\n                DONE: begin\n                    out_bytes <= message_buffer;\n                    done <= 1'b1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\nreg [1:0] state;\nreg [1:0] byte_count;\nreg [23:0] message;\n\nparameter IDLE = 2'b00;\nparameter COLLECT = 2'b01;\nparameter COMPLETE = 2'b10;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n        byte_count <= 2'b00;\n        message <= 24'b0;\n        done <= 1'b0;\n        out_bytes <= 24'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                done <= 1'b0;\n                if (in[3]) begin\n                    state <= COLLECT;\n                    byte_count <= 2'b01;\n                    message[23:16] <= in;\n                end\n            end\n            COLLECT: begin\n                if (byte_count == 2'b01) begin\n                    message[15:8] <= in;\n                    byte_count <= 2'b10;\n                end else if (byte_count == 2'b10) begin\n                    message[7:0] <= in;\n                    state <= COMPLETE;\n                end\n            end\n            COMPLETE: begin\n                out_bytes <= message;\n                done <= 1'b1;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [7:0] byte1, byte2;\n    \n    localparam IDLE = 2'b00;\n    localparam BYTE1 = 2'b01;\n    localparam BYTE2 = 2'b10;\n    localparam BYTE3 = 2'b11;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_bytes <= 24'b0;\n            done <= 1'b0;\n            byte1 <= 8'b0;\n            byte2 <= 8'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    done <= 1'b0;\n                    if (in[3]) byte1 <= in;\n                end\n                BYTE1: begin\n                    byte2 <= in;\n                end\n                BYTE2: begin\n                    out_bytes <= {byte1, byte2, in};\n                end\n                BYTE3: begin\n                    done <= 1'b1;\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] buffer;\n    reg [1:0] byte_count;\n\n    localparam IDLE = 2'b00;\n    localparam COLLECT = 2'b01;\n    localparam COMPLETE = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            buffer <= 24'b0;\n            byte_count <= 2'b0;\n            done <= 1'b0;\n            out_bytes <= 24'b0;\n        end else begin\n            state <= next_state;\n            if (state == COLLECT) begin\n                buffer <= {buffer[15:0], in};\n                byte_count <= byte_count + 1;\n            end\n            if (state == COMPLETE) begin\n                out_bytes <= buffer;\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (in[3]) next_state = COLLECT;\n            end\n            COLLECT: begin\n                if (byte_count == 2'b10) next_state = COMPLETE;\n            end\n            COMPLETE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [15:0] buffer;\n    \n    parameter IDLE = 2'b00;\n    parameter BYTE1 = 2'b01;\n    parameter BYTE2 = 2'b10;\n    parameter BYTE3 = 2'b11;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_bytes <= 24'b0;\n            done <= 1'b0;\n            buffer <= 16'b0;\n        end else begin\n            state <= next_state;\n            if (state == BYTE1) buffer[15:8] <= in;\n            if (state == BYTE2) buffer[7:0] <= in;\n            if (state == BYTE3) begin\n                out_bytes <= {buffer, in};\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = (in[3]) ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] message;\n    reg [1:0] byte_count;\n\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            message <= 24'b0;\n            byte_count <= 2'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state != IDLE) begin\n                message <= {message[15:0], in};\n                byte_count <= byte_count + 1'b1;\n            end\n            done <= (state == BYTE3);\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = (in[3]) ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(*) begin\n        if (done)\n            out_bytes = message;\n        else\n            out_bytes = 24'bx;\n    end\n\nendmodule"]}
{"task_id": "2012_q2b", "llmgen_RTL": ["module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule"]}
{"task_id": "vector0", "llmgen_RTL": ["module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule", "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"]}
{"task_id": "kmap4", "llmgen_RTL": ["module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111, \n        4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b1;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b1;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b0;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b0;\n            4'b1010: out = 1'b0;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b1;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b1;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b0;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b0;\n            4'b1010: out = 1'b0;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111,\n        4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        out = (a & ~b & ~c & d) | (~a & b & ~c & d) | (a & ~b & c & ~d) | (~a & b & c & ~d) |\n              (~a & ~b & ~c & ~d) | (a & b & ~c & ~d) | (~a & ~b & c & d) | (a & b & c & d);\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0001, 4'b0010, 4'b0100, 4'b0111, \n            4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111, \n        4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0001, 4'b0100, 4'b0111, 4'b1010: out = 1'b1;\n            4'b0010, 4'b0101, 4'b1000, 4'b1011: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111, \n        4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        out = (a ^ b) ^ (c ^ d);\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111, \n        4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 0;\n            4'b0001: out = 1;\n            4'b0010: out = 1;\n            4'b0011: out = 0;\n            4'b0100: out = 1;\n            4'b0101: out = 0;\n            4'b0110: out = 0;\n            4'b0111: out = 1;\n            4'b1000: out = 1;\n            4'b1001: out = 0;\n            4'b1010: out = 0;\n            4'b1011: out = 1;\n            4'b1100: out = 0;\n            4'b1101: out = 1;\n            4'b1110: out = 1;\n            4'b1111: out = 0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111, \n        4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b1;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b1;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b0;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b0;\n            4'b1010: out = 1'b0;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b1;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b1;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b0;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b0;\n            4'b1010: out = 1'b0;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111, 4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111, \n        4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0010, 4'b0100, 4'b0111, \n        4'b1001, 4'b1010, 4'b1100, 4'b1111: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b1;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b1;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b0;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b0;\n            4'b1010: out = 1'b0;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b1;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b1;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b0;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b0;\n            4'b1010: out = 1'b0;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b0;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "vector1", "llmgen_RTL": ["module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"]}
{"task_id": "norgate", "llmgen_RTL": ["module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\nassign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\nassign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a | b);\n\nendmodule"]}
{"task_id": "alwaysblock2", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // Using assign statement\n    assign out_assign = a ^ b;\n\n    // Using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n    \n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n    \n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // Using assign statement\n    assign out_assign = a ^ b;\n\n    // Using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // Using assign statement\n    assign out_assign = a ^ b;\n\n    // Using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"]}
{"task_id": "m2014_q6c", "llmgen_RTL": ["module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = (y[1] & ~w) | (y[3] & w);\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = (y[1] & ~w) | (y[3] & ~w);\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = y[1] & ~w;\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    assign Y2 = (y[1] & ~w) | (y[3] & ~w);\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule"]}
{"task_id": "mux256to1", "llmgen_RTL": ["module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n\tassign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n\tassign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n\tassign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n    assign out = in[sel];\n\nendmodule", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput out\n);\n\n    assign out = in[sel];\n\nendmodule"]}
{"task_id": "2014_q4a", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux1_out, mux2_out;\n\n    assign mux1_out = E ? w : Q;\n    assign mux2_out = L ? R : mux1_out;\n\n    always @(posedge clk) begin\n        Q <= mux2_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: Choose between shift and hold\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: Choose between load and shift/hold\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\n    assign mux_out = L ? R : (E ? w : Q);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: Choose between shift (w) and hold (Q)\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: Choose between load (R) and shift/hold (mux_out)\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: Choose between holding current value or shifting\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: Choose between shift/hold result and load value\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: Choose between w (shift) and Q (hold)\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: Choose between R (load) and the output of the first mux\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux1_out, mux2_out;\n\n    // First multiplexer: Choose between holding current value (Q) or shifting (w)\n    assign mux1_out = E ? w : Q;\n\n    // Second multiplexer: Choose between shift/hold result or loading new value (R)\n    assign mux2_out = L ? R : mux1_out;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux2_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: Choose between holding current value or shifting\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: Choose between shift/hold result or loading R\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: select between holding current value and shifting\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: select between shift/hold and load\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: Choose between holding current value or shifting\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: Choose between shift/hold result and load value\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux1_out;\n    wire mux2_out;\n\n    assign mux1_out = E ? w : Q;\n    assign mux2_out = L ? R : mux1_out;\n\n    always @(posedge clk) begin\n        Q <= mux2_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: choose between holding current value and shifting\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: choose between shift/hold and load\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: select between holding current value and shifting\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: select between shift/hold and load\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: choose between holding current value (Q) or shifting (w)\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: choose between shift/hold (mux_out) or load (R)\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: Select between holding current value or shifting\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: Select between shift/hold result and load value\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux1_out;\n    wire mux2_out;\n\n    assign mux1_out = E ? w : Q;\n    assign mux2_out = L ? R : mux1_out;\n\n    always @(posedge clk) begin\n        Q <= mux2_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n    \n    // First multiplexer: selects between holding current value and shifting\n    assign mux_out = E ? w : Q;\n    \n    // Second multiplexer: selects between shift/hold and load\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    assign mux_out = L ? R : (E ? w : Q);\n\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // First multiplexer: select between holding current value or shifting\n    assign mux_out = E ? w : Q;\n\n    // Second multiplexer: select between shift/hold result and load value\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else\n            Q <= mux_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n    wire mux_out;\n    \n    assign mux_out = L ? R : (E ? w : Q);\n    \n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule"]}
{"task_id": "ece241_2014_q4", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg [2:0] state;\n\n    wire xor_out, and_out, or_out;\n\n    assign xor_out = x ^ state[2];\n    assign and_out = x & ~state[1];\n    assign or_out = x | ~state[0];\n\n    always @(posedge clk) begin\n        state[2] <= xor_out;\n        state[1] <= and_out;\n        state[0] <= or_out;\n    end\n\n    assign z = ~(state[2] ^ state[1] ^ state[0]);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"]}
{"task_id": "circuit4", "llmgen_RTL": ["module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | c) & (~a | ~d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | c | d) & (~a | c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | c | d) & (~a | c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | c | d) & (~a | c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | c | d) & (~a | c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | c | d) & ~(a & ~b & ~c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | c | d) & (~a | c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | c) & (~a | ~d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = b | c | (a & d);\n\nendmodule"]}
{"task_id": "rule110", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg [511:0] next_q;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0 ? q[i-1] : 1'b0), q[i], (i < 511 ? q[i+1] : 1'b0)})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg [511:0] next_q;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0 ? q[i-1] : 1'b0), q[i], (i < 511 ? q[i+1] : 1'b0)})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= (q[510] | q[511]) & ~(q[510] & q[511]);\n            \n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= (q[i-1] | q[i] | q[i+1]) & ~(q[i-1] & q[i] & q[i+1]);\n            end\n            \n            q[0] <= (q[0] | q[1]) & ~(q[0] & q[1]);\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg [511:0] next_q;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0 ? 1'b0 : q[i-1]), q[i], (i == 511 ? 1'b0 : q[i+1])})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg left, center, right;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            for (i = 0; i < 512; i = i + 1) begin\n                left = (i == 0) ? 1'b0 : q[i-1];\n                center = q[i];\n                right = (i == 511) ? 1'b0 : q[i+1];\n\n                case ({left, center, right})\n                    3'b111: q[i] <= 1'b0;\n                    3'b110: q[i] <= 1'b1;\n                    3'b101: q[i] <= 1'b1;\n                    3'b100: q[i] <= 1'b0;\n                    3'b011: q[i] <= 1'b1;\n                    3'b010: q[i] <= 1'b1;\n                    3'b001: q[i] <= 1'b1;\n                    3'b000: q[i] <= 1'b0;\n                endcase\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg [511:0] next_q;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0 ? 1'b0 : q[i-1]), q[i], (i == 511 ? 1'b0 : q[i+1])})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0 ? 1'b0 : q[i-1]), q[i], (i == 511 ? 1'b0 : q[i+1])})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0 ? 1'b0 : q[i-1]), q[i], (i == 511 ? 1'b0 : q[i+1])})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg [511:0] next_q;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0 ? 1'b0 : q[i-1]), q[i], (i == 511 ? 1'b0 : q[i+1])})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0 ? q[i-1] : 1'b0), q[i], (i < 511 ? q[i+1] : 1'b0)})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    reg [513:0] extended_q;\n    integer i;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            extended_q = {1'b0, q, 1'b0};\n            for (i = 0; i < 512; i = i + 1) begin\n                case ({extended_q[i+2], extended_q[i+1], extended_q[i]})\n                    3'b111: q[i] <= 1'b0;\n                    3'b110: q[i] <= 1'b1;\n                    3'b101: q[i] <= 1'b1;\n                    3'b100: q[i] <= 1'b0;\n                    3'b011: q[i] <= 1'b1;\n                    3'b010: q[i] <= 1'b1;\n                    3'b001: q[i] <= 1'b1;\n                    3'b000: q[i] <= 1'b0;\n                endcase\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0 ? 1'b0 : q[i-1]), q[i], (i == 511 ? 1'b0 : q[i+1])})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0 ? q[i-1] : 1'b0), q[i], (i < 511 ? q[i+1] : 1'b0)})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510] | (~q[511] & q[510]);\n            \n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= (q[i-1] & q[i] & ~q[i+1]) | (q[i-1] & ~q[i]) | (~q[i-1] & q[i+1]);\n            end\n            \n            q[0] <= q[1] | (~q[0] & q[1]);\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg [511:0] next_q;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0 ? q[i-1] : 1'b0), q[i], (i < 511 ? q[i+1] : 1'b0)})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510] | (q[511] & ~q[510]);\n            \n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= (q[i-1] & q[i] & ~q[i+1]) | \n                        (q[i-1] & ~q[i] & q[i+1]) | \n                        (~q[i-1] & q[i+1]);\n            end\n            \n            q[0] <= q[1] | (q[0] & ~q[1]);\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= (q[511] & ~q[510]) | (~q[511] & q[510]);\n            \n            genvar i;\n            for (i = 1; i < 511; i = i + 1) begin : rule110_gen\n                q[i] <= (q[i+1] & q[i] & ~q[i-1]) | (q[i+1] & ~q[i]) | (~q[i+1] & q[i-1]);\n            end\n            \n            q[0] <= (q[1] & q[0]) | (~q[1] & 1'b0);\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg [511:0] next_q;\n\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0 ? 1'b0 : q[i-1]), q[i], (i == 511 ? 1'b0 : q[i+1])})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    integer i;\n    reg left, center, right;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            for (i = 0; i < 512; i = i + 1) begin\n                left = (i == 0) ? 1'b0 : q[i-1];\n                center = q[i];\n                right = (i == 511) ? 1'b0 : q[i+1];\n\n                case ({left, center, right})\n                    3'b111: q[i] <= 1'b0;\n                    3'b110: q[i] <= 1'b1;\n                    3'b101: q[i] <= 1'b1;\n                    3'b100: q[i] <= 1'b0;\n                    3'b011: q[i] <= 1'b1;\n                    3'b010: q[i] <= 1'b1;\n                    3'b001: q[i] <= 1'b1;\n                    3'b000: q[i] <= 1'b0;\n                endcase\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510] | (~q[511] & q[510]);\n            \n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= (q[i-1] & q[i] & ~q[i+1]) | (q[i-1] & ~q[i]) | (~q[i-1] & q[i+1]);\n            end\n            \n            q[0] <= q[0] | q[1];\n        end\n    end\n\nendmodule"]}
{"task_id": "fsm3s", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\treg [1:0] state, next_state;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\t\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\treg [1:0] state, next_state;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\t\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign out = (state == D);\n\nendmodule"]}
{"task_id": "circuit5", "llmgen_RTL": ["module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'h0: q = b;\n            4'h1: q = e;\n            4'h2: q = a;\n            4'h3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\nalways @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "bugs_mux2", "llmgen_RTL": ["module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule"]}
{"task_id": "mt2015_muxdff", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n    \n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n    \n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    sub_module sm (\n        .clk(clk),\n        .L(L),\n        .q_in(q_in),\n        .r_in(r_in),\n        .Q(Q)\n    );\n\nendmodule\n\nmodule sub_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n    wire mux_out;\n\n    assign mux_out = L ? r_in : q_in;\n\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q\n);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // D Flip-flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule"]}
{"task_id": "edgecapture", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        prev_in <= 32'b0;\n    end else begin\n        prev_in <= in;\n        out <= (out | (~in & prev_in));\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] in_prev;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            in_prev <= 32'b0;\n        end else begin\n            in_prev <= in;\n            out <= out | (~in & in_prev);\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n\treg [31:0] prev_in;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tout <= 32'b0;\n\t\t\tprev_in <= 32'b0;\n\t\tend else begin\n\t\t\tprev_in <= in;\n\t\t\tout <= (out | (~in & prev_in));\n\t\tend\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (~in & prev_in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (~in & prev_in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        prev_in <= 32'b0;\n    end else begin\n        prev_in <= in;\n        out <= (out | (~in & prev_in));\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (~in & prev_in));\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= out | (prev_in & ~in);\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (prev_in & ~in));\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= out | (prev_in & ~in);\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n\treg [31:0] prev_in;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tout <= 32'b0;\n\t\t\tprev_in <= 32'b0;\n\t\tend else begin\n\t\t\tprev_in <= in;\n\t\t\tout <= (out | (~in & prev_in));\n\t\tend\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= (out | (~in & prev_in));\n        end\n    end\n\nendmodule"]}
{"task_id": "dff8", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"]}
{"task_id": "ece241_2014_q1c", "llmgen_RTL": ["module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n    \n    assign s = a + b;\n    \n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n\n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [8:0] sum;\n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\n    wire [8:0] sum;\n    \n    assign sum = {a[7], a} + {b[7], b};\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule"]}
{"task_id": "review2015_fsmonehot", "llmgen_RTL": ["module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n    \n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding\n    wire S    = state[0];\n    wire S1   = state[1];\n    wire S11  = state[2];\n    wire S110 = state[3];\n    wire B0   = state[4];\n    wire B1   = state[5];\n    wire B2   = state[6];\n    wire B3   = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | Count & ~done_counting;\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encodings\n    wire S = state[0];\n    wire S1 = state[1];\n    wire S11 = state[2];\n    wire S110 = state[3];\n    wire B0 = state[4];\n    wire B1 = state[5];\n    wire B2 = state[6];\n    wire B3 = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign B3_next = B2;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = (Count & done_counting) | (Wait & ~ack);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State aliases\n    wire S = state[0];\n    wire S1 = state[1];\n    wire S11 = state[2];\n    wire S110 = state[3];\n    wire B0 = state[4];\n    wire B1 = state[5];\n    wire B2 = state[6];\n    wire B3 = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign B3_next = B2;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = (Count & done_counting) | (Wait & ~ack);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding\n    wire S = state[0];\n    wire S1 = state[1];\n    wire S11 = state[2];\n    wire S110 = state[3];\n    wire B0 = state[4];\n    wire B1 = state[5];\n    wire B2 = state[6];\n    wire B3 = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign B3_next = B2;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = (Count & done_counting) | (Wait & ~ack);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding\n    wire S = state[0];\n    wire S1 = state[1];\n    wire S11 = state[2];\n    wire S110 = state[3];\n    wire B0 = state[4];\n    wire B1 = state[5];\n    wire B2 = state[6];\n    wire B3 = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign B3_next = B2;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = (Count & done_counting) | (Wait & ~ack);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encodings\n    wire S = state[0];\n    wire S1 = state[1];\n    wire S11 = state[2];\n    wire S110 = state[3];\n    wire B0 = state[4];\n    wire B1 = state[5];\n    wire B2 = state[6];\n    wire B3 = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign B3_next = B2;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = (Count & done_counting) | (Wait & ~ack);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State aliases\n    wire S = state[0];\n    wire S1 = state[1];\n    wire S11 = state[2];\n    wire S110 = state[3];\n    wire B0 = state[4];\n    wire B1 = state[5];\n    wire B2 = state[6];\n    wire B3 = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign B3_next = B2;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = (Count & done_counting) | (Wait & ~ack);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S = state[0];\n    wire S1 = state[1];\n    wire S11 = state[2];\n    wire S110 = state[3];\n    wire B0 = state[4];\n    wire B1 = state[5];\n    wire B2 = state[6];\n    wire B3 = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    assign B3_next = B2;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = (Count & done_counting) | (Wait & ~ack);\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | Count & ~done_counting;\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | Count & ~done_counting;\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding\n    wire S = state[0];\n    wire S1 = state[1];\n    wire S11 = state[2];\n    wire S110 = state[3];\n    wire B0 = state[4];\n    wire B1 = state[5];\n    wire B2 = state[6];\n    wire B3 = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign B3_next = B2;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = (Count & done_counting) | (Wait & ~ack);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign {Wait, Count, B3, B2, B1, B0, S110, S11, S1, S} = state;\n\n    assign B3_next = B2;\n    assign S_next = S & ~d | S1 & ~d | S110 & ~d | Wait & ack;\n    assign S1_next = S & d;\n    assign Count_next = B3 | (Count & ~done_counting);\n    assign Wait_next = Count & done_counting | Wait & ~ack;\n\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule"]}
{"task_id": "counter_2bc", "llmgen_RTL": ["module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;  // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1;  // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1;  // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n        // When train_valid is 0, state remains unchanged\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1;\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;  // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1;  // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1;  // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;  // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1;  // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1;  // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                state <= (state == 2'b11) ? 2'b11 : state + 1'b1; // Increment up to 3\n            end else begin\n                state <= (state == 2'b00) ? 2'b00 : state - 1'b1; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule"]}
{"task_id": "always_casez", "llmgen_RTL": ["module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'bzzzzzzz1: pos = 3'd0;\n        8'bzzzzzz10: pos = 3'd1;\n        8'bzzzzz100: pos = 3'd2;\n        8'bzzzz1000: pos = 3'd3;\n        8'bzzz10000: pos = 3'd4;\n        8'bzz100000: pos = 3'd5;\n        8'bz1000000: pos = 3'd6;\n        8'b10000000: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    if (in[0]) pos = 3'd0;\n    else if (in[1]) pos = 3'd1;\n    else if (in[2]) pos = 3'd2;\n    else if (in[3]) pos = 3'd3;\n    else if (in[4]) pos = 3'd4;\n    else if (in[5]) pos = 3'd5;\n    else if (in[6]) pos = 3'd6;\n    else if (in[7]) pos = 3'd7;\n    else pos = 3'd0;\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'bzzzzzzz1: pos = 3'd0;\n        8'bzzzzzz10: pos = 3'd1;\n        8'bzzzzz100: pos = 3'd2;\n        8'bzzzz1000: pos = 3'd3;\n        8'bzzz10000: pos = 3'd4;\n        8'bzz100000: pos = 3'd5;\n        8'bz1000000: pos = 3'd6;\n        8'b10000000: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule"]}
{"task_id": "always_nolatches", "llmgen_RTL": ["module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n        \n        case(scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                left = 1'b0;\n                down = 1'b0;\n                right = 1'b0;\n                up = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n        \n        case(scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                left = 1'b0;\n                down = 1'b0;\n                right = 1'b0;\n                up = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case(scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        // Default values\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n\n        case(scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                left = 1'b0;\n                down = 1'b0;\n                right = 1'b0;\n                up = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    \n    case(scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        // Default all outputs to 0\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n\n        case(scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                // No arrow key pressed, all outputs remain 0\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n\n        case (scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                left = 1'b0;\n                down = 1'b0;\n                right = 1'b0;\n                up = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case(scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        // Default all outputs to 0\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n\n        case(scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                left = 1'b0;\n                down = 1'b0;\n                right = 1'b0;\n                up = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @(*) begin\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n        \n        case (scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                left = 1'b0;\n                down = 1'b0;\n                right = 1'b0;\n                up = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n        \n        case (scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                left = 1'b0;\n                down = 1'b0;\n                right = 1'b0;\n                up = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n        \n        case (scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: begin\n                left = 1'b0;\n                down = 1'b0;\n                right = 1'b0;\n                up = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case(scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case(scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n    always @(*) begin\n        // Default all outputs to 0\n        left = 1'b0;\n        down = 1'b0;\n        right = 1'b0;\n        up = 1'b0;\n\n        case (scancode)\n            16'he06b: left = 1'b1;\n            16'he072: down = 1'b1;\n            16'he074: right = 1'b1;\n            16'he075: up = 1'b1;\n            default: ; // No action for other scancodes\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n\n    case(scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\n\nendmodule"]}
{"task_id": "m2014_q4j", "llmgen_RTL": ["module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0),  .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0),  .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n    \n    wire [3:0] carry;\n    \n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0),  .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0),  .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n    \n    wire [3:0] carry;\n    \n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n    \n    wire [3:0] carry;\n    \n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n    \n    wire [3:0] carry;\n    \n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0),  .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"]}
{"task_id": "history_shift", "llmgen_RTL": ["module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else begin\n            if (train_mispredicted) begin\n                predict_history <= {train_history[30:0], train_taken};\n            end\n            else if (predict_valid) begin\n                predict_history <= {predict_history[30:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule"]}
{"task_id": "wire_decl", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n    wire and1_out, and2_out;\n\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n    assign out = and1_out | and2_out;\n    assign out_n = ~out;\n\nendmodule"]}
{"task_id": "dff", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\t\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"]}
{"task_id": "ece241_2013_q12", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] select;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    assign select = {A, B, C};\n\n    always @(*) begin\n        case (select)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] select;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign select = {A, B, C};\n\n    always @(*) begin\n        case(select)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\nreg [7:0] Q;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        Q <= {Q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = Q[0];\n        3'b001: Z = Q[1];\n        3'b010: Z = Q[2];\n        3'b011: Z = Q[3];\n        3'b100: Z = Q[4];\n        3'b101: Z = Q[5];\n        3'b110: Z = Q[6];\n        3'b111: Z = Q[7];\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\nreg [7:0] Q;\nwire [2:0] sel;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        Q <= {Q[6:0], S};\n    end\nend\n\nassign sel = {A, B, C};\n\nalways @(*) begin\n    case (sel)\n        3'b000: Z = Q[0];\n        3'b001: Z = Q[1];\n        3'b010: Z = Q[2];\n        3'b011: Z = Q[3];\n        3'b100: Z = Q[4];\n        3'b101: Z = Q[5];\n        3'b110: Z = Q[6];\n        3'b111: Z = Q[7];\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\nreg [7:0] Q;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        Q <= {Q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = Q[0];\n        3'b001: Z = Q[1];\n        3'b010: Z = Q[2];\n        3'b011: Z = Q[3];\n        3'b100: Z = Q[4];\n        3'b101: Z = Q[5];\n        3'b110: Z = Q[6];\n        3'b111: Z = Q[7];\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case(sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] sel;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign sel = {A, B, C};\n\n    always @(*) begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] select;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    assign select = {A, B, C};\n\n    always @(*) begin\n        case (select)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n    reg [7:0] Q;\n    wire [2:0] select;\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {S, Q[7:1]};\n    end\n\n    assign select = {A, B, C};\n\n    always @(*) begin\n        case (select)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"]}
{"task_id": "thermostat", "llmgen_RTL": ["module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule", "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = heater | aircon | fan_on;\n\nendmodule"]}
{"task_id": "ece241_2013_q2", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & c & d) | (~a & ~b & c & ~d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | ~b | c | d) & (~a | b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // SOP form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // POS form\n    assign out_pos = (a | b | c) & (a | c | d) & (~a | b | c) & (~a | b | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & c & d) | (~a & ~b & c & ~d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | ~b | c | d) & (~a | b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) & (b | c | d) & (~a | ~b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | // 2\n                     (a & b & c & ~d) |  // 7\n                     (a & b & c & d);    // 15\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) &\n                     (b | c | d) &\n                     (a | b | d) &\n                     (a | b | c);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) & (b | c | d) & (~a | b | c | d) & (~a | ~b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & c & d) | (~a & ~b & c & ~d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (~a | b | ~c | d) & (~a | ~b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & c & ~d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | ~b | c | d) & (~a | b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | ~b | ~c | d) & (~a | b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & c & d) | (~a & ~b & c & ~d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | ~b | c | d) & (~a | b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & c & ~d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | b | ~c | d) & \n                     (a | ~b | c | d) & (~a | b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) & (b | c | d) & (~a | ~b | c) & (~a | b | ~c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | ~b | ~c | d) & (~a | b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & c & d) | (~a & ~b & c & ~d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (~a | b | c | d) & (~a | ~b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) & (b | c | d) & (~a | b | c | d) & (~a | ~b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) & (b | c | d) & (~a | b | ~c | d) & (~a | ~b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n\t// Sum-of-Products (SOP) form\n\tassign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n\t// Product-of-Sums (POS) form\n\tassign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | b | ~c | d) & (a | ~b | c | d) & (~a | b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) & (b | c | d) & (~a | ~b | c | d);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | // 2\n                     (a & b & c & ~d) |  // 7\n                     (a & b & c & d);    // 15\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) &\n                     (b | c | d) &\n                     (a | b | c);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & c & d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | c | d) & (b | c | d) & (a | b | c);\n\nendmodule"]}
{"task_id": "lfsr32", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= {q[0] ^ q[1] ^ q[21] ^ q[31], q[31:1]};\n        end\n    end\n\nendmodule"]}
{"task_id": "circuit3", "llmgen_RTL": ["module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | a) & (c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | a) & (c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | a) & (c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | a) & (c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | a) & (c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b | a) & (c | d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (b & d) | (b & c) | (a & d) | (a & c);\n\nendmodule"]}
{"task_id": "7420", "llmgen_RTL": ["module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n    \n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"]}
{"task_id": "popcount255", "llmgen_RTL": ["module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    reg [7:0] count;\n\n    always @(*) begin\n        count = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            count = count + in[i];\n        end\n        out = count;\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    always @(*) begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i] == 1'b1)\n            count = count + 1'b1;\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    reg [7:0] count;\n\n    always @(*) begin\n        count = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            if (in[i] == 1'b1)\n                count = count + 8'd1;\n        end\n        out = count;\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    always @(*) begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @(*) begin\n        out = 8'b0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    reg [7:0] count;\n\n    always @(*) begin\n        count = 8'b0;\n        for (i = 0; i < 255; i = i + 1) begin\n            count = count + in[i];\n        end\n        out = count;\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    reg [7:0] count;\n\n    always @(*) begin\n        count = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            count = count + in[i];\n        end\n        out = count;\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n    integer i;\n    reg [7:0] count;\n\n    always @(*) begin\n        count = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            count = count + in[i];\n        end\n        out = count;\n    end\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*) begin\n    count = 8'd0;\n    for (i = 0; i < 255; i = i + 1) begin\n        count = count + in[i];\n    end\n    out = count;\nend\n\nendmodule"]}
{"task_id": "gatesv", "llmgen_RTL": ["module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[2];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[0] = in[0] ^ in[3];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule"]}
{"task_id": "circuit6", "llmgen_RTL": ["module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n    always @(*) begin\n        case(a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n    \n    always @(*) begin\n        case(a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n    always @(*) begin\n        case(a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n    always @(*) begin\n        case(a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\nalways @(*) begin\n    case(a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n    always @(*) begin\n        case(a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "countslow", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena)\n            q <= (q == 4'd9) ? 4'd0 : q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena)\n            q <= (q == 4'd9) ? 4'd0 : q + 4'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena)\n            q <= (q == 4'd9) ? 4'd0 : q + 4'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena)\n            q <= (q == 4'd9) ? 4'd0 : q + 4'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 1'd1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'b0000;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 1'd1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 1'd1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena)\n            q <= (q == 4'd9) ? 4'd0 : q + 4'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 1'd1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1'd1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'b0000;\n            else\n                q <= q + 1'b1;\n        end\n    end\n\nendmodule"]}
{"task_id": "m2014_q4f", "llmgen_RTL": ["module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule"]}
{"task_id": "m2014_q4h", "llmgen_RTL": ["module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule"]}
{"task_id": "fsm1", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\n    parameter A = 1'b0;\n    parameter B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = state;\n\nendmodule"]}
{"task_id": "dualedge", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n\treg q1, q2;\n\n\talways @(posedge clk) begin\n\t\tq1 <= d;\n\tend\n\n\talways @(negedge clk) begin\n\t\tq2 <= d;\n\tend\n\n\talways @(*) begin\n\t\tq = clk ? q1 : q2;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk ? q1 : q2;\nend\n\nendmodule"]}
{"task_id": "xnorgate", "llmgen_RTL": ["module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\nassign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a ^ b);\n\nendmodule"]}
{"task_id": "mt2015_q4", "llmgen_RTL": ["module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nwire a1_out, a2_out, b1_out, b2_out;\nwire or_out, and_out;\n\n// Module A instances\nA a1 (.x(x), .y(y), .z(a1_out));\nA a2 (.x(x), .y(y), .z(a2_out));\n\n// Module B instances\nB b1 (.x(x), .y(y), .z(b1_out));\nB b2 (.x(x), .y(y), .z(b2_out));\n\n// OR gate\nassign or_out = a1_out | b1_out;\n\n// AND gate\nassign and_out = a2_out & b2_out;\n\n// XOR gate\nassign z = or_out ^ and_out;\n\nendmodule\n\nmodule A(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n\nalways @(*) begin\n    if (x == 1'b0 && y == 1'b0)\n        z = 1'b1;\n    else if (x == 1'b1 && y == 1'b1)\n        z = 1'b1;\n    else\n        z = 1'b0;\nend\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nwire a1_out, a2_out, b1_out, b2_out;\nwire or_out, and_out;\n\n// Module A instances\nA a1 (.x(x), .y(y), .z(a1_out));\nA a2 (.x(x), .y(y), .z(a2_out));\n\n// Module B instances\nB b1 (.x(x), .y(y), .z(b1_out));\nB b2 (.x(x), .y(y), .z(b2_out));\n\n// OR gate\nassign or_out = a1_out | b1_out;\n\n// AND gate\nassign and_out = a2_out & b2_out;\n\n// XOR gate\nassign z = or_out ^ and_out;\n\nendmodule\n\nmodule A(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n\nalways @(*) begin\n    if (x == 1'b0 && y == 1'b0)\n        z = 1'b1;\n    else if (x == 1'b1 && y == 1'b1)\n        z = 1'b1;\n    else\n        z = 1'b0;\nend\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Module A instances\n    assign a1_out = (x ^ y) & x;\n    assign a2_out = (x ^ y) & x;\n\n    // Module B instances\n    assign b1_out = (~x & ~y) | (x & y);\n    assign b2_out = (~x & ~y) | (x & y);\n\n    // OR gate\n    assign or_out = a1_out | b1_out;\n\n    // AND gate\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nwire z_a1, z_b1, z_a2, z_b2;\nwire or_out, and_out;\n\n// Module A implementations\nassign z_a1 = (x ^ y) & x;\nassign z_a2 = (x ^ y) & x;\n\n// Module B implementations\nreg z_b1_reg, z_b2_reg;\n\nalways @(*) begin\n    if (x == 0 && y == 0)\n        z_b1_reg = 1;\n    else if (x == 1 && y == 1)\n        z_b1_reg = 1;\n    else\n        z_b1_reg = 0;\nend\n\nalways @(*) begin\n    if (x == 0 && y == 0)\n        z_b2_reg = 1;\n    else if (x == 1 && y == 1)\n        z_b2_reg = 1;\n    else\n        z_b2_reg = 0;\nend\n\nassign z_b1 = z_b1_reg;\nassign z_b2 = z_b2_reg;\n\n// OR and AND gates\nassign or_out = z_a1 | z_b1;\nassign and_out = z_a2 & z_b2;\n\n// Final XOR\nassign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nwire z_a1, z_b1, z_a2, z_b2;\nwire or_out, and_out;\n\n// Module A instances\nA a1 (.x(x), .y(y), .z(z_a1));\nA a2 (.x(x), .y(y), .z(z_a2));\n\n// Module B instances\nB b1 (.x(x), .y(y), .z(z_b1));\nB b2 (.x(x), .y(y), .z(z_b2));\n\n// OR gate\nassign or_out = z_a1 | z_b1;\n\n// AND gate\nassign and_out = z_a2 & z_b2;\n\n// XOR gate\nassign z = or_out ^ and_out;\n\nendmodule\n\nmodule A(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nassign z = (x^y) & x;\n\nendmodule\n\nmodule B(\n\tinput x,\n\tinput y,\n\toutput reg z\n);\n\nalways @(*) begin\n\tif (x == 0 && y == 0)\n\t\tz = 1;\n\telse if (x == 1 && y == 1)\n\t\tz = 1;\n\telse\n\t\tz = 0;\nend\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n    \n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n    \n    // Module A instances\n    module_a a1 (.x(x), .y(y), .z(a1_out));\n    module_a a2 (.x(x), .y(y), .z(a2_out));\n    \n    // Module B instances\n    module_b b1 (.x(x), .y(y), .z(b1_out));\n    module_b b2 (.x(x), .y(y), .z(b2_out));\n    \n    // OR gate\n    assign or_out = a1_out | b1_out;\n    \n    // AND gate\n    assign and_out = a2_out & b2_out;\n    \n    // XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule\n\nmodule module_a(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule module_b(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        if (x == 0 && y == 0)\n            z = 1;\n        else if (x == 1 && y == 1)\n            z = 1;\n        else\n            z = 0;\n    end\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    wire z_a1, z_b1, z_a2, z_b2;\n    wire or_out, and_out;\n\n    // Module A instances\n    assign z_a1 = (x ^ y) & x;\n    assign z_a2 = (x ^ y) & x;\n\n    // Module B instances\n    assign z_b1 = (~x & ~y) | (x & y);\n    assign z_b2 = (~x & ~y) | (x & y);\n\n    // OR gate\n    assign or_out = z_a1 | z_b1;\n\n    // AND gate\n    assign and_out = z_a2 & z_b2;\n\n    // XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Module A instances\n    assign a1_out = (x ^ y) & x;\n    assign a2_out = (x ^ y) & x;\n\n    // Module B instances\n    assign b1_out = (~x & ~y) | (x & y);\n    assign b2_out = (~x & ~y) | (x & y);\n\n    // OR gate\n    assign or_out = a1_out | b1_out;\n\n    // AND gate\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate for final output\n    assign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire a1_out, a2_out, b1_out, b2_out;\n\twire or_out, and_out;\n\n\t// Module A instances\n\tassign a1_out = (x ^ y) & x;\n\tassign a2_out = (x ^ y) & x;\n\n\t// Module B instances\n\treg b1_reg, b2_reg;\n\n\talways @(*) begin\n\t\tcase ({x, y})\n\t\t\t2'b00: {b1_reg, b2_reg} = 2'b11;\n\t\t\t2'b01: {b1_reg, b2_reg} = 2'b00;\n\t\t\t2'b10: {b1_reg, b2_reg} = 2'b00;\n\t\t\t2'b11: {b1_reg, b2_reg} = 2'b11;\n\t\tendcase\n\tend\n\n\tassign b1_out = b1_reg;\n\tassign b2_out = b2_reg;\n\n\t// OR gate\n\tassign or_out = a1_out | b1_out;\n\n\t// AND gate\n\tassign and_out = a2_out & b2_out;\n\n\t// XOR gate\n\tassign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Module A instances\n    assign a1_out = (x ^ y) & x;\n    assign a2_out = (x ^ y) & x;\n\n    // Module B instances\n    assign b1_out = (~x & ~y) | (x & y);\n    assign b2_out = (~x & ~y) | (x & y);\n\n    // OR gate\n    assign or_out = a1_out | b1_out;\n\n    // AND gate\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nwire a_out1, a_out2, b_out1, b_out2;\nwire or_out, and_out;\n\n// Module A instances\nA a1 (.x(x), .y(y), .z(a_out1));\nA a2 (.x(x), .y(y), .z(a_out2));\n\n// Module B instances\nB b1 (.x(x), .y(y), .z(b_out1));\nB b2 (.x(x), .y(y), .z(b_out2));\n\n// OR gate\nassign or_out = a_out1 | b_out1;\n\n// AND gate\nassign and_out = a_out2 & b_out2;\n\n// XOR gate\nassign z = or_out ^ and_out;\n\nendmodule\n\n// Module A implementation\nmodule A(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n\n// Module B implementation\nmodule B(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nassign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    wire z_a1, z_b1, z_a2, z_b2;\n    wire or_out, and_out;\n\n    // Module A instances\n    assign z_a1 = (x ^ y) & x;\n    assign z_a2 = (x ^ y) & x;\n\n    // Module B instances\n    assign z_b1 = (~x & ~y) | (x & y);\n    assign z_b2 = (~x & ~y) | (x & y);\n\n    // OR gate\n    assign or_out = z_a1 | z_b1;\n\n    // AND gate\n    assign and_out = z_a2 & z_b2;\n\n    // XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire a1_out, a2_out, b1_out, b2_out;\n\twire or_out, and_out;\n\n\t// Instantiate A modules\n\tA a1 (.x(x), .y(y), .z(a1_out));\n\tA a2 (.x(x), .y(y), .z(a2_out));\n\n\t// Instantiate B modules\n\tB b1 (.x(x), .y(y), .z(b1_out));\n\tB b2 (.x(x), .y(y), .z(b2_out));\n\n\t// OR gate\n\tassign or_out = a1_out | b1_out;\n\n\t// AND gate\n\tassign and_out = a2_out & b2_out;\n\n\t// XOR gate\n\tassign z = or_out ^ and_out;\n\nendmodule\n\nmodule A(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\tassign z = (x ^ y) & x;\n\nendmodule\n\nmodule B(\n\tinput x,\n\tinput y,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tif (x == 0 && y == 0)\n\t\t\tz = 1;\n\t\telse if (x == 1 && y == 1)\n\t\t\tz = 1;\n\t\telse\n\t\t\tz = 0;\n\tend\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    wire z_a1, z_b1, z_a2, z_b2;\n    wire or_out, and_out;\n\n    // Module A instances\n    assign z_a1 = (x ^ y) & x;\n    assign z_a2 = (x ^ y) & x;\n\n    // Module B instances\n    assign z_b1 = (~x & ~y) | (x & y);\n    assign z_b2 = (~x & ~y) | (x & y);\n\n    // OR gate\n    assign or_out = z_a1 | z_b1;\n\n    // AND gate\n    assign and_out = z_a2 & z_b2;\n\n    // XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n\twire z_a1, z_b1, z_a2, z_b2;\n\twire or_out, and_out;\n\n\t// Module A instances\n\tassign z_a1 = (x ^ y) & x;\n\tassign z_a2 = (x ^ y) & x;\n\n\t// Module B instances\n\tassign z_b1 = (~x & ~y) | (x & y);\n\tassign z_b2 = (~x & ~y) | (x & y);\n\n\t// OR gate\n\tassign or_out = z_a1 | z_b1;\n\n\t// AND gate\n\tassign and_out = z_a2 & z_b2;\n\n\t// XOR gate\n\tassign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Module A instances\n    assign a1_out = (x^y) & x;\n    assign a2_out = (x^y) & x;\n\n    // Module B instances\n    reg b1_reg, b2_reg;\n\n    always @(*) begin\n        case ({x, y})\n            2'b00: begin b1_reg = 1; b2_reg = 1; end\n            2'b01: begin b1_reg = 0; b2_reg = 0; end\n            2'b10: begin b1_reg = 0; b2_reg = 0; end\n            2'b11: begin b1_reg = 1; b2_reg = 1; end\n        endcase\n    end\n\n    assign b1_out = b1_reg;\n    assign b2_out = b2_reg;\n\n    // OR and AND gates\n    assign or_out = a1_out | b1_out;\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate for final output\n    assign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nwire a1_out, a2_out, b1_out, b2_out;\nwire or_out, and_out;\n\n// Module A instances\nA a1 (.x(x), .y(y), .z(a1_out));\nA a2 (.x(x), .y(y), .z(a2_out));\n\n// Module B instances\nB b1 (.x(x), .y(y), .z(b1_out));\nB b2 (.x(x), .y(y), .z(b2_out));\n\n// OR gate\nassign or_out = a1_out | b1_out;\n\n// AND gate\nassign and_out = a2_out & b2_out;\n\n// XOR gate\nassign z = or_out ^ and_out;\n\nendmodule\n\nmodule A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        if (x == 0 && y == 0)\n            z = 1;\n        else if (x == 1 && y == 1)\n            z = 1;\n        else\n            z = 0;\n    end\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nwire a1_out, a2_out, b1_out, b2_out;\nwire or_out, and_out;\n\n// Instantiate A modules\nA a1 (.x(x), .y(y), .z(a1_out));\nA a2 (.x(x), .y(y), .z(a2_out));\n\n// Instantiate B modules\nB b1 (.x(x), .y(y), .z(b1_out));\nB b2 (.x(x), .y(y), .z(b2_out));\n\n// OR gate\nassign or_out = a1_out | b1_out;\n\n// AND gate\nassign and_out = a2_out & b2_out;\n\n// XOR gate\nassign z = or_out ^ and_out;\n\nendmodule\n\nmodule A(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n\nalways @(*) begin\n    if (x == 0 && y == 0)\n        z = 1;\n    else if (x == 1 && y == 1)\n        z = 1;\n    else\n        z = 0;\nend\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    wire z_a1, z_b1, z_a2, z_b2;\n    wire or_out, and_out;\n\n    // Instantiate Module A (twice)\n    assign z_a1 = (x ^ y) & x;\n    assign z_a2 = (x ^ y) & x;\n\n    // Instantiate Module B (twice)\n    reg z_b1_reg, z_b2_reg;\n    \n    always @(x or y) begin\n        if (x == 0 && y == 0)\n            z_b1_reg <= 1;\n        else if (x == 1 && y == 1)\n            z_b1_reg <= 1;\n        else\n            z_b1_reg <= 0;\n    end\n    \n    always @(x or y) begin\n        if (x == 0 && y == 0)\n            z_b2_reg <= 1;\n        else if (x == 1 && y == 1)\n            z_b2_reg <= 1;\n        else\n            z_b2_reg <= 0;\n    end\n    \n    assign z_b1 = z_b1_reg;\n    assign z_b2 = z_b2_reg;\n\n    // OR and AND gates\n    assign or_out = z_a1 | z_b1;\n    assign and_out = z_a2 & z_b2;\n\n    // Final XOR\n    assign z = or_out ^ and_out;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\nwire a1_out, a2_out, b1_out, b2_out;\nwire or_out, and_out;\n\n// Module A instances\nA a1 (.x(x), .y(y), .z(a1_out));\nA a2 (.x(x), .y(y), .z(a2_out));\n\n// Module B instances\nB b1 (.x(x), .y(y), .z(b1_out));\nB b2 (.x(x), .y(y), .z(b2_out));\n\n// OR gate\nassign or_out = a1_out | b1_out;\n\n// AND gate\nassign and_out = a2_out & b2_out;\n\n// XOR gate\nassign z = or_out ^ and_out;\n\nendmodule\n\nmodule A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        if (x == 0 && y == 0)\n            z = 1;\n        else if (x == 1 && y == 1)\n            z = 1;\n        else\n            z = 0;\n    end\nendmodule"]}
{"task_id": "rotate100", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // Rotate right\n                2'b10: q <= {q[98:0], q[99]};    // Rotate left\n                default: q <= q;                 // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // Rotate right\n                2'b10: q <= {q[98:0], q[99]};    // Rotate left\n                default: q <= q;                 // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // rotate right\n                2'b10: q <= {q[98:0], q[99]};    // rotate left\n                default: q <= q;                 // no rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};  // rotate right\n                2'b10: q <= {q[98:0], q[99]}; // rotate left\n                default: q <= q;              // no rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};    // Rotate right\n                2'b10: q <= {q[98:0], q[99]};   // Rotate left\n                default: q <= q;                // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};      // Rotate right\n                2'b10: q <= {q[98:0], q[99]};     // Rotate left\n                default: q <= q;                  // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // Rotate right\n                2'b10: q <= {q[98:0], q[99]};    // Rotate left\n                default: q <= q;                 // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};  // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q;              // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // Rotate right\n                2'b10: q <= {q[98:0], q[99]};    // Rotate left\n                default: q <= q;                 // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};  // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q;              // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // Rotate right\n                2'b10: q <= {q[98:0], q[99]};    // Rotate left\n                default: q <= q;                 // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};  // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q;              // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};  // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q;              // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // Rotate right\n                2'b10: q <= {q[98:0], q[99]};    // Rotate left\n                default: q <= q;                 // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // Rotate right\n                2'b10: q <= {q[98:0], q[99]};    // Rotate left\n                default: q <= q;                 // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};  // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q;              // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};     // Rotate right\n                2'b10: q <= {q[98:0], q[99]};    // Rotate left\n                default: q <= q;                 // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};    // Rotate right\n                2'b10: q <= {q[98:0], q[99]};   // Rotate left\n                default: q <= q;                // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};    // Rotate right\n                2'b10: q <= {q[98:0], q[99]};   // Rotate left\n                default: q <= q;                // No rotation\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};    // Rotate right\n                2'b10: q <= {q[98:0], q[99]};   // Rotate left\n                default: q <= q;                // No rotation\n            endcase\n        end\n    end\n\nendmodule"]}
{"task_id": "review2015_count1k", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0;\n        end else if (q == 10'd999) begin\n            q <= 10'd0;\n        end else begin\n            q <= q + 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0;\n        end else if (q == 10'd999) begin\n            q <= 10'd0;\n        end else begin\n            q <= q + 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0;\n        end else if (q == 10'd999) begin\n            q <= 10'd0;\n        end else begin\n            q <= q + 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0;\n        end else if (q == 10'd999) begin\n            q <= 10'd0;\n        end else begin\n            q <= q + 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0;\n        end else if (q == 10'd999) begin\n            q <= 10'd0;\n        end else begin\n            q <= q + 1'd1;\n        end\n    end\n\nendmodule"]}
{"task_id": "notgate", "llmgen_RTL": ["module top_module(\n\tinput in,\n\toutput out\n);\n\nassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\nassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n    assign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n    assign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n    assign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n    assign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n    assign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n    assign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n    assign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\nassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n    assign out = ~in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule"]}
{"task_id": "fsm_onehot", "llmgen_RTL": ["module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (~in & state[7]) | (~in & state[8]) | (~in & state[9]);\n    assign next_state[1] = (in & state[0]) | (in & state[8]) | (in & state[9]);\n    assign next_state[2] = in & state[1];\n    assign next_state[3] = in & state[2];\n    assign next_state[4] = in & state[3];\n    assign next_state[5] = in & state[4];\n    assign next_state[6] = in & state[5];\n    assign next_state[7] = in & state[6] | (in & state[7]);\n    assign next_state[8] = ~in & state[5];\n    assign next_state[9] = ~in & state[6];\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | \n                           (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (~in & state[7]) | (~in & state[8]) | (~in & state[9]);\n    assign next_state[1] = (in & state[0]) | (in & state[8]) | (in & state[9]);\n    assign next_state[2] = in & state[1];\n    assign next_state[3] = in & state[2];\n    assign next_state[4] = in & state[3];\n    assign next_state[5] = in & state[4];\n    assign next_state[6] = in & state[5];\n    assign next_state[7] = in & state[6] | (in & state[7]);\n    assign next_state[8] = ~in & state[5];\n    assign next_state[9] = ~in & state[6];\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2\n);\n\n    assign next_state[0] = (~in & (state[0] | state[1] | state[2] | state[3] | state[4])) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"]}
{"task_id": "ece241_2013_q7", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;     // No change\n            2'b01: Q <= 1'b0;  // Reset\n            2'b10: Q <= 1'b1;  // Set\n            2'b11: Q <= ~Q;    // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;     // No change\n            2'b01: Q <= 1'b0;  // Reset\n            2'b10: Q <= 1'b1;  // Set\n            2'b11: Q <= ~Q;    // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;      // No change\n        2'b01: Q <= 1'b0;   // Reset\n        2'b10: Q <= 1'b1;   // Set\n        2'b11: Q <= ~Q;     // Toggle\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;      // No change\n        2'b01: Q <= 1'b0;   // Reset\n        2'b10: Q <= 1'b1;   // Set\n        2'b11: Q <= ~Q;     // Toggle\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;    // No change\n            2'b01: Q <= 1'b0; // Reset\n            2'b10: Q <= 1'b1; // Set\n            2'b11: Q <= ~Q;   // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j,k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;      // No change\n        2'b01: Q <= 1'b0;   // Reset\n        2'b10: Q <= 1'b1;   // Set\n        2'b11: Q <= ~Q;     // Toggle\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;      // No change\n        2'b01: Q <= 1'b0;   // Reset\n        2'b10: Q <= 1'b1;   // Set\n        2'b11: Q <= ~Q;     // Toggle\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // No change\n            2'b01: Q <= 1'b0;   // Reset\n            2'b10: Q <= 1'b1;   // Set\n            2'b11: Q <= ~Q;     // Toggle\n        endcase\n    end\n\nendmodule"]}
{"task_id": "popcount3", "llmgen_RTL": ["module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n\tassign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule", "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule"]}
{"task_id": "vector5", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n    \n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n    \n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n    \n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    generate\n        genvar i, j;\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n    \n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n    \n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    wire [4:0] inputs = {a, b, c, d, e};\n    \n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : outer_loop\n            for (j = 0; j < 5; j = j + 1) begin : inner_loop\n                assign out[i*5 + j] = ~(inputs[i] ^ inputs[j]);\n            end\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n    \n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n    \n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\n\nendmodule"]}
{"task_id": "lemmings1", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT:  next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput reg walk_left,\n\toutput reg walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n    \n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput reg walk_left,\n\toutput reg walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n    \n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n            default: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput reg walk_left,\n\toutput reg walk_right\n);\n\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT:\n                if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput reg walk_left,\n\toutput reg walk_right\n);\n\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput reg walk_left,\n\toutput reg walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n    \n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n            default: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\n    parameter LEFT = 1'b0;\n    parameter RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: next_state = (bump_left) ? RIGHT : LEFT;\n            RIGHT: next_state = (bump_right) ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule"]}
{"task_id": "circuit1", "llmgen_RTL": ["module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n    assign q = a & b;\n\nendmodule"]}
{"task_id": "7458", "llmgen_RTL": ["module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1_out, and2_out, and3_out, and4_out;\n\n    assign and1_out = p1a & p1b & p1c;\n    assign and2_out = p1d & p1e & p1f;\n    assign and3_out = p2a & p2b;\n    assign and4_out = p2c & p2d;\n\n    assign p1y = and1_out | and2_out;\n    assign p2y = and3_out | and4_out;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule"]}
{"task_id": "2014_q3c", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b0;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b0;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b0;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b0;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\nalways @(*) begin\n    case (y)\n        3'b000: begin\n            Y0 = x;\n            z = 1'b0;\n        end\n        3'b001: begin\n            Y0 = 1'b0;\n            z = 1'b0;\n        end\n        3'b010: begin\n            Y0 = x;\n            z = 1'b0;\n        end\n        3'b011: begin\n            Y0 = ~x;\n            z = 1'b1;\n        end\n        3'b100: begin\n            Y0 = 1'b0;\n            z = 1'b1;\n        end\n        default: begin\n            Y0 = 1'b0;\n            z = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b001: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n            3'b010: begin\n                Y0 = x;\n                z = 1'b0;\n            end\n            3'b011: begin\n                Y0 = ~x;\n                z = 1'b1;\n            end\n            3'b100: begin\n                Y0 = 1'b1;\n                z = 1'b1;\n            end\n            default: begin\n                Y0 = 1'b0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"]}
{"task_id": "m2014_q4e", "llmgen_RTL": ["module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule"]}
{"task_id": "wire4", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\t\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"]}
{"task_id": "m2014_q4b", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule"]}
{"task_id": "always_case", "llmgen_RTL": ["module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        3'd0: out = data0;\n        3'd1: out = data1;\n        3'd2: out = data2;\n        3'd3: out = data3;\n        3'd4: out = data4;\n        3'd5: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        3'd0: out = data0;\n        3'd1: out = data1;\n        3'd2: out = data2;\n        3'd3: out = data3;\n        3'd4: out = data4;\n        3'd5: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        3'd0: out = data0;\n        3'd1: out = data1;\n        3'd2: out = data2;\n        3'd3: out = data3;\n        3'd4: out = data4;\n        3'd5: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        3'd0: out = data0;\n        3'd1: out = data1;\n        3'd2: out = data2;\n        3'd3: out = data3;\n        3'd4: out = data4;\n        3'd5: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "timer", "llmgen_RTL": ["module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load)\n            counter <= data;\n        else if (counter != 10'b0)\n            counter <= counter - 1'b1;\n    end\n\n    assign tc = (counter == 10'b0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'b0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'b0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'b0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'b0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'b0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'b0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'b0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'b0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load)\n        counter <= data;\n    else if (counter != 10'd0)\n        counter <= counter - 1'b1;\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule"]}
{"task_id": "review2015_fsmseq", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n\tlocalparam S0 = 3'b000;\n\tlocalparam S1 = 3'b001;\n\tlocalparam S11 = 3'b010;\n\tlocalparam S110 = 3'b011;\n\tlocalparam S1101 = 3'b100;\n\n\treg [2:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tstart_shifting <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == S1101)\n\t\t\t\tstart_shifting <= 1;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: next_state = data ? S1 : S0;\n\t\t\tS1: next_state = data ? S11 : S0;\n\t\t\tS11: next_state = data ? S11 : S110;\n\t\t\tS110: next_state = data ? S1101 : S0;\n\t\t\tS1101: next_state = S1101;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S11 = 3'b010, S110 = 3'b011, S1101 = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            state <= next_state;\n            if (state == S1101)\n                start_shifting <= 1;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S11 : S0;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : S0;\n            S1101: next_state = S1101;\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0010,\n              S110 = 4'b0011,\n              S1101 = 4'b0100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S11 : S0;\n                S11: state <= data ? S11 : S110;\n                S110: state <= data ? S1101 : S0;\n                S1101: state <= S1101;\n                default: state <= S0;\n            endcase\n\n            if (state == S1101)\n                start_shifting <= 1;\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    reg [3:0] state, next_state;\n    parameter S0 = 4'b0000, S1 = 4'b0001, S11 = 4'b0011, S110 = 4'b0111, S1101 = 4'b1111;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S11 : S0;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : S0;\n            S1101: next_state = S1101;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (state == S1101)\n            start_shifting <= 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0010,\n              S110 = 4'b0011,\n              S1101 = 4'b0100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S11 : S0;\n                S11: state <= data ? S11 : S110;\n                S110: state <= data ? S1101 : S0;\n                S1101: state <= S1101;\n                default: state <= S0;\n            endcase\n\n            if (state == S1101) begin\n                start_shifting <= 1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S11 = 3'b010, S110 = 3'b011, S1101 = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            state <= next_state;\n            if (state == S1101)\n                start_shifting <= 1;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S11 : S0;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : S0;\n            S1101: next_state = S1101;\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n\tparameter S0 = 3'b000;\n\tparameter S1 = 3'b001;\n\tparameter S11 = 3'b010;\n\tparameter S110 = 3'b011;\n\tparameter S1101 = 3'b100;\n\n\treg [2:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tstart_shifting <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == S1101) start_shifting <= 1;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: next_state = data ? S1 : S0;\n\t\t\tS1: next_state = data ? S11 : S0;\n\t\t\tS11: next_state = data ? S11 : S110;\n\t\t\tS110: next_state = data ? S1101 : S0;\n\t\t\tS1101: next_state = S1101;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n\tparameter S0 = 3'b000;\n\tparameter S1 = 3'b001;\n\tparameter S11 = 3'b010;\n\tparameter S110 = 3'b011;\n\tparameter S1101 = 3'b100;\n\n\treg [2:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tstart_shifting <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == S1101)\n\t\t\t\tstart_shifting <= 1;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: next_state = data ? S1 : S0;\n\t\t\tS1: next_state = data ? S11 : S0;\n\t\t\tS11: next_state = data ? S11 : S110;\n\t\t\tS110: next_state = data ? S1101 : S0;\n\t\t\tS1101: next_state = S1101;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n\treg [3:0] state, next_state;\n\t\n\tparameter S0 = 4'b0000;\n\tparameter S1 = 4'b0001;\n\tparameter S11 = 4'b0010;\n\tparameter S110 = 4'b0011;\n\tparameter S1101 = 4'b0100;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tstart_shifting <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == S1101)\n\t\t\t\tstart_shifting <= 1;\n\t\tend\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: next_state = data ? S1 : S0;\n\t\t\tS1: next_state = data ? S11 : S0;\n\t\t\tS11: next_state = data ? S11 : S110;\n\t\t\tS110: next_state = data ? S1101 : S0;\n\t\t\tS1101: next_state = S1101;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // Define states\n    parameter S0 = 3'b000;\n    parameter S1 = 3'b001;\n    parameter S11 = 3'b010;\n    parameter S110 = 3'b011;\n    parameter S1101 = 3'b100;\n\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S11 : S0;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : S0;\n            S1101: next_state = S1101;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (current_state == S1101)\n            start_shifting <= 1;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0011,\n              S110 = 4'b0111,\n              S1101 = 4'b1111;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S11 : S0;\n                S11: state <= data ? S11 : S110;\n                S110: state <= data ? S1101 : S0;\n                S1101: state <= S1101;\n                default: state <= S0;\n            endcase\n\n            if (state == S1101) begin\n                start_shifting <= 1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n    reg [3:0] state, next_state;\n    \n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0011,\n              S110 = 4'b0111,\n              S1101 = 4'b1111;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            state <= next_state;\n            if (state == S1101) start_shifting <= 1;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S11 : S0;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : S0;\n            S1101: next_state = S1101;\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0011,\n              S110 = 4'b0111,\n              S1101 = 4'b1111;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S11 : S0;\n                S11: state <= data ? S11 : S110;\n                S110: state <= data ? S1101 : S0;\n                S1101: state <= S1101;\n                default: state <= S0;\n            endcase\n\n            if (state == S1101)\n                start_shifting <= 1;\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0011,\n              S110 = 4'b0110,\n              S1101 = 4'b1101;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S11 : S0;\n                S11: state <= data ? S11 : S110;\n                S110: state <= data ? S1101 : S0;\n                S1101: state <= S1101;\n                default: state <= S0;\n            endcase\n\n            if (state == S1101)\n                start_shifting <= 1;\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S2 = 4'b0010,\n              S3 = 4'b0011,\n              S4 = 4'b0100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S2 : S0;\n                S2: state <= data ? S2 : S3;\n                S3: state <= data ? S4 : S0;\n                S4: state <= S4;\n                default: state <= S0;\n            endcase\n\n            if (state == S4) begin\n                start_shifting <= 1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0011,\n              S110 = 4'b0111,\n              S1101 = 4'b1111;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S11 : S0;\n                S11: state <= data ? S11 : S110;\n                S110: state <= data ? S1101 : S0;\n                S1101: state <= S1101;\n                default: state <= S0;\n            endcase\n\n            if (state == S1101) begin\n                start_shifting <= 1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0011,\n              S110 = 4'b0111,\n              S1101 = 4'b1111;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S11 : S0;\n                S11: state <= data ? S11 : S110;\n                S110: state <= data ? S1101 : S0;\n                S1101: state <= S1101;\n                default: state <= S0;\n            endcase\n\n            if (state == S1101) begin\n                start_shifting <= 1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput reg start_shifting\n);\n\n    reg [3:0] state, next_state;\n    \n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0010,\n              S110 = 4'b0011,\n              S1101 = 4'b0100;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            state <= next_state;\n            if (state == S1101)\n                start_shifting <= 1;\n        end\n    end\n    \n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S11 : S0;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : S0;\n            S1101: next_state = S1101;\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S11 = 4'b0011,\n              S110 = 4'b0111,\n              S1101 = 4'b1111;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end\n        else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S11 : S0;\n                S11: state <= data ? S11 : S110;\n                S110: state <= data ? S1101 : S0;\n                S1101: state <= S1101;\n                default: state <= S0;\n            endcase\n\n            if (state == S1101)\n                start_shifting <= 1;\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    reg [3:0] state;\n    parameter S0 = 4'b0000,\n              S1 = 4'b0001,\n              S2 = 4'b0010,\n              S3 = 4'b0011,\n              S4 = 4'b0100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                S0: state <= data ? S1 : S0;\n                S1: state <= data ? S2 : S0;\n                S2: state <= data ? S2 : S3;\n                S3: state <= data ? S4 : S0;\n                S4: state <= S4;\n                default: state <= S0;\n            endcase\n\n            if (state == S4)\n                start_shifting <= 1;\n        end\n    end\n\nendmodule"]}
{"task_id": "dff8r", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"]}
{"task_id": "edgedetect2", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    prev_in <= in;\n    anyedge <= in ^ prev_in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        anyedge <= in ^ in_prev;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    prev_in <= in;\n    anyedge <= in ^ prev_in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    prev_in <= in;\n    anyedge <= in ^ prev_in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        anyedge <= in ^ in_prev;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in ^ in_prev;\nend\n\nendmodule"]}
{"task_id": "count1to10", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;  // Reset to 1\n        else if (q == 4'd10)\n            q <= 4'd1;  // Wrap around to 1 after reaching 10\n        else\n            q <= q + 1'b1;  // Increment counter\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'd1;\n\t\telse if (q == 4'd10)\n\t\t\tq <= 4'd1;\n\t\telse\n\t\t\tq <= q + 1'd1;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd1;\n    else if (q == 4'd10)\n        q <= 4'd1;\n    else\n        q <= q + 1'b1;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd1;\n    else if (q == 4'd10)\n        q <= 4'd1;\n    else\n        q <= q + 1'd1;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd1;\n    else if (q == 4'd10)\n        q <= 4'd1;\n    else\n        q <= q + 1'd1;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1'd1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule"]}
{"task_id": "circuit9", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b1)\n            q <= 3'd4;\n        else if (q == 3'd0)\n            q <= 3'd1;\n        else if (q == 3'd6)\n            q <= 3'd0;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0)\n                q <= 3'd1;\n            else if (q == 3'd6)\n                q <= 3'd0;\n            else\n                q <= q + 1'b1;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0)\n                q <= 3'd1;\n            else if (q == 3'd6)\n                q <= 3'd0;\n            else\n                q <= q + 1'b1;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0 || q == 3'd7) begin\n                q <= 3'd1;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0 || q == 3'd6) begin\n                q <= 3'd1;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'd4;\n        end else begin\n            if (q == 3'd0) begin\n                q <= 3'd1;\n            end else if (q == 3'd6) begin\n                q <= 3'd0;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule"]}
{"task_id": "lfsr5", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 5'h1;  // Reset to 1\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2] ^ q[4];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 5'h1;  // Reset to 1\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2] ^ q[4];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q <= {q[3:0], q[4] ^ q[2]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001;\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 5'h1;  // Reset to 1\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2] ^ q[4];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 5'h1;  // Reset to 1\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2] ^ q[4];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 5'h1;  // Reset to 1\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2] ^ q[4];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 5'h1;  // Reset to 1\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2] ^ q[4];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q <= {q[3:0], q[4] ^ q[2]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 5'h1;  // Reset to 1\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2] ^ q[4];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;  // Reset to 1\n        end else begin\n            q[4] <= q[3];\n            q[3] <= q[2] ^ q[4];\n            q[2] <= q[1];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule"]}
{"task_id": "bugs_addsubz", "llmgen_RTL": ["module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n          1'b0: out = a + b;\n          1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n          1'b0: out = a + b;\n          1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule"]}
{"task_id": "m2014_q3", "llmgen_RTL": ["module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0101, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = x[1] | (~x[2] & x[3]);\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0101, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = x[1] | (x[3] & ~x[4]);\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0111, 4'b1011, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = 1'b0; // Assigning don't-care outputs to 0\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case(x)\n            4'b0001, 4'b0010, 4'b0100: f = 1'b0;\n            4'b0111, 4'b1011, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0111, 4'b1000, 4'b1001, 4'b1010, 4'b1011, 4'b1100, 4'b1101: f = 1'b1;\n            default: f = 1'b0; // Assigning 0 to don't-care conditions\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0101, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = x[3] | (~x[4] & x[2]);\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0111, 4'b1000, 4'b1001, 4'b1010, 4'b1011: f = 1'b1;\n            4'b0010, 4'b0100, 4'b0110, 4'b1110: f = 1'b0;\n            default: f = 1'b0; // Assigning don't-care outputs to 0\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0111, 4'b1011, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = 1'b0; // Treating don't-cares as 0\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0101, 4'b1000: f = 1'b0;\n            4'b0110, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = x[1] | (~x[2] & x[3]);\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0111, 4'b1000, 4'b1001, 4'b1010, 4'b1011, 4'b1100: f = 1'b1;\n            default: f = 1'b0; // Assigning don't-care conditions to 0\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0111, 4'b1000, 4'b1001, 4'b1010, 4'b1011, 4'b1100, 4'b1101: f = 1'b1;\n            default: f = 1'b0; // Assign don't-cares to 0 for simplicity\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0010, 4'b0100: f = 1'b0;\n            4'b0110, 4'b1000, 4'b1001, 4'b1010, 4'b1011, 4'b1100, 4'b1101: f = 1'b1;\n            4'b0111: f = 1'b1;\n            default: f = 1'b0;  // Assigning 0 to don't-care conditions\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0101, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = x[1] | (x[3] & ~x[2]);\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0111, 4'b1011, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = 1'b0; // Assigning 0 to don't-care conditions\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case(x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0111, 4'b1011, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = 1'b0;  // Assigning 0 to don't-care conditions\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0101, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = x[1] | (~x[2] & x[3]);\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0111, 4'b1011, 4'b1100, 4'b1101, 4'b1110: f = 1'b1;\n            default: f = 1'b0;  // Assigning don't-cares to 0 for simplicity\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0101, 4'b1000, 4'b1001, 4'b1010, 4'b1100, 4'b1101: f = 1'b1;\n            default: f = 1'b0;  // Assigning 0 to don't-care conditions\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0010, 4'b0100: f = 1'b0;\n            4'b0111, 4'b1000, 4'b1001, 4'b1010, 4'b1011, 4'b1100, 4'b1101: f = 1'b1;\n            default: f = 1'b0; // Assign don't-care outputs to 0\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0001, 4'b0100, 4'b0110: f = 1'b0;\n            4'b0101, 4'b1000, 4'b1001, 4'b1010, 4'b1100, 4'b1101: f = 1'b1;\n            default: f = 1'b0; // Assigning 0 to don't-care conditions\n        endcase\n    end\n\nendmodule"]}
{"task_id": "bugs_case", "llmgen_RTL": ["module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\n    always @(*) begin\n        case(code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\n    always @(*) begin\n        case(code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\n    always @(*) begin\n        case(code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule"]}
{"task_id": "vectorr", "llmgen_RTL": ["module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule"]}
{"task_id": "kmap3", "llmgen_RTL": ["module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            default: out = 1'b1; // Covering don't care conditions\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0010: out = 1'b0;\n        4'b0011: out = 1'b0;\n        4'b0100: out = 1'b0;\n        4'b0101: out = 1'b0;\n        4'b0110: out = 1'b1;\n        4'b0111: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'b1;\n        4'b1010: out = 1'b1;\n        4'b1011: out = 1'b1;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b1;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0010: out = 1'b0;\n        4'b0011: out = 1'b0;\n        4'b0100: out = 1'b0;\n        4'b0101: out = 1'b0;\n        4'b0110: out = 1'b1;\n        4'b0111: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'b1;\n        4'b1010: out = 1'b1;\n        4'b1011: out = 1'b1;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b1;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0010: out = 1'b0;\n        4'b0011: out = 1'b0;\n        4'b0100: out = 1'b0;\n        4'b0101: out = 1'b0;\n        4'b0110: out = 1'b1;\n        4'b0111: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'b1;\n        4'b1010: out = 1'b1;\n        4'b1011: out = 1'b1;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b1;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0010: out = 1'b0;\n        4'b0011: out = 1'b0;\n        4'b0100: out = 1'b0;\n        4'b0101: out = 1'b0;\n        4'b0110: out = 1'b1;\n        4'b0111: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'b1;\n        4'b1010: out = 1'b1;\n        4'b1011: out = 1'b1;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b1;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0010: out = 1'b0;\n        4'b0011: out = 1'b0;\n        4'b0100: out = 1'b0;\n        4'b0101: out = 1'b0;\n        4'b0110: out = 1'b1;\n        4'b0111: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'b1;\n        4'b1010: out = 1'b1;\n        4'b1011: out = 1'b1;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b1;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0010: out = 1'b0;\n        4'b0011: out = 1'b0;\n        4'b0100: out = 1'b0;\n        4'b0101: out = 1'b0;\n        4'b0110: out = 1'b1;\n        4'b0111: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'b1;\n        4'b1010: out = 1'b1;\n        4'b1011: out = 1'b1;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b1;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b0;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b1;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "review2015_shiftcount", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {data, q[3:1]};\n        end\n        else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            q <= q - 1;\n        end\n    end\n\nendmodule"]}
{"task_id": "wire", "llmgen_RTL": ["module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule", "module top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule"]}
{"task_id": "review2015_fsmshift", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 3'd0;\n            shift_ena <= 1'b1;\n        end else if (count < 3'd4) begin\n            count <= count + 1'b1;\n            shift_ena <= 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        count <= 3'd0;\n    end else begin\n        if (count < 3'd3) begin\n            shift_ena <= 1'b1;\n            count <= count + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            count <= count;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 3'd0;\n        shift_ena <= 1'b1;\n    end else begin\n        if (count < 3'd3) begin\n            count <= count + 1'b1;\n            shift_ena <= 1'b1;\n        end else begin\n            count <= count;\n            shift_ena <= 1'b0;\n        end\n    end\nend\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1'b1;\n            count <= 2'b00;\n        end else begin\n            if (count < 2'b11) begin\n                count <= count + 1'b1;\n                shift_ena <= 1'b1;\n            end else begin\n                shift_ena <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\n\treg [2:0] count;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tshift_ena <= 1'b1;\n\t\t\tcount <= 3'd0;\n\t\tend\n\t\telse begin\n\t\t\tif (count < 3'd3) begin\n\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\tcount <= count + 1'b1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_ena <= 1'b0;\n\t\t\t\tcount <= count;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        count <= 3'd0;\n    end else begin\n        if (count < 3'd3) begin\n            shift_ena <= 1'b1;\n            count <= count + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            count <= count;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        counter <= 3'd0;\n    end else begin\n        if (counter < 3'd3) begin\n            shift_ena <= 1'b1;\n            counter <= counter + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            counter <= counter;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1'b1;\n            count <= 3'd0;\n        end else begin\n            if (count < 3'd3) begin\n                shift_ena <= 1'b1;\n                count <= count + 1'b1;\n            end else begin\n                shift_ena <= 1'b0;\n                count <= count;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        count <= 3'd0;\n    end else begin\n        if (count < 3'd3) begin\n            shift_ena <= 1'b1;\n            count <= count + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            count <= count;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        count <= 3'd0;\n    end else begin\n        if (count < 3'd3) begin\n            shift_ena <= 1'b1;\n            count <= count + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            count <= count;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        counter <= 3'd0;\n    end else begin\n        if (counter < 3'd3) begin\n            shift_ena <= 1'b1;\n            counter <= counter + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            counter <= 3'd3;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        count <= 3'd0;\n    end else begin\n        if (count < 3'd3) begin\n            shift_ena <= 1'b1;\n            count <= count + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            count <= count;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        count <= 3'd0;\n    end else begin\n        if (count < 3'd3) begin\n            shift_ena <= 1'b1;\n            count <= count + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            count <= count;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] state;\nreg [1:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 3'b001;\n        count <= 2'b00;\n        shift_ena <= 1'b1;\n    end else begin\n        case (state)\n            3'b001: begin\n                if (count == 2'b11) begin\n                    state <= 3'b010;\n                    count <= 2'b00;\n                    shift_ena <= 1'b0;\n                end else begin\n                    count <= count + 1'b1;\n                    shift_ena <= 1'b1;\n                end\n            end\n            3'b010: begin\n                shift_ena <= 1'b0;\n            end\n            default: begin\n                state <= 3'b010;\n                shift_ena <= 1'b0;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        counter <= 3'd0;\n    end else begin\n        if (counter < 3'd3) begin\n            shift_ena <= 1'b1;\n            counter <= counter + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            counter <= counter;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 3'd0;\n        shift_ena <= 1'b1;\n    end else begin\n        if (count < 3'd3) begin\n            count <= count + 1'b1;\n            shift_ena <= 1'b1;\n        end else begin\n            count <= count;\n            shift_ena <= 1'b0;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\n    reg [2:0] counter;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 3'd3;\n            shift_ena <= 1'b1;\n        end else if (counter > 0) begin\n            counter <= counter - 1'b1;\n            shift_ena <= 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] state;\nreg [1:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 3'b001;\n        count <= 2'b00;\n        shift_ena <= 1'b1;\n    end else begin\n        case (state)\n            3'b001: begin\n                if (count == 2'b11) begin\n                    state <= 3'b010;\n                    count <= 2'b00;\n                    shift_ena <= 1'b0;\n                end else begin\n                    count <= count + 1'b1;\n                    shift_ena <= 1'b1;\n                end\n            end\n            3'b010: begin\n                shift_ena <= 1'b0;\n            end\n            default: begin\n                state <= 3'b010;\n                shift_ena <= 1'b0;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg shift_ena\n);\n\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b1;\n        counter <= 3'd0;\n    end else begin\n        if (counter < 3'd3) begin\n            shift_ena <= 1'b1;\n            counter <= counter + 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n            counter <= counter;\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n    reg [2:0] count;\n    reg shift_ena_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 3'd3;\n            shift_ena_reg <= 1'b1;\n        end else if (count > 0) begin\n            count <= count - 1'b1;\n            shift_ena_reg <= 1'b1;\n        end else begin\n            count <= 3'd0;\n            shift_ena_reg <= 1'b0;\n        end\n    end\n\n    assign shift_ena = shift_ena_reg;\n\nendmodule"]}
{"task_id": "count15", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;\n    else\n        q <= q + 1'b1;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            if (q == 4'b1111) begin\n                q <= 4'b0000;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            if (q == 4'b1111) begin\n                q <= 4'b0000;\n            end else begin\n                q <= q + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule"]}
{"task_id": "always_if", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"]}
{"task_id": "kmap1", "llmgen_RTL": ["module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = ~a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = ~a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = ~a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = (~a & b) | (b) | (c);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = (~a & b) | (b) | (c);\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n    assign out = a | b | c;\n\nendmodule"]}
{"task_id": "2013_q2afsm", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    // State encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: next_state = r[1] ? B : A;\n            C: next_state = r[2] ? C : A;\n            D: next_state = r[3] ? D : A;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (r[1])\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse if (r[2])\n\t\t\t\t\tnext_state = C;\n\t\t\t\telse if (r[3])\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (r[1])\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (r[2])\n\t\t\t\t\tnext_state = C;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (r[3])\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign g[1] = (state == B);\n\tassign g[2] = (state == C);\n\tassign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    reg [1:0] state, next_state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"]}
{"task_id": "count10", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (q == 4'b1001)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (q == 4'b1001)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (q == 4'b1001) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1'b1;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (q == 4'b1001)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (q == 4'b1001)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (q == 4'b1001)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd0;\n    else if (q == 4'd9)\n        q <= 4'd0;\n    else\n        q <= q + 1'd1;\nend\n\nendmodule"]}
{"task_id": "fsm_ps2", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            SEARCH: begin\n                if (in[3])\n                    next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                done = 1'b1;\n                if (in[3])\n                    next_state = BYTE2;\n                else\n                    next_state = SEARCH;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n    reg [1:0] state, next_state;\n    reg done_reg;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        done_reg = 1'b0;\n        case (state)\n            SEARCH: if (in[3]) next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: begin\n                next_state = in[3] ? BYTE2 : SEARCH;\n                done_reg = 1'b1;\n            end\n        endcase\n    end\n\n    assign done = done_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n        case (state)\n            SEARCH: begin\n                if (in[3])\n                    next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                done = 1'b1;\n                if (in[3])\n                    next_state = BYTE2;\n                else\n                    next_state = SEARCH;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n\treg [1:0] state, next_state;\n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 1'b0;\n\t\tcase (state)\n\t\t\tS0: if (in[3]) next_state = S1;\n\t\t\tS1: next_state = S2;\n\t\t\tS2: begin\n\t\t\t\tif (in[3])\n\t\t\t\t\tnext_state = S1;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tdone = 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\n    reg [1:0] state, next_state;\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            SEARCH: next_state = (in[3]) ? BYTE2 : SEARCH;\n            BYTE2:  next_state = BYTE3;\n            BYTE3:  next_state = (in[3]) ? BYTE2 : SEARCH;\n            default: next_state = SEARCH;\n        endcase\n    end\n\n    assign done = (state == BYTE3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n\tlocalparam SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\treg [1:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= SEARCH;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 1'b0;\n\n\t\tcase (state)\n\t\t\tSEARCH: begin\n\t\t\t\tif (in[3])\n\t\t\t\t\tnext_state = BYTE2;\n\t\t\tend\n\t\t\tBYTE2: begin\n\t\t\t\tnext_state = BYTE3;\n\t\t\tend\n\t\t\tBYTE3: begin\n\t\t\t\tdone = 1'b1;\n\t\t\t\tnext_state = SEARCH;\n\t\t\tend\n\t\tendcase\n\n\t\tif (reset)\n\t\t\tnext_state = SEARCH;\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n        case (state)\n            S0: if (in[3]) next_state = S1;\n            S1: next_state = S2;\n            S2: begin\n                if (in[3])\n                    next_state = S1;\n                else\n                    next_state = S0;\n                done = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\nreg [1:0] state, next_state;\nparameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= SEARCH;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        SEARCH: next_state = (in[3]) ? BYTE2 : SEARCH;\n        BYTE2:  next_state = BYTE3;\n        BYTE3:  next_state = (in[3]) ? BYTE2 : SEARCH;\n        default: next_state = SEARCH;\n    endcase\nend\n\nassign done = (state == BYTE3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n        case (state)\n            S0: if (in[3]) next_state = S1;\n            S1: next_state = S2;\n            S2: begin\n                if (in[3]) \n                    next_state = S1;\n                else \n                    next_state = S0;\n                done = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\nreg [1:0] state, next_state;\nparameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= SEARCH;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    next_state = state;\n    case (state)\n        SEARCH: if (in[3]) next_state = BYTE2;\n        BYTE2: next_state = BYTE3;\n        BYTE3: next_state = in[3] ? BYTE2 : SEARCH;\n    endcase\nend\n\nassign done = (state == BYTE3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\n    reg [1:0] state, next_state;\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            SEARCH: if (in[3]) next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE2 : SEARCH;\n        endcase\n    end\n\n    assign done = (state == BYTE3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\nreg [1:0] state, next_state;\nparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= S0;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        S0: next_state = (in[3]) ? S1 : S0;\n        S1: next_state = S2;\n        S2: next_state = (in[3]) ? S1 : S0;\n        default: next_state = S0;\n    endcase\nend\n\nassign done = (state == S2) && (next_state == S1 || next_state == S0);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n        \n        case (state)\n            S0: if (in[3]) next_state = S1;\n            S1: next_state = S2;\n            S2: begin\n                if (in[3]) \n                    next_state = S1;\n                else \n                    next_state = S0;\n                done = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\n    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = (in[3]) ? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = (in[3]) ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    assign done = (state == S2) && (next_state == S1 || next_state == S0);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n    reg [1:0] state;\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= SEARCH;\n            done <= 0;\n        end else begin\n            case (state)\n                SEARCH: begin\n                    if (in[3]) begin\n                        state <= BYTE2;\n                    end\n                    done <= 0;\n                end\n                BYTE2: begin\n                    state <= BYTE3;\n                    done <= 0;\n                end\n                BYTE3: begin\n                    if (in[3]) begin\n                        state <= BYTE2;\n                    end else begin\n                        state <= SEARCH;\n                    end\n                    done <= 1;\n                end\n                default: state <= SEARCH;\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n        case (state)\n            SEARCH: if (in[3]) next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: begin\n                next_state = in[3] ? BYTE2 : SEARCH;\n                done = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n    reg [1:0] state, next_state;\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            SEARCH: begin\n                if (in[3])\n                    next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                done = 1'b1;\n                if (in[3])\n                    next_state = BYTE2;\n                else\n                    next_state = SEARCH;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\n    reg [1:0] state, next_state;\n    parameter SEARCH = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            SEARCH: next_state = (in[3]) ? BYTE2 : SEARCH;\n            BYTE2:  next_state = BYTE3;\n            BYTE3:  next_state = (in[3]) ? BYTE2 : SEARCH;\n            default: next_state = SEARCH;\n        endcase\n    end\n\n    assign done = (state == BYTE3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\n    reg [1:0] state, next_state;\n    parameter IDLE = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3]) ? BYTE2 : IDLE;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = (in[3]) ? BYTE2 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    assign done = (state == BYTE3);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\nreg [1:0] state, next_state;\nparameter IDLE = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: if (in[3]) next_state = BYTE2;\n        BYTE2: next_state = BYTE3;\n        BYTE3: next_state = in[3] ? BYTE2 : IDLE;\n    endcase\nend\n\nassign done = (state == BYTE3);\n\nendmodule"]}
{"task_id": "mux2to1", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel == 0) ? a : b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = sel ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = (sel) ? b : a;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n    assign out = (sel) ? b : a;\n\nendmodule"]}
{"task_id": "gates4", "llmgen_RTL": ["module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule"]}
{"task_id": "2014_q3bfsm", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\nreg [2:0] state, next_state;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= 3'b000;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        3'b000: next_state = x ? 3'b001 : 3'b000;\n        3'b001: next_state = x ? 3'b100 : 3'b001;\n        3'b010: next_state = x ? 3'b001 : 3'b010;\n        3'b011: next_state = x ? 3'b010 : 3'b001;\n        3'b100: next_state = x ? 3'b100 : 3'b011;\n        default: next_state = 3'b000;\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        3'b011, 3'b100: z = 1'b1;\n        default: z = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\nreg [2:0] state, next_state;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= 3'b000;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        3'b000: next_state = x ? 3'b001 : 3'b000;\n        3'b001: next_state = x ? 3'b100 : 3'b001;\n        3'b010: next_state = x ? 3'b001 : 3'b010;\n        3'b011: next_state = x ? 3'b010 : 3'b001;\n        3'b100: next_state = x ? 3'b100 : 3'b011;\n        default: next_state = 3'b000;\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        3'b011, 3'b100: z = 1'b1;\n        default: z = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\nreg [2:0] state, next_state;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= 3'b000;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        3'b000: next_state = x ? 3'b001 : 3'b000;\n        3'b001: next_state = x ? 3'b100 : 3'b001;\n        3'b010: next_state = x ? 3'b001 : 3'b010;\n        3'b011: next_state = x ? 3'b010 : 3'b001;\n        3'b100: next_state = x ? 3'b100 : 3'b011;\n        default: next_state = 3'b000;\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        3'b011, 3'b100: z = 1'b1;\n        default: z = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\nreg [2:0] state, next_state;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= 3'b000;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        3'b000: next_state = x ? 3'b001 : 3'b000;\n        3'b001: next_state = x ? 3'b100 : 3'b001;\n        3'b010: next_state = x ? 3'b001 : 3'b010;\n        3'b011: next_state = x ? 3'b010 : 3'b001;\n        3'b100: next_state = x ? 3'b100 : 3'b011;\n        default: next_state = 3'b000;\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        3'b011, 3'b100: z = 1'b1;\n        default: z = 1'b0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "2013_q2bfsm", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101, G = 3'b110;\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        case (state)\n            A: begin\n                if (resetn) next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x) next_state = D;\n            end\n            D: begin\n                if (!x) next_state = E;\n                else next_state = C;\n            end\n            E: begin\n                if (x) next_state = F;\n                else next_state = C;\n            end\n            F: begin\n                next_state = G;\n            end\n            G: begin\n                if (count == 2'b10 && !y)\n                    next_state = A;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            g <= 0;\n            count <= 0;\n        end\n        else if (state == F) begin\n            g <= 1;\n            count <= 0;\n        end\n        else if (state == G) begin\n            if (y)\n                count <= 2'b11;\n            else if (count != 2'b11)\n                count <= count + 1;\n            \n            if (count == 2'b10 && !y)\n                g <= 0;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter STATE_A = 3'b000;\n    parameter STATE_B = 3'b001;\n    parameter STATE_C = 3'b010;\n    parameter STATE_D = 3'b011;\n    parameter STATE_E = 3'b100;\n    parameter STATE_F = 3'b101;\n    parameter STATE_G = 3'b110;\n    parameter STATE_H = 3'b111;\n\n    reg [2:0] current_state, next_state;\n    reg [1:0] x_count, y_count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = resetn ? STATE_B : STATE_A;\n            STATE_B: next_state = STATE_C;\n            STATE_C: next_state = (x_count == 2'b11) ? STATE_D : STATE_C;\n            STATE_D: next_state = STATE_E;\n            STATE_E: next_state = y ? STATE_G : ((y_count == 2'b10) ? STATE_H : STATE_E);\n            STATE_F: next_state = STATE_F;\n            STATE_G: next_state = STATE_G;\n            STATE_H: next_state = STATE_H;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_count <= 2'b00;\n            y_count <= 2'b00;\n        end\n        else begin\n            case (current_state)\n                STATE_C: begin\n                    if (x == 1 && x_count == 2'b00)\n                        x_count <= 2'b01;\n                    else if (x == 0 && x_count == 2'b01)\n                        x_count <= 2'b10;\n                    else if (x == 1 && x_count == 2'b10)\n                        x_count <= 2'b11;\n                    else\n                        x_count <= 2'b00;\n                end\n                STATE_E: y_count <= y_count + 1;\n                default: begin\n                    x_count <= 2'b00;\n                    y_count <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n        end\n        else begin\n            f <= (current_state == STATE_B);\n            g <= (current_state == STATE_D) || (current_state == STATE_E) || (current_state == STATE_G);\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101, G = 3'b110;\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            A: begin\n                if (resetn) next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x) next_state = D;\n            end\n            D: begin\n                if (!x) next_state = E;\n                else next_state = C;\n            end\n            E: begin\n                if (x) next_state = F;\n                else next_state = C;\n            end\n            F: begin\n                g = 1;\n                if (y) next_state = G;\n                else if (count == 2'b10) next_state = A;\n            end\n            G: begin\n                g = 1;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn)\n            count <= 2'b00;\n        else if (state == F)\n            count <= count + 1'b1;\n        else\n            count <= 2'b00;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter STATE_A = 3'b000;\n    parameter STATE_B = 3'b001;\n    parameter STATE_C = 3'b010;\n    parameter STATE_D = 3'b011;\n    parameter STATE_E = 3'b100;\n    parameter STATE_F = 3'b101;\n    parameter STATE_G = 3'b110;\n    parameter STATE_H = 3'b111;\n\n    reg [2:0] current_state, next_state;\n    reg [1:0] x_count, y_count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = resetn ? STATE_B : STATE_A;\n            STATE_B: next_state = STATE_C;\n            STATE_C: next_state = (x_count == 2'b11) ? STATE_D : STATE_C;\n            STATE_D: next_state = STATE_E;\n            STATE_E: next_state = y ? STATE_G : (y_count == 2'b10) ? STATE_F : STATE_E;\n            STATE_F: next_state = STATE_F;\n            STATE_G: next_state = STATE_G;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_count <= 2'b00;\n            y_count <= 2'b00;\n        end else begin\n            case (current_state)\n                STATE_C: x_count <= (x) ? {x_count[0], 1'b1} : 2'b00;\n                STATE_E: y_count <= y_count + 1;\n                default: begin\n                    x_count <= 2'b00;\n                    y_count <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            f <= 1'b0;\n            g <= 1'b0;\n        end else begin\n            f <= (current_state == STATE_B);\n            g <= (current_state == STATE_D) || (current_state == STATE_E) || (current_state == STATE_G);\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101, G = 3'b110;\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            A: begin\n                if (resetn) next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x) next_state = D;\n            end\n            D: begin\n                if (!x) next_state = E;\n                else next_state = C;\n            end\n            E: begin\n                if (x) next_state = F;\n                else next_state = C;\n            end\n            F: begin\n                g = 1;\n                if (y) next_state = G;\n                else if (count == 2'b10) next_state = A;\n            end\n            G: begin\n                g = 1;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn)\n            count <= 2'b00;\n        else if (state == F)\n            count <= count + 1'b1;\n        else\n            count <= 2'b00;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n\tlocalparam STATE_A = 3'd0,\n\t\t\t   STATE_B = 3'd1,\n\t\t\t   STATE_C = 3'd2,\n\t\t\t   STATE_D = 3'd3,\n\t\t\t   STATE_E = 3'd4,\n\t\t\t   STATE_F = 3'd5,\n\t\t\t   STATE_G = 3'd6;\n\n\treg [2:0] state, next_state;\n\treg [1:0] x_count, y_count;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tstate <= STATE_A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tf = 0;\n\t\tg = 0;\n\t\tcase (state)\n\t\t\tSTATE_A: begin\n\t\t\t\tif (resetn)\n\t\t\t\t\tnext_state = STATE_B;\n\t\t\tend\n\t\t\tSTATE_B: begin\n\t\t\t\tf = 1;\n\t\t\t\tnext_state = STATE_C;\n\t\t\tend\n\t\t\tSTATE_C: begin\n\t\t\t\tif (x_count == 2'b11)\n\t\t\t\t\tnext_state = STATE_D;\n\t\t\tend\n\t\t\tSTATE_D: begin\n\t\t\t\tg = 1;\n\t\t\t\tnext_state = STATE_E;\n\t\t\tend\n\t\t\tSTATE_E: begin\n\t\t\t\tg = 1;\n\t\t\t\tif (y)\n\t\t\t\t\tnext_state = STATE_G;\n\t\t\t\telse if (y_count == 2'b10)\n\t\t\t\t\tnext_state = STATE_F;\n\t\t\tend\n\t\t\tSTATE_F: begin\n\t\t\t\tg = 0;\n\t\t\tend\n\t\t\tSTATE_G: begin\n\t\t\t\tg = 1;\n\t\t\tend\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tx_count <= 2'b00;\n\t\t\ty_count <= 2'b00;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tSTATE_C: begin\n\t\t\t\t\tx_count <= {x_count[0], x};\n\t\t\t\tend\n\t\t\t\tSTATE_E: begin\n\t\t\t\t\ty_count <= y_count + 1'b1;\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tx_count <= 2'b00;\n\t\t\t\t\ty_count <= 2'b00;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101, G = 3'b110;\n    reg [2:0] state, next_state;\n    reg [1:0] counter;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            A: begin\n                if (resetn) next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x) next_state = D;\n            end\n            D: begin\n                if (!x) next_state = E;\n                else next_state = C;\n            end\n            E: begin\n                if (x) next_state = F;\n                else next_state = C;\n            end\n            F: begin\n                g = 1;\n                if (y) next_state = G;\n                else if (counter == 2'b10) next_state = A;\n            end\n            G: begin\n                g = 1;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn)\n            counter <= 2'b00;\n        else if (state == F)\n            counter <= counter + 1'b1;\n        else\n            counter <= 2'b00;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter STATE_A = 3'b000;\n    parameter STATE_B = 3'b001;\n    parameter STATE_C = 3'b010;\n    parameter STATE_D = 3'b011;\n    parameter STATE_E = 3'b100;\n    parameter STATE_F = 3'b101;\n    parameter STATE_G = 3'b110;\n    parameter STATE_H = 3'b111;\n\n    reg [2:0] current_state, next_state;\n    reg [1:0] x_counter, y_counter;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = resetn ? STATE_B : STATE_A;\n            STATE_B: next_state = STATE_C;\n            STATE_C: next_state = (x_counter == 2'b11) ? STATE_D : STATE_C;\n            STATE_D: next_state = STATE_E;\n            STATE_E: next_state = y ? STATE_G : (y_counter == 2'b10) ? STATE_F : STATE_E;\n            STATE_F: next_state = STATE_F;\n            STATE_G: next_state = STATE_G;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_counter <= 2'b00;\n            y_counter <= 2'b00;\n        end else begin\n            case (current_state)\n                STATE_C: x_counter <= (x) ? {x_counter[0], 1'b1} : {x_counter[0], 1'b0};\n                STATE_E: y_counter <= y_counter + 1;\n                default: begin\n                    x_counter <= 2'b00;\n                    y_counter <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        f = (current_state == STATE_B);\n        g = (current_state == STATE_D) || (current_state == STATE_E) || (current_state == STATE_G);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101, G = 3'b110;\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            A: begin\n                if (resetn) next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x) next_state = D;\n            end\n            D: begin\n                if (!x) next_state = E;\n                else next_state = C;\n            end\n            E: begin\n                if (x) next_state = F;\n                else next_state = C;\n            end\n            F: begin\n                g = 1;\n                if (y) next_state = G;\n                else if (count == 2) next_state = A;\n            end\n            G: begin\n                g = 1;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn)\n            count <= 0;\n        else if (state == F)\n            count <= count + 1;\n        else\n            count <= 0;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    localparam STATE_A = 3'd0,\n               STATE_B = 3'd1,\n               STATE_C = 3'd2,\n               STATE_D = 3'd3,\n               STATE_E = 3'd4,\n               STATE_F = 3'd5,\n               STATE_G = 3'd6,\n               STATE_H = 3'd7;\n\n    reg [2:0] state, next_state;\n    reg [1:0] y_counter;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            STATE_A: begin\n                if (resetn)\n                    next_state = STATE_B;\n            end\n            STATE_B: begin\n                f = 1;\n                next_state = STATE_C;\n            end\n            STATE_C: begin\n                if (x)\n                    next_state = STATE_D;\n            end\n            STATE_D: begin\n                if (!x)\n                    next_state = STATE_E;\n                else\n                    next_state = STATE_C;\n            end\n            STATE_E: begin\n                if (x)\n                    next_state = STATE_F;\n                else\n                    next_state = STATE_C;\n            end\n            STATE_F: begin\n                g = 1;\n                if (y)\n                    next_state = STATE_H;\n                else\n                    next_state = STATE_G;\n            end\n            STATE_G: begin\n                g = 1;\n                if (y)\n                    next_state = STATE_H;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_H: begin\n                g = 1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101, G = 3'b110;\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        case (state)\n            A: begin\n                if (resetn)\n                    next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x)\n                    next_state = D;\n            end\n            D: begin\n                if (!x)\n                    next_state = E;\n                else\n                    next_state = C;\n            end\n            E: begin\n                if (x)\n                    next_state = F;\n                else\n                    next_state = C;\n            end\n            F: begin\n                g = 1;\n                if (y)\n                    next_state = G;\n                else if (count == 2'b10)\n                    next_state = G;\n            end\n            G: begin\n                g = (y | count != 2'b10);\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn)\n            count <= 2'b00;\n        else if (state == F)\n            count <= count + 1'b1;\n        else\n            count <= 2'b00;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    localparam STATE_A = 3'd0, STATE_B = 3'd1, STATE_C = 3'd2, STATE_D = 3'd3, STATE_E = 3'd4, STATE_F = 3'd5, STATE_G = 3'd6;\n    reg [2:0] state, next_state;\n    reg [1:0] x_count, y_count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            STATE_A: begin\n                if (resetn)\n                    next_state = STATE_B;\n            end\n            STATE_B: begin\n                f = 1;\n                next_state = STATE_C;\n            end\n            STATE_C: begin\n                if (x_count == 2'b11)\n                    next_state = STATE_D;\n            end\n            STATE_D: begin\n                g = 1;\n                next_state = STATE_E;\n            end\n            STATE_E: begin\n                g = 1;\n                if (y)\n                    next_state = STATE_F;\n                else if (y_count == 2'b10)\n                    next_state = STATE_G;\n            end\n            STATE_F: begin\n                g = 1;\n            end\n            STATE_G: begin\n                g = 0;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_count <= 2'b00;\n            y_count <= 2'b00;\n        end\n        else begin\n            case (state)\n                STATE_C: begin\n                    x_count <= {x_count[0], x};\n                end\n                STATE_E: begin\n                    y_count <= y_count + 1'b1;\n                end\n                default: begin\n                    x_count <= 2'b00;\n                    y_count <= 2'b00;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter STATE_A = 3'b000;\n    parameter STATE_B = 3'b001;\n    parameter STATE_C = 3'b010;\n    parameter STATE_D = 3'b011;\n    parameter STATE_E = 3'b100;\n    parameter STATE_F = 3'b101;\n    parameter STATE_G = 3'b110;\n    parameter STATE_H = 3'b111;\n\n    reg [2:0] state, next_state;\n    reg [1:0] x_counter;\n    reg [1:0] y_counter;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            STATE_A: begin\n                if (resetn)\n                    next_state = STATE_B;\n            end\n            STATE_B: begin\n                f = 1;\n                next_state = STATE_C;\n            end\n            STATE_C: begin\n                if (x)\n                    next_state = STATE_D;\n            end\n            STATE_D: begin\n                if (!x)\n                    next_state = STATE_E;\n                else\n                    next_state = STATE_C;\n            end\n            STATE_E: begin\n                if (x)\n                    next_state = STATE_F;\n                else\n                    next_state = STATE_C;\n            end\n            STATE_F: begin\n                g = 1;\n                if (y)\n                    next_state = STATE_H;\n                else if (y_counter == 2'b01)\n                    next_state = STATE_G;\n            end\n            STATE_G: begin\n                g = 0;\n            end\n            STATE_H: begin\n                g = 1;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_counter <= 2'b00;\n            y_counter <= 2'b00;\n        end\n        else begin\n            case (state)\n                STATE_C, STATE_D, STATE_E: begin\n                    if (x)\n                        x_counter <= x_counter + 1;\n                    else\n                        x_counter <= 2'b00;\n                end\n                STATE_F: begin\n                    y_counter <= y_counter + 1;\n                end\n                default: begin\n                    x_counter <= 2'b00;\n                    y_counter <= 2'b00;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    // State encoding\n    localparam STATE_A = 3'd0,\n               STATE_B = 3'd1,\n               STATE_C = 3'd2,\n               STATE_D = 3'd3,\n               STATE_E = 3'd4,\n               STATE_F = 3'd5,\n               STATE_G = 3'd6;\n\n    reg [2:0] current_state, next_state;\n    reg [1:0] x_counter, y_counter;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        next_state = current_state;\n        f = 1'b0;\n        g = 1'b0;\n\n        case (current_state)\n            STATE_A: begin\n                if (resetn)\n                    next_state = STATE_B;\n            end\n            STATE_B: begin\n                f = 1'b1;\n                next_state = STATE_C;\n            end\n            STATE_C: begin\n                if (x_counter == 2'b11)\n                    next_state = STATE_D;\n            end\n            STATE_D: begin\n                g = 1'b1;\n                if (y)\n                    next_state = STATE_G;\n                else if (y_counter == 2'b10)\n                    next_state = STATE_F;\n                else\n                    next_state = STATE_E;\n            end\n            STATE_E: begin\n                g = 1'b1;\n                if (y)\n                    next_state = STATE_G;\n                else\n                    next_state = STATE_F;\n            end\n            STATE_F: begin\n                // g remains 0, stay in this state until reset\n            end\n            STATE_G: begin\n                g = 1'b1;\n                // Stay in this state until reset\n            end\n        endcase\n    end\n\n    // X counter logic\n    always @(posedge clk) begin\n        if (!resetn || current_state != STATE_C)\n            x_counter <= 2'b00;\n        else if (current_state == STATE_C) begin\n            if (x_counter == 2'b00 && x == 1'b1)\n                x_counter <= 2'b01;\n            else if (x_counter == 2'b01 && x == 1'b0)\n                x_counter <= 2'b10;\n            else if (x_counter == 2'b10 && x == 1'b1)\n                x_counter <= 2'b11;\n            else\n                x_counter <= 2'b00;\n        end\n    end\n\n    // Y counter logic\n    always @(posedge clk) begin\n        if (!resetn || current_state != STATE_D)\n            y_counter <= 2'b00;\n        else if (current_state == STATE_D || current_state == STATE_E)\n            y_counter <= y_counter + 1'b1;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101, G = 3'b110;\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            A: begin\n                if (resetn)\n                    next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x)\n                    next_state = D;\n            end\n            D: begin\n                if (!x)\n                    next_state = E;\n                else\n                    next_state = C;\n            end\n            E: begin\n                if (x)\n                    next_state = F;\n                else\n                    next_state = C;\n            end\n            F: begin\n                g = 1;\n                if (y)\n                    next_state = G;\n                else if (count == 2'b01)\n                    next_state = G;\n            end\n            G: begin\n                g = (count != 2'b10);\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn)\n            count <= 2'b00;\n        else if (state == F)\n            count <= count + 1'b1;\n        else\n            count <= 2'b00;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    localparam STATE_A = 3'd0,\n               STATE_B = 3'd1,\n               STATE_C = 3'd2,\n               STATE_D = 3'd3,\n               STATE_E = 3'd4,\n               STATE_F = 3'd5,\n               STATE_G = 3'd6,\n               STATE_H = 3'd7;\n\n    reg [2:0] state, next_state;\n    reg [1:0] y_counter;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            STATE_A: begin\n                if (resetn)\n                    next_state = STATE_B;\n            end\n            STATE_B: begin\n                f = 1;\n                next_state = STATE_C;\n            end\n            STATE_C: begin\n                if (x)\n                    next_state = STATE_D;\n            end\n            STATE_D: begin\n                if (!x)\n                    next_state = STATE_E;\n                else\n                    next_state = STATE_C;\n            end\n            STATE_E: begin\n                if (x)\n                    next_state = STATE_F;\n                else\n                    next_state = STATE_C;\n            end\n            STATE_F: begin\n                g = 1;\n                if (y)\n                    next_state = STATE_H;\n                else\n                    next_state = STATE_G;\n            end\n            STATE_G: begin\n                g = 1;\n                if (y)\n                    next_state = STATE_H;\n                else if (y_counter == 2'd1)\n                    next_state = STATE_A;\n            end\n            STATE_H: begin\n                g = 1;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn)\n            y_counter <= 2'd0;\n        else if (state == STATE_F)\n            y_counter <= 2'd0;\n        else if (state == STATE_G)\n            y_counter <= y_counter + 1'b1;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    parameter STATE_A = 3'b000;\n    parameter STATE_B = 3'b001;\n    parameter STATE_C = 3'b010;\n    parameter STATE_D = 3'b011;\n    parameter STATE_E = 3'b100;\n    parameter STATE_F = 3'b101;\n    parameter STATE_G = 3'b110;\n    parameter STATE_H = 3'b111;\n\n    reg [2:0] state, next_state;\n    reg [1:0] x_counter;\n    reg [1:0] y_counter;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n\n        case (state)\n            STATE_A: begin\n                if (resetn)\n                    next_state = STATE_B;\n            end\n            STATE_B: begin\n                f = 1;\n                next_state = STATE_C;\n            end\n            STATE_C: begin\n                if (x)\n                    next_state = STATE_D;\n            end\n            STATE_D: begin\n                if (!x)\n                    next_state = STATE_E;\n                else\n                    next_state = STATE_C;\n            end\n            STATE_E: begin\n                if (x)\n                    next_state = STATE_F;\n                else\n                    next_state = STATE_C;\n            end\n            STATE_F: begin\n                g = 1;\n                next_state = STATE_G;\n            end\n            STATE_G: begin\n                g = 1;\n                if (y)\n                    next_state = STATE_H;\n                else if (y_counter == 2'b01)\n                    next_state = STATE_A;\n            end\n            STATE_H: begin\n                g = 1;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_counter <= 2'b00;\n            y_counter <= 2'b00;\n        end else begin\n            case (state)\n                STATE_C, STATE_D, STATE_E: begin\n                    if (x)\n                        x_counter <= x_counter + 1;\n                    else\n                        x_counter <= 2'b00;\n                end\n                STATE_G: begin\n                    y_counter <= y_counter + 1;\n                end\n                default: begin\n                    x_counter <= 2'b00;\n                    y_counter <= 2'b00;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    localparam A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5, G = 3'd6;\n    reg [2:0] state, next_state;\n    reg [1:0] y_count;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            A: begin\n                if (resetn)\n                    next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x)\n                    next_state = D;\n            end\n            D: begin\n                if (!x)\n                    next_state = E;\n                else\n                    next_state = C;\n            end\n            E: begin\n                if (x)\n                    next_state = F;\n                else\n                    next_state = C;\n            end\n            F: begin\n                g = 1;\n                if (y)\n                    next_state = G;\n                else if (y_count == 2'b10)\n                    next_state = A;\n            end\n            G: begin\n                g = 1;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!resetn)\n            y_count <= 2'b00;\n        else if (state == F)\n            y_count <= y_count + 1'b1;\n        else\n            y_count <= 2'b00;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    localparam STATE_A = 3'b000;\n    localparam STATE_B = 3'b001;\n    localparam STATE_C = 3'b010;\n    localparam STATE_D = 3'b011;\n    localparam STATE_E = 3'b100;\n    localparam STATE_F = 3'b101;\n    localparam STATE_G = 3'b110;\n    localparam STATE_H = 3'b111;\n\n    reg [2:0] state, next_state;\n    reg [1:0] y_counter;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        g = 0;\n        case (state)\n            STATE_A: begin\n                if (resetn) next_state = STATE_B;\n            end\n            STATE_B: begin\n                f = 1;\n                next_state = STATE_C;\n            end\n            STATE_C: begin\n                if (x) next_state = STATE_D;\n            end\n            STATE_D: begin\n                if (!x) next_state = STATE_E;\n                else next_state = STATE_C;\n            end\n            STATE_E: begin\n                if (x) next_state = STATE_F;\n                else next_state = STATE_C;\n            end\n            STATE_F: begin\n                g = 1;\n                if (y) next_state = STATE_H;\n                else next_state = STATE_G;\n            end\n            STATE_G: begin\n                g = 1;\n                if (y) next_state = STATE_H;\n                else next_state = STATE_A;\n            end\n            STATE_H: begin\n                g = 1;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n\tparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101, G = 3'b110, H = 3'b111;\n\treg [2:0] state, next_state;\n\treg [1:0] count;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tf = 0;\n\t\tg = 0;\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (resetn) next_state = B;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tf = 1;\n\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (x) next_state = D;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (!x) next_state = E;\n\t\t\t\telse next_state = C;\n\t\t\tend\n\t\t\tE: begin\n\t\t\t\tif (x) next_state = F;\n\t\t\t\telse next_state = C;\n\t\t\tend\n\t\t\tF: begin\n\t\t\t\tg = 1;\n\t\t\t\tif (y) next_state = G;\n\t\t\t\telse if (count == 2'b10) next_state = H;\n\t\t\tend\n\t\t\tG: begin\n\t\t\t\tg = 1;\n\t\t\tend\n\t\t\tH: begin\n\t\t\t\tg = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tcount <= 2'b00;\n\t\telse if (state == F)\n\t\t\tcount <= count + 1'b1;\n\t\telse\n\t\t\tcount <= 2'b00;\n\tend\n\nendmodule"]}
{"task_id": "dff8p", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\n\talways @(negedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 8'h34;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;  // Reset to 0x34\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset) begin\n            q <= 8'h34;  // Reset to 0x34\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;  // Reset to 0x34\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;\n    else\n        q <= d;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule"]}
{"task_id": "reduction", "llmgen_RTL": ["module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n    assign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n    assign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n    assign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n    assign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n    assign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n    assign parity = ^in;\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n    assign parity = ^in;\n\nendmodule"]}
{"task_id": "fsm3comb", "llmgen_RTL": ["module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;\n            2'b01: next_state = in ? 2'b01 : 2'b10;\n            2'b10: next_state = in ? 2'b11 : 2'b00;\n            2'b11: next_state = in ? 2'b01 : 2'b10;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // State A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // State B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // State C\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // State D\n        endcase\n    end\n\n    assign out = (state == 2'b11);  // Output is 1 only in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case(state)\n            2'b00: next_state = in ? 2'b01 : 2'b00; // A\n            2'b01: next_state = in ? 2'b01 : 2'b10; // B\n            2'b10: next_state = in ? 2'b11 : 2'b00; // C\n            2'b11: next_state = in ? 2'b01 : 2'b10; // D\n        endcase\n    end\n\n    assign out = (state == 2'b11); // Output is 1 only when in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // C\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // D\n        endcase\n    end\n\n    assign out = (state == 2'b11);  // Output is 1 only when in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00; // A\n            2'b01: next_state = in ? 2'b01 : 2'b10; // B\n            2'b10: next_state = in ? 2'b11 : 2'b00; // C\n            2'b11: next_state = in ? 2'b01 : 2'b10; // D\n        endcase\n    end\n\n    assign out = (state == 2'b11); // Output is 1 only when in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // C\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // D\n        endcase\n    end\n\n    assign out = (state == 2'b11);  // Output is 1 only in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;\n            2'b01: next_state = in ? 2'b01 : 2'b10;\n            2'b10: next_state = in ? 2'b11 : 2'b00;\n            2'b11: next_state = in ? 2'b01 : 2'b10;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;\n            2'b01: next_state = in ? 2'b01 : 2'b10;\n            2'b10: next_state = in ? 2'b11 : 2'b00;\n            2'b11: next_state = in ? 2'b01 : 2'b10;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // State A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // State B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // State C\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // State D\n        endcase\n    end\n\n    assign out = (state == 2'b11);  // Output is 1 only in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;\n            2'b01: next_state = in ? 2'b01 : 2'b10;\n            2'b10: next_state = in ? 2'b11 : 2'b00;\n            2'b11: next_state = in ? 2'b01 : 2'b10;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;\n            2'b01: next_state = in ? 2'b01 : 2'b10;\n            2'b10: next_state = in ? 2'b11 : 2'b00;\n            2'b11: next_state = in ? 2'b01 : 2'b10;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // State A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // State B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // State C\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // State D\n        endcase\n    end\n\n    assign out = (state == 2'b11);  // Output is 1 only in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;\n            2'b01: next_state = in ? 2'b01 : 2'b10;\n            2'b10: next_state = in ? 2'b11 : 2'b00;\n            2'b11: next_state = in ? 2'b01 : 2'b10;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // State A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // State B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // State C\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // State D\n        endcase\n    end\n\n    assign out = (state == 2'b11);  // Output is 1 only in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;\n            2'b01: next_state = in ? 2'b01 : 2'b10;\n            2'b10: next_state = in ? 2'b11 : 2'b00;\n            2'b11: next_state = in ? 2'b01 : 2'b10;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n\tend\n\n\tassign out = (state == D);\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // C\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // D\n        endcase\n    end\n\n    assign out = (state == 2'b11);  // Output is 1 only in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // C\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // D\n        endcase\n    end\n\n    assign out = (state == 2'b11);  // Output is 1 only in state D\n\nendmodule"]}
{"task_id": "mt2015_q4b", "llmgen_RTL": ["module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    reg z;\n    reg [1:0] state;\n    \n    always @(*) begin\n        case (state)\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n        endcase\n    end\n    \n    always @(x or y) begin\n        state = {x, y};\n    end\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    reg z;\n    reg [1:0] state;\n    \n    always @(*) begin\n        case (state)\n            2'b00: z = 1'b1;\n            2'b01: z = 1'b0;\n            2'b10: z = 1'b0;\n            2'b11: z = 1'b1;\n        endcase\n    end\n    \n    always @(x or y) begin\n        case ({x, y})\n            2'b00: state <= 2'b00;\n            2'b01: state <= 2'b10;\n            2'b10: state <= 2'b01;\n            2'b11: state <= 2'b11;\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(*) begin\n        case (state)\n            3'b000: next_state = (x | y) ? 3'b001 : 3'b000;\n            3'b001: next_state = (x & y) ? 3'b010 : 3'b001;\n            3'b010: next_state = 3'b000;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    always @(posedge x or posedge y) begin\n        state <= next_state;\n    end\n\n    assign z = (state == 3'b000) | (state == 3'b010);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    reg [1:0] state;\n    wire [1:0] next_state;\n\n    always @(posedge x or posedge y) begin\n        if (x || y)\n            state <= next_state;\n    end\n\n    assign next_state = (x & y) ? 2'b11 :\n                        (x & ~y) ? 2'b01 :\n                        (~x & y) ? 2'b10 :\n                        2'b00;\n\n    assign z = (state == 2'b00) | (state == 2'b11);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\n    reg z_reg;\n    \n    always @(*) begin\n        if (x && y)\n            z_reg = 1'b1;\n        else if (!x && !y)\n            z_reg = 1'b1;\n        else\n            z_reg = 1'b0;\n    end\n    \n    assign z = z_reg;\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule"]}
{"task_id": "2012_q2fsm", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) | (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    reg [2:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    reg [2:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    // State encoding\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    reg [2:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    // State encoding\n    localparam A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    reg [2:0] state, next_state;\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    // State encoding\n    localparam A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    reg [2:0] state, next_state;\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    // State encoding\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n    reg [2:0] state, next_state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    assign z = (state == E) || (state == F);\n\nendmodule"]}
{"task_id": "dff16e", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0])\n            q[7:0] <= d[7:0];\n        if (byteena[1])\n            q[15:8] <= d[15:8];\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule"]}
{"task_id": "edgedetect", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= (~in_prev) & in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n\treg [7:0] in_prev;\n\n\talways @(posedge clk) begin\n\t\tin_prev <= in;\n\t\tpedge <= in & ~in_prev;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= (~in_prev) & in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= (~in_prev) & in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        in_prev <= in;\n        pedge <= (~in_prev) & in;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= ~in_prev & in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= (~in_prev) & in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n\treg [7:0] in_prev;\n\n\talways @(posedge clk) begin\n\t\tin_prev <= in;\n\t\tpedge <= in & ~in_prev;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= (~in_prev) & in;\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge\n);\n\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\n\nendmodule"]}
{"task_id": "circuit8", "llmgen_RTL": ["module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\nreg state;\n\nalways @(posedge clock or posedge a) begin\n    if (a) begin\n        p <= 1;\n        state <= 1;\n    end else begin\n        p <= 0;\n        if (state) begin\n            q <= 1;\n            state <= 0;\n        end\n    end\nend\n\nalways @(negedge clock) begin\n    if (a) begin\n        p <= 1;\n    end else if (p) begin\n        q <= 1;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\nreg state;\n\nalways @(posedge clock or negedge clock) begin\n    if (clock) begin\n        state <= a;\n        p <= a;\n    end else begin\n        q <= state & p;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end\n        else begin\n            p <= 0;\n            if (state)\n                q <= 1;\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (a)\n            q <= 0;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end else begin\n            p <= 0;\n            if (state) begin\n                q <= 1;\n            end\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (a) begin\n            p <= 1;\n        end else begin\n            p <= 0;\n            if (state) begin\n                q <= 1;\n            end\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\nreg state;\n\nalways @(posedge clock) begin\n    state <= a;\n    p <= a & ~state;\nend\n\nalways @(negedge clock) begin\n    q <= p;\nend\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end\n        else begin\n            p <= 0;\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (state)\n            q <= 1;\n        else\n            q <= 0;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end\n        else begin\n            p <= 0;\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (state)\n            q <= 1;\n        else\n            q <= 0;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end else begin\n            p <= 0;\n            if (state)\n                q <= 1;\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (a) begin\n            p <= 1;\n        end else begin\n            p <= 0;\n            q <= state;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\nreg state;\n\nalways @(posedge clock) begin\n    if (a) begin\n        p <= 1;\n        state <= 1;\n    end\n    else begin\n        p <= 0;\n        state <= 0;\n    end\nend\n\nalways @(negedge clock) begin\n    if (state)\n        q <= 1;\n    else\n        q <= 0;\nend\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            state <= 1'b1;\n            p <= 1'b1;\n        end else begin\n            state <= 1'b0;\n            p <= 1'b0;\n        end\n    end\n\n    always @(negedge clock) begin\n        q <= state;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end else begin\n            p <= 0;\n            if (state)\n                q <= 1;\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (a)\n            q <= 0;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end\n        else begin\n            p <= 0;\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (state)\n            q <= 1;\n        else\n            q <= 0;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            state <= 1'b1;\n            p <= 1'b1;\n        end else begin\n            state <= 1'b0;\n            p <= 1'b0;\n        end\n    end\n\n    always @(negedge clock) begin\n        q <= state;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            state <= 1'b1;\n            p <= 1'b1;\n        end else begin\n            state <= 1'b0;\n            p <= 1'b0;\n        end\n    end\n\n    always @(negedge clock) begin\n        q <= state;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\nreg state;\n\nalways @(posedge clock) begin\n    state <= a;\n    p <= a & ~state;\nend\n\nalways @(negedge clock) begin\n    q <= p;\nend\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\nreg state;\n\nalways @(posedge clock) begin\n    if (a) begin\n        p <= 1;\n        state <= 1;\n    end else begin\n        p <= 0;\n        if (state) begin\n            q <= 1;\n        end\n        state <= 0;\n    end\nend\n\nalways @(negedge clock) begin\n    if (a) begin\n        q <= 0;\n    end\nend\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end\n        else begin\n            p <= 0;\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (state)\n            q <= 1;\n        else\n            q <= 0;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            state <= 1;\n        end\n        else begin\n            p <= 0;\n            state <= 0;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (state)\n            q <= 1;\n        else\n            q <= 0;\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock or negedge clock) begin\n        if (clock) begin\n            state <= a;\n            p <= a;\n        end else begin\n            q <= state & p;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n    reg state;\n\n    always @(posedge clock) begin\n        if (a) begin\n            state <= 1'b1;\n            p <= 1'b1;\n        end else begin\n            state <= 1'b0;\n            p <= 1'b0;\n        end\n    end\n\n    always @(negedge clock) begin\n        q <= state;\n    end\n\nendmodule"]}
{"task_id": "rule90", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[0] <= q[1];\n            \n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[0] <= q[1];\n            \n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[511] <= q[510];\n            q[510:1] <= q[511:2] ^ q[509:0];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule"]}
{"task_id": "mt2015_eq2", "llmgen_RTL": ["module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z\n);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z\n);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z\n);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z\n);\n\n\tassign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n    assign z = (A == B);\n\nendmodule"]}
{"task_id": "gatesv100", "llmgen_RTL": ["module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // Generate out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_both\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Generate out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : gen_out_any\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Generate out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_different\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n\n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // (1) out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // (2) out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // (3) out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n\n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // (1) out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_gen\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // (2) out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_gen\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // (3) out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : different_gen\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : diff_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // Generate out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_both\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Generate out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : gen_out_any\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Generate out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_different\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n\n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_gen\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_gen\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : diff_gen\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : diff_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n\n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[0] = in[0] ^ in[99];\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i-1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_gen\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_gen\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : diff_gen\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_gen\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_gen\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : diff_gen\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n\n    // Generate out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_both\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Generate out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : gen_any\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Generate out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_different\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // Generate out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_both\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Generate out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : gen_any\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Generate out_different\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_different\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n    \n    // Handle wrap-around case for out_different[99]\n    assign out_different[99] = in[99] ^ in[0];\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n    \n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_gen\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_gen\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : diff_gen\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    genvar i;\n\n    // out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_gen\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_gen\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different\n    assign out_different[99] = in[99] ^ in[0];\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : diff_gen\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule"]}
{"task_id": "m2014_q4a", "llmgen_RTL": ["module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\nalways_latch begin\n\tif (ena) begin\n\t\tq <= d;\n\tend\nend\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\nalways_latch begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\nalways_latch begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n\talways_latch begin\n\t\tif (ena) begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\nalways_latch begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\nalways_latch begin\n\tif (ena) begin\n\t\tq <= d;\n\tend\nend\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\nalways_latch begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\nalways_latch begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n    always_latch begin\n        if (ena) begin\n            q <= d;\n        end\n    end\n\nendmodule"]}
{"task_id": "mux256to1v", "llmgen_RTL": ["module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] selected;\n    assign selected = in[sel*4 +: 4];\n    assign out = selected;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] mux_out;\n    \n    assign mux_out = in[sel*4 +: 4];\n    assign out = mux_out;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] mux_out;\n    \n    assign mux_out = in[sel*4 +: 4];\n    assign out = mux_out;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] selected;\n    \n    assign selected = in[sel*4 +: 4];\n    assign out = selected;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] mux_out;\n    \n    assign mux_out = in[sel*4 +: 4];\n    assign out = mux_out;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] mux_out;\n    \n    assign mux_out = in[sel*4 +: 4];\n    assign out = mux_out;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    assign out = in[sel*4 +: 4];\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] selected_bits;\n    \n    assign selected_bits = in[sel*4 +: 4];\n    assign out = selected_bits;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    assign out = in[sel*4 +: 4];\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] mux_out;\n    \n    assign mux_out = in[sel*4 +: 4];\n    assign out = mux_out;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] mux_out;\n    \n    assign mux_out = in[sel*4 +: 4];\n    assign out = mux_out;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] selected;\n    assign selected = in[sel*4 +: 4];\n    assign out = selected;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    assign out = in[sel*4 +: 4];\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    assign out = in[sel*4 +: 4];\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] selected_bits;\n    \n    assign selected_bits = in[sel*4 +: 4];\n    assign out = selected_bits;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    assign out = in[sel*4 +: 4];\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n\tassign out = in[sel*4 +: 4];\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] mux_out;\n    \n    assign mux_out = in[sel*4 +: 4];\n    assign out = mux_out;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    wire [3:0] mux_out;\n    \n    assign mux_out = in[sel*4 +: 4];\n    assign out = mux_out;\n\nendmodule", "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n    assign out = in[sel*4 +: 4];\n\nendmodule"]}
{"task_id": "mux9to1v", "llmgen_RTL": ["module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always_comb begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always_comb begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always_comb begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always_comb begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n    always_comb begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "vectorgates", "llmgen_RTL": ["module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[5:3] = ~b;\n    assign out_not[2:0] = ~a;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = |a || |b;\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = |a || |b;\n    assign out_not = {~b, ~a};\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = |a || |b;\n    assign out_not[5:3] = ~b;\n    assign out_not[2:0] = ~a;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operations\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = |a || |b;\n    assign out_not = {~b, ~a};\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[5:3] = ~b;\n    assign out_not[2:0] = ~a;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operations\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = |a || |b;\n\n    // NOT operation\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule"]}
{"task_id": "fsm3onehot", "llmgen_RTL": ["module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // Output is 1 only when in state D (4'b1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;  // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;  // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;  // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;  // D\n            default: next_state = 4'b0001;  // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3];  // Output is 1 only when in state D (4'b1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;\n            default: next_state = 4'b0001;\n        endcase\n    end\n\n    assign out = state[3];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // Output is 1 only in state D (4'b1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // Output is 1 only when in state D (4'b1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // Output is 1 only when in state D (4'b1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;\n            default: next_state = 4'b0001;\n        endcase\n    end\n\n    assign out = state[3];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // D state (1000) produces output 1\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;\n            default: next_state = 4'b0001;\n        endcase\n    end\n\n    assign out = state[3];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // Output is 1 only when in state D (4'b1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        next_state[0] = (state[0] & ~in) | (state[2] & ~in);\n        next_state[1] = (state[0] & in) | (state[1]) | (state[3] & in);\n        next_state[2] = (state[1] & ~in) | (state[3] & ~in);\n        next_state[3] = (state[2] & in);\n    end\n\n    assign out = state[3];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // D state (1000) produces output 1\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // D state (1000) produces output 1\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;\n            default: next_state = 4'b0001;\n        endcase\n    end\n\n    assign out = state[3];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        next_state[0] = (state[0] & ~in) | (state[2] & ~in);\n        next_state[1] = (state[0] & in) | (state[1]) | (state[3] & in);\n        next_state[2] = (state[1] & ~in) | (state[3] & ~in);\n        next_state[3] = (state[2] & in);\n    end\n\n    // Output logic\n    assign out = state[3];\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;  // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;  // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;  // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;  // D\n            default: next_state = 4'b0001;  // Default to state A\n        endcase\n    end\n\n    assign out = state[3];  // Output is 1 only when in state D (4'b1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t4'b0001: next_state = in ? 4'b0010 : 4'b0001;  // A\n\t\t\t4'b0010: next_state = in ? 4'b0010 : 4'b0100;  // B\n\t\t\t4'b0100: next_state = in ? 4'b1000 : 4'b0001;  // C\n\t\t\t4'b1000: next_state = in ? 4'b0010 : 4'b0100;  // D\n\t\t\tdefault: next_state = 4'b0001;  // Default to state A\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign out = (state == 4'b1000);  // Output is 1 only in state D\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // Output is 1 only when in state D (1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // Output is 1 only when in state D (4'b1000)\n\nendmodule", "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;\n            default: next_state = 4'b0001;\n        endcase\n    end\n\n    assign out = state[3];\n\nendmodule"]}
{"task_id": "conditional", "llmgen_RTL": ["module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule"]}
{"task_id": "gates", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"]}
{"task_id": "kmap2", "llmgen_RTL": ["module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~b & ~c & ~d) | \n                 (~a & ~b & ~c & d) | \n                 (~a & ~b & c & ~d) | \n                 (~a & b & ~c & ~d) | \n                 (~a & b & c & d) | \n                 (a & ~b & ~c & ~d) | \n                 (a & ~b & ~c & d) | \n                 (a & b & c & ~d) | \n                 (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~b & ~c & ~d) | \n                 (~a & ~b & ~c & d) | \n                 (~a & ~b & c & ~d) | \n                 (~a & b & ~c & ~d) | \n                 (~a & b & c & d) | \n                 (a & ~b & ~c & ~d) | \n                 (a & ~b & ~c & d) | \n                 (a & ~b & c & d) | \n                 (a & b & c & ~d) | \n                 (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~d) | (~b & ~c & d) | (a & ~b & ~d) | (b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & c & ~d) | (a & ~b & ~c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~b & ~c & ~d) |\n                 (~a & ~b & ~c & d) |\n                 (~a & ~b & c & ~d) |\n                 (~a & b & ~c & ~d) |\n                 (~a & b & c & d) |\n                 (a & ~b & ~c & ~d) |\n                 (a & ~b & ~c & d) |\n                 (a & b & c & ~d) |\n                 (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (~b & ~c & ~d) | (a & ~b & c) | (b & c) | (a & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & c & ~d) | (a & ~b & ~c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~b & ~c & ~d) |\n                 (~a & ~b & ~c & d) |\n                 (~a & b & ~c & ~d) |\n                 (~a & ~b & c & ~d) |\n                 (a & ~b & ~c & ~d) |\n                 (a & ~b & ~c & d) |\n                 (~a & b & c & d) |\n                 (a & b & c & ~d) |\n                 (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & ~b & ~c) | (a & c & ~d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & ~b & ~c) | (a & c & ~d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & c & ~d) | (~b & c & ~d) | (a & ~b & ~c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & ~b & ~c) | (a & c & ~d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~b & ~c & ~d) | \n                 (~a & ~b & ~c & d) | \n                 (~a & ~b & c & ~d) | \n                 (~a & b & ~c & ~d) | \n                 (~a & b & c & d) | \n                 (a & ~b & ~c & ~d) | \n                 (a & ~b & ~c & d) | \n                 (a & ~b & c & d) | \n                 (a & b & c & ~d) | \n                 (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & ~b & ~c) | (a & c & ~d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & c & ~d) | (a & ~b & ~c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & c & ~d) | (~b & c & ~d) | (a & ~b & ~c);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & c & ~d) | (~b & c & ~d) | (a & ~b & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & ~b & ~c) | (a & c & ~d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & ~b & ~c) | (a & c & ~d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n    assign out = (~a & ~c) | (~a & ~b & ~d) | (b & c & d) | (a & ~b & ~c) | (a & c & ~d);\n\nendmodule"]}
{"task_id": "2014_q3fsm", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n    \n    localparam A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == B1 || state == B2)\n                count <= count + w;\n            else if (state == B3) begin\n                z <= (count == 2'd2);\n                count <= w;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            A:   next_state = s ? B1 : A;\n            B1:  next_state = B2;\n            B2:  next_state = B3;\n            B3:  next_state = B1;\n            default: next_state = A;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 1'b0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'd0;\n                    z <= 1'b0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= w ? count + 1'b1 : count;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= w ? count + 1'b1 : count;\n                end\n                B3: begin\n                    state <= B1;\n                    count <= w ? count + 1'b1 : count;\n                    z <= (count + w) == 2'd2;\n                    count <= 2'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n    \n    localparam A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == B1 || state == B2) begin\n                count <= count + w;\n            end else if (state == B3) begin\n                z <= (count + w == 2'd2);\n                count <= 2'd0;\n            end else begin\n                z <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            A:   next_state = s ? B1 : A;\n            B1:  next_state = B2;\n            B2:  next_state = B3;\n            B3:  next_state = B1;\n            default: next_state = A;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    localparam A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'd0;\n                    z <= 0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= w ? count + 1 : count;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= w ? count + 1 : count;\n                end\n                B3: begin\n                    state <= B1;\n                    count <= w ? count + 1 : count;\n                    z <= (count + w) == 2;\n                    count <= 2'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 0;\n            z <= 0;\n        end else begin\n            case (state)\n                A: state <= s ? B : A;\n                B: begin\n                    state <= C;\n                    count <= w;\n                end\n                C: begin\n                    state <= D;\n                    count <= count + w;\n                end\n                D: begin\n                    state <= E;\n                    count <= count + w;\n                end\n                E: begin\n                    state <= B;\n                    z <= (count == 2);\n                    count <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    localparam A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 1'b0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'd0;\n                    z <= 1'b0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= count + w;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= count + w;\n                end\n                B3: begin\n                    state <= B1;\n                    count <= count + w;\n                    z <= (count + w == 2'd2);\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, C = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'b00;\n            z <= 0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'b00;\n                    z <= 0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= count + w;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= count + w;\n                end\n                B3: begin\n                    state <= C;\n                    count <= count + w;\n                end\n                C: begin\n                    state <= B1;\n                    z <= (count == 2'b10);\n                    count <= 2'b00;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 0;\n            z <= 0;\n        end else begin\n            case (state)\n                A: state <= s ? B : A;\n                B: begin\n                    state <= C;\n                    count <= w;\n                end\n                C: begin\n                    state <= D;\n                    count <= count + w;\n                end\n                D: begin\n                    state <= E;\n                    count <= count + w;\n                end\n                E: begin\n                    state <= B;\n                    z <= (count == 2);\n                    count <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 1'b0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'd0;\n                    z <= 1'b0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= w ? count + 1'b1 : count;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= w ? count + 1'b1 : count;\n                end\n                B3: begin\n                    state <= B1;\n                    count <= w ? count + 1'b1 : count;\n                    z <= (count + w) == 2'd2;\n                    count <= 2'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, C = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 0;\n            z <= 0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 0;\n                    z <= 0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= count + w;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= count + w;\n                end\n                B3: begin\n                    state <= C;\n                    count <= count + w;\n                end\n                C: begin\n                    state <= B1;\n                    z <= (count == 2);\n                    count <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state, next_state;\n    reg [1:0] count;\n    \n    localparam A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A:   next_state = s ? B1 : A;\n            B1:  next_state = B2;\n            B2:  next_state = B3;\n            B3:  next_state = B1;\n            default: next_state = A;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n            z <= 0;\n        end else begin\n            case (state)\n                B1: count <= w;\n                B2: count <= count + w;\n                B3: begin\n                    count <= count + w;\n                    z <= (count + w == 2);\n                end\n                default: begin\n                    count <= 0;\n                    z <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\nreg [2:0] state, next_state;\nreg [1:0] count;\n\nparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\nalways @(posedge clk) begin\n    if (reset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    next_state = state;\n    case (state)\n        A: if (s) next_state = B;\n        B: next_state = C;\n        C: next_state = D;\n        D: next_state = E;\n        E: next_state = B;\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 0;\n        z <= 0;\n    end\n    else begin\n        case (state)\n            B: count <= w;\n            C: count <= count + w;\n            D: count <= count + w;\n            E: begin\n                z <= (count == 2);\n                count <= 0;\n            end\n            default: begin\n                count <= 0;\n                z <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 1'b0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'd0;\n                    z <= 1'b0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= count + w;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= count + w;\n                end\n                B3: begin\n                    state <= B1;\n                    count <= count + w;\n                    z <= (count + w == 2'd2);\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'd0;\n                    z <= 0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= w ? count + 1 : count;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= w ? count + 1 : count;\n                end\n                B3: begin\n                    state <= B1;\n                    count <= w ? count + 1 : count;\n                    z <= (count + w) == 2;\n                    count <= 2'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 1'b0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'd0;\n                    z <= 1'b0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= count + w;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= count + w;\n                end\n                B3: begin\n                    state <= B1;\n                    count <= count + w;\n                    z <= (count + w == 2'd2);\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'b00;\n            z <= 0;\n        end else begin\n            case (state)\n                A: state <= s ? B : A;\n                B: begin\n                    state <= C;\n                    count <= w ? 2'b01 : 2'b00;\n                end\n                C: begin\n                    state <= D;\n                    count <= count + w;\n                end\n                D: begin\n                    state <= E;\n                    count <= count + w;\n                end\n                E: begin\n                    state <= B;\n                    z <= (count == 2'b10);\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'b00;\n            z <= 0;\n        end else begin\n            case (state)\n                A: state <= s ? B : A;\n                B: begin\n                    state <= C;\n                    count <= w ? 2'b01 : 2'b00;\n                end\n                C: begin\n                    state <= D;\n                    count <= count + w;\n                end\n                D: begin\n                    state <= E;\n                    count <= count + w;\n                end\n                E: begin\n                    state <= B;\n                    z <= (count == 2'b10);\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'd0, B1 = 3'd1, B2 = 3'd2, B3 = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'd0;\n            z <= 1'b0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 2'd0;\n                    z <= 1'b0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= w ? count + 1 : count;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= w ? count + 1 : count;\n                end\n                B3: begin\n                    state <= B1;\n                    count <= w ? count + 1 : count;\n                    z <= (count + w) == 2'd2;\n                    count <= 2'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n    reg [2:0] state;\n    reg [1:0] count;\n    \n    parameter A = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, C = 3'b100;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 0;\n            z <= 0;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) state <= B1;\n                    count <= 0;\n                    z <= 0;\n                end\n                B1: begin\n                    state <= B2;\n                    count <= count + w;\n                end\n                B2: begin\n                    state <= B3;\n                    count <= count + w;\n                end\n                B3: begin\n                    state <= C;\n                    count <= count + w;\n                end\n                C: begin\n                    state <= B1;\n                    z <= (count == 2);\n                    count <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\nreg [2:0] state;\nreg [1:0] count;\n\nparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= A;\n        count <= 0;\n        z <= 0;\n    end else begin\n        case (state)\n            A: state <= s ? B : A;\n            B: begin\n                state <= C;\n                count <= w;\n            end\n            C: begin\n                state <= D;\n                count <= count + w;\n            end\n            D: begin\n                state <= E;\n                count <= count + w;\n            end\n            E: begin\n                state <= B;\n                z <= (count == 2);\n                count <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule"]}
{"task_id": "vector4", "llmgen_RTL": ["module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n\tassign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule", "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule"]}
{"task_id": "m2014_q4k", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0000;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0000;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule"]}
{"task_id": "always_case2", "llmgen_RTL": ["module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b0001: pos = 2'd0;\n        4'b001?: pos = 2'd1;\n        4'b01??: pos = 2'd2;\n        4'b1???: pos = 2'd3;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n    always @(*) begin\n        casez(in)\n            4'b1???: pos = 2'd3;\n            4'b01??: pos = 2'd2;\n            4'b001?: pos = 2'd1;\n            4'b0001: pos = 2'd0;\n            default: pos = 2'd0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casex(in)\n        4'b1xxx: pos = 2'd3;\n        4'b01xx: pos = 2'd2;\n        4'b001x: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b???1: pos = 2'd0;\n        4'b??10: pos = 2'd1;\n        4'b?100: pos = 2'd2;\n        4'b1000: pos = 2'd3;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b???1: pos = 2'd0;\n        4'b??10: pos = 2'd1;\n        4'b?100: pos = 2'd2;\n        4'b1000: pos = 2'd3;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b???1: pos = 2'b00;\n        4'b??10: pos = 2'b01;\n        4'b?100: pos = 2'b10;\n        4'b1000: pos = 2'b11;\n        default: pos = 2'b00;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule"]}
{"task_id": "fsm2", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    assign out = (state == ON);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\n    reg state, next_state;\n    \n    parameter OFF = 1'b0, ON = 1'b1;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n        endcase\n    end\n    \n    assign out = (state == ON);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\n    reg state, next_state;\n    \n    parameter OFF = 1'b0, ON = 1'b1;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n    \n    assign out = (state == ON);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\n    reg out;\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON: next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    always @(*) begin\n        out = (state == ON);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\n    reg out;\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON: next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\n    reg state, next_state;\n    \n    parameter OFF = 1'b0, ON = 1'b1;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n    \n    assign out = (state == ON);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n        endcase\n    end\n\n    always @(*) begin\n        out = (state == ON);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\nreg state, next_state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= 1'b0;  // Reset to OFF state\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        1'b0:  // OFF state\n            next_state = j ? 1'b1 : 1'b0;\n        1'b1:  // ON state\n            next_state = k ? 1'b0 : 1'b1;\n    endcase\nend\n\nassign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    always @(*) begin\n        out = (state == ON);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\n    reg state, next_state;\n    \n    parameter OFF = 1'b0, ON = 1'b1;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n        endcase\n    end\n    \n    assign out = (state == ON);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\n    reg state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 1'b0;  // Reset to OFF state\n        else begin\n            case (state)\n                1'b0: state <= j ? 1'b1 : 1'b0;  // OFF state\n                1'b1: state <= k ? 1'b0 : 1'b1;  // ON state\n            endcase\n        end\n    end\n    \n    assign out = state;\n\nendmodule"]}
{"task_id": "m2014_q4i", "llmgen_RTL": ["module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\t\nendmodule", "module top_module(\n\toutput out);\n\n    assign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n    output out\n);\n\n    assign out = 1'b0;\n\nendmodule", "module top_module(\n    output out\n);\n\n    assign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n    output out\n);\n\n    assign out = 1'b0;\n\nendmodule", "module top_module(\n    output out\n);\n\n    assign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\n    assign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\nendmodule", "module top_module(\n\toutput out);\n\n\tassign out = 1'b0;\n\nendmodule"]}
{"task_id": "step_one", "llmgen_RTL": ["module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n\toutput one\n);\n\n\tassign one = 1'b1;\n\nendmodule", "module top_module(\n\toutput one\n);\n\n\tassign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n\toutput one\n);\n\n\tassign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n\toutput one\n);\n\n\tassign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n\toutput one\n);\n\n\tassign one = 1'b1;\n\nendmodule", "module top_module(\n\toutput one\n);\n\n\tassign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n\toutput one\n);\n\n\tassign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule", "module top_module(\n\toutput one\n);\n\n\tassign one = 1'b1;\n\nendmodule", "module top_module(\n    output one\n);\n\n    assign one = 1'b1;\n\nendmodule"]}
{"task_id": "vector100r", "llmgen_RTL": ["module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n\tinteger i;\n\talways @(*) begin\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tout[i] = in[99-i];\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n\tinteger i;\n\t\n\talways @(*) begin\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tout[i] = in[99-i];\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\ninteger i;\n\nalways @(*) begin\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99-i];\n    end\nend\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\ninteger i;\n\nalways @(*) begin\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99-i];\n    end\nend\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\ninteger i;\n\nalways @(*) begin\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99-i];\n    end\nend\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\ninteger i;\n\nalways @(*) begin\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99-i];\n    end\nend\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule"]}
{"task_id": "m2014_q4d", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    wire xor_out;\n\n    assign xor_out = in ^ out;\n\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    wire xor_out;\n\n    assign xor_out = in ^ out;\n\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    wire xor_out;\n\n    assign xor_out = in ^ out;\n\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    wire xor_out;\n\n    assign xor_out = in ^ out;\n\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    wire xor_out;\n\n    assign xor_out = in ^ out;\n\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    wire xor_out;\n\n    assign xor_out = in ^ out;\n\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    wire xor_out;\n\n    assign xor_out = in ^ out;\n\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    wire xor_out;\n\n    assign xor_out = in ^ out;\n\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule"]}
{"task_id": "shift4", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule"]}
{"task_id": "truthtable1", "llmgen_RTL": ["module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (x2 & ~x3) | (x1 & x3);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (x2 & ~x3) | (x1 & x3);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (x2 & ~x3) | (x1 & x3);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (x2 & ~x3) | (x1 & x3);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (x2 & ~x3) | (x1 & x3);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (x2 & ~x3) | (x1 & x3);\n\nendmodule", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\n    assign f = (x2 & ~x3) | (x1 & x3);\n\nendmodule"]}
{"task_id": "dff8ar", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tq <= 8'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"]}
{"task_id": "gates100", "llmgen_RTL": ["module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule"]}
{"task_id": "hadd", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\nassign sum = a ^ b;\nassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule"]}
{"task_id": "always_if2", "llmgen_RTL": ["module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty)\n            keep_driving = 1;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule"]}
{"task_id": "fsm2s", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= 1'b0;  // OFF state\n        else\n            case (state)\n                1'b0:   // OFF state\n                    if (j)\n                        state <= 1'b1;  // Transition to ON state\n                1'b1:   // ON state\n                    if (k)\n                        state <= 1'b0;  // Transition to OFF state\n            endcase\n    end\n    \n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0;\n\tparameter ON = 1'b1;\n\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0;\n\tparameter ON = 1'b1;\n\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: out = 1'b0;\n\t\t\tON: out = 1'b1;\n\t\t\tdefault: out = 1'b0;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    always @(*) begin\n        out = (state == ON);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0;\n\tparameter ON = 1'b1;\n\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: out = 1'b0;\n\t\t\tON: out = 1'b1;\n\t\t\tdefault: out = 1'b0;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON: next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    always @(*) begin\n        out = (state == ON);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0;\n\tparameter ON = 1'b1;\n\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= 1'b0;\n        else\n            case (state)\n                1'b0: state <= j ? 1'b1 : 1'b0;\n                1'b1: state <= k ? 1'b0 : 1'b1;\n            endcase\n    end\n\n    assign out = state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON:  next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n    parameter OFF = 1'b0;\n    parameter ON = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    always @(*) begin\n        out = (state == ON);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput reg out\n);\n\n\tparameter OFF = 1'b0;\n\tparameter ON = 1'b1;\n\n\treg state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tout = (state == ON);\n\tend\n\nendmodule"]}
{"task_id": "vector3", "llmgen_RTL": ["module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    wire [31:0] concatenated;\n    \n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule"]}
{"task_id": "circuit2", "llmgen_RTL": ["module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & c & ~d) | \n               (~a & b & d) | \n               (a & ~b & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & c & ~d) | \n               (~a & b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & c & ~d) | \n               (~a & b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & c & ~d) | \n               (~a & b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & c & ~d) | \n               (~a & b & d) | \n               (a & ~b & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule"]}
{"task_id": "andgate", "llmgen_RTL": ["module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\nassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\nassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n    assign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = a & b;\n\nendmodule", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\nassign out = a & b;\n\nendmodule"]}
{"task_id": "fsm1s", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    reg current_state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_B;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    assign out = (current_state == STATE_B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    assign out = (state == STATE_B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    assign out = (state == STATE_B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    reg current_state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_B;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    assign out = (current_state == STATE_B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    assign out = (state == STATE_B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    reg state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    assign out = (state == STATE_B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    reg current_state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_B;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    assign out = (current_state == STATE_B);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\n    reg state, next_state;\n    parameter A = 1'b0, B = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    assign out = (state == B);\n\nendmodule"]}
{"task_id": "fadd", "llmgen_RTL": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\t\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"]}
{"task_id": "m2014_q4g", "llmgen_RTL": ["module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\twire xnor_out;\n\n\tassign xnor_out = ~(in1 ^ in2);\n\tassign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\nwire xnor_out;\n\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    logic xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\nwire xnor_out;\n\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\n\nendmodule"]}
{"task_id": "ece241_2014_q3", "llmgen_RTL": ["module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? 1'b1 : d;\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c | d;\n    \n    assign mux_out = c ? 1'b1 : 1'b0;\n    assign mux_in[3] = d ? mux_out : 1'b1;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? c : 1'b1;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c;\n    assign mux_in[3] = d ? c : 1'b1;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? d : 1'b1;\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n    \n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? (d ? 1'b1 : 1'b1) : (d ? 1'b0 : 1'b1);\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c | d;\n    \n    assign mux_out = c ? 1'b1 : 1'b0;\n    assign mux_in[3] = d ? mux_out : 1'b1;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n    \n    assign mux_in[0] = d ? c : 1'b1;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c | d;\n    assign mux_in[3] = ~d;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n    \n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    mux2to1 mux_3 (\n        .sel(c),\n        .in0(1'b1),\n        .in1(d),\n        .out(mux_out)\n    );\n    \n    assign mux_in[3] = mux_out;\n\nendmodule\n\nmodule mux2to1 (\n    input sel,\n    input in0,\n    input in1,\n    output out\n);\n\n    assign out = sel ? in1 : in0;\n\nendmodule", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c | d;\n    assign mux_in[3] = ~d;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : c;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c | d;\n    assign mux_in[3] = ~d;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n\n    assign mux_out = c ? d : 1'b1;\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n    \n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? (d ? 1'b1 : 1'b1) : (d ? 1'b0 : 1'b1);\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? d : 1'b1;\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n    \n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? d : 1'b1;\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? d : 1'b1;\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c | d;\n    \n    assign mux_out = c ? 1'b1 : 1'b0;\n    assign mux_in[3] = d ? mux_out : 1'b1;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n    \n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? (d ? 1'b1 : 1'b1) : (d ? 1'b0 : 1'b1);\n    assign mux_in[3] = mux_out;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n    \n    assign mux_in[0] = d ? c : 1'b1;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c | d;\n    assign mux_in[3] = ~d;\n\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n    \n    assign mux_in[0] = c | d;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c & d;\n    \n    mux2to1 mux_3 (\n        .sel(c),\n        .in0(~d),\n        .in1(d),\n        .out(mux_out)\n    );\n    \n    assign mux_in[3] = mux_out;\n\nendmodule\n\nmodule mux2to1 (\n    input sel,\n    input in0,\n    input in1,\n    output out\n);\n    assign out = sel ? in1 : in0;\nendmodule", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\n    wire mux_out;\n\n    assign mux_in[0] = d ? 1'b1 : 1'b0;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c ? 1'b1 : 1'b0;\n    \n    assign mux_out = c ? 1'b1 : 1'b0;\n    assign mux_in[3] = d ? mux_out : 1'b1;\n\nendmodule"]}
{"task_id": "ece241_2014_q5b", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A & x) | (state == B & ~x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            case (state)\n                A: state <= x ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            case (state)\n                A: state <= x ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n    end\n\n    assign z = (state == A & x) | (state == B & ~x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            case (state)\n                A: state <= x ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    localparam STATE_A = 2'b01;\n    localparam STATE_B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = x ? STATE_B : STATE_A;\n            STATE_B: next_state = STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    assign z = (state == STATE_A && x) || (state == STATE_B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n\tlocalparam STATE_A = 2'b01;\n\tlocalparam STATE_B = 2'b10;\n\n\treg [1:0] state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= STATE_A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tSTATE_A: next_state = x ? STATE_B : STATE_A;\n\t\t\tSTATE_B: next_state = STATE_B;\n\t\t\tdefault: next_state = STATE_A;\n\t\tendcase\n\tend\n\n\tassign z = (state == STATE_A && x) || (state == STATE_B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            case (state)\n                A: state <= x ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n    end\n\n    assign z = (state == A && x) || (state == B && ~x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n    reg [1:0] state, next_state;\n    parameter A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule"]}
{"task_id": "circuit10", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state) ? (!a && b) || (a && !b) : (a || b);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a & b)\n            state <= 1'b1;\n        else if (~a & ~b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state & ~a & ~b) | (~state & ((~a & b) | (a & ~b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state == 1'b0) ? (a ^ b) : !(a ^ b);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && (a ^ b));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b && !state)\n            state <= 1'b1;\n        else if (!a && !b && state)\n            state <= 1'b0;\n    end\n    \n    assign q = (a ^ b) | state;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state_reg;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state_reg <= 1'b1;\n        else if (!a && !b)\n            state_reg <= 1'b0;\n    end\n    \n    assign state = state_reg;\n    assign q = (a ^ b) ^ state_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state <= 1'b1;\n        else if (!a && !b)\n            state <= 1'b0;\n    end\n    \n    assign q = (state && !a && !b) || (!state && ((a && !b) || (!a && b)));\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n    reg state_reg;\n    \n    always @(posedge clk) begin\n        if (a && b)\n            state_reg <= 1'b1;\n        else if (!a && !b)\n            state_reg <= 1'b0;\n    end\n    \n    assign state = state_reg;\n    assign q = (state_reg && !a && !b) || (!state_reg && ((a && !b) || (!a && b)));\n\nendmodule"]}
{"task_id": "2012_q1g", "llmgen_RTL": ["module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x[4:3])\n            2'b00: f = (x[2:1] == 2'b00) || (x[2:1] == 2'b10);\n            2'b01: f = 1'b0;\n            2'b11: f = ~(x[2:1] == 2'b10);\n            2'b10: f = ~(x[2:1] == 2'b11);\n            default: f = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x[4:3])\n            2'b00: f = (x[2:1] == 2'b00 || x[2:1] == 2'b10);\n            2'b01: f = 1'b0;\n            2'b11: f = (x[2:1] != 2'b10);\n            2'b10: f = (x[2:1] != 2'b11);\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | (~x[3] & ~x[4] & x[1]) | (x[3] & x[4] & ~x[1]) | (x[3] & ~x[2] & ~x[1]) | (~x[4] & x[3] & x[2]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x[4:3])\n            2'b00: f = (x[2:1] == 2'b00) || (x[2:1] == 2'b10);\n            2'b01: f = 1'b0;\n            2'b11: f = ~(x[2:1] == 2'b10);\n            2'b10: f = ~(x[2:1] == 2'b11);\n            default: f = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case(x[4:3])\n            2'b00: f = (x[2:1] == 2'b00) || (x[2:1] == 2'b10);\n            2'b01: f = 1'b0;\n            2'b11: f = ~(x[2:1] == 2'b10);\n            2'b10: f = ~(x[2:1] == 2'b11);\n            default: f = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x[4:3])\n            2'b00: f = (x[2:1] == 2'b00) || (x[2:1] == 2'b10);\n            2'b01: f = 1'b0;\n            2'b11: f = ~(x[2:1] == 2'b10);\n            2'b10: f = ~(x[2:1] == 2'b11);\n            default: f = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) |\n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x[4:3])\n            2'b00: f = (x[2:1] == 2'b00) || (x[2:1] == 2'b10);\n            2'b01: f = 1'b0;\n            2'b11: f = ~(x[2:1] == 2'b10);\n            2'b10: f = ~(x[2:1] == 2'b11);\n            default: f = 1'b0;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x[4:3])\n            2'b00: f = (x[2:1] == 2'b00) || (x[2:1] == 2'b10);\n            2'b01: f = 1'b0;\n            2'b11: f = ~(x[2:1] == 2'b10);\n            2'b10: f = ~(x[2:1] == 2'b11);\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    assign f = (~x[3] & ~x[4] & ~x[2]) | \n               (~x[3] & ~x[4] & x[1]) | \n               (x[3] & ~x[4]) | \n               (x[3] & x[4] & ~x[1]) | \n               (x[4] & ~x[2] & ~x[1]);\n\nendmodule", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n    always_comb begin\n        case (x[4:3])\n            2'b00: f = (x[2:1] == 2'b00) || (x[2:1] == 2'b10);\n            2'b01: f = 1'b0;\n            2'b11: f = ~(x[2:1] == 2'b10);\n            2'b10: f = ~(x[2:1] == 2'b11);\n        endcase\n    end\n\nendmodule"]}
{"task_id": "fsm_hdlc", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n\treg [3:0] state, next_state;\n\tparameter S0 = 4'd0, S1 = 4'd1, S2 = 4'd2, S3 = 4'd3, S4 = 4'd4, S5 = 4'd5, S6 = 4'd6, S7 = 4'd7;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: next_state = in ? S7 : S0;\n\t\t\tS7: next_state = in ? S7 : S0;\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tdisc <= 0;\n\t\t\tflag <= 0;\n\t\t\terr <= 0;\n\t\tend\n\t\telse begin\n\t\t\tdisc <= (state == S5) && !in;\n\t\t\tflag <= (state == S6) && !in;\n\t\t\terr <= (state == S7);\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset) state <= S0;\n        else state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S6 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            disc <= (state == S5) && !in;\n            flag <= (state == S6) && !in;\n            err <= (state == S6) && in;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n\tparameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n\treg [2:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset) state <= S0;\n\t\telse state <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: next_state = in ? S6 : S0;\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tdisc <= 0;\n\t\t\tflag <= 0;\n\t\t\terr <= 0;\n\t\tend else begin\n\t\t\tdisc <= (state == S5) && !in;\n\t\t\tflag <= (state == S6) && !in;\n\t\t\terr <= (state == S6) && in;\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S6 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            disc <= (state == S5) && !in;\n            flag <= (state == S6) && !in;\n            err <= (state == S6) && in;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err\n);\n\n\treg [3:0] state, next_state;\n\treg disc_r, flag_r, err_r;\n\t\n\tparameter S0 = 4'd0, S1 = 4'd1, S2 = 4'd2, S3 = 4'd3, S4 = 4'd4, S5 = 4'd5, S6 = 4'd6, S7 = 4'd7;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tdisc_r <= 1'b0;\n\t\t\tflag_r <= 1'b0;\n\t\t\terr_r <= 1'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tdisc_r <= (state == S5 && in == 1'b0);\n\t\t\tflag_r <= (state == S6 && in == 1'b0);\n\t\t\terr_r <= (state == S6 && in == 1'b1);\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: next_state = in ? S7 : S0;\n\t\t\tS7: next_state = in ? S7 : S0;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\n\tassign disc = disc_r;\n\tassign flag = flag_r;\n\tassign err = err_r;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S6 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end\n        else begin\n            disc <= (state == S5 && !in);\n            flag <= (state == S6 && !in);\n            err <= (state == S6 && in);\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err\n);\n\n    reg [3:0] state, next_state;\n    reg disc_r, flag_r, err_r;\n\n    parameter S0 = 4'd0, S1 = 4'd1, S2 = 4'd2, S3 = 4'd3, S4 = 4'd4, S5 = 4'd5, S6 = 4'd6, S7 = 4'd7;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            disc_r <= 0;\n            flag_r <= 0;\n            err_r <= 0;\n        end else begin\n            state <= next_state;\n            disc_r <= (state == S5 && in == 0);\n            flag_r <= (state == S6 && in == 0);\n            err_r <= (state == S6 && in == 1);\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = S7;\n            default: next_state = S0;\n        endcase\n    end\n\n    assign disc = disc_r;\n    assign flag = flag_r;\n    assign err = err_r;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset) state <= S0;\n        else state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S6 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            disc <= (state == S5 && !in);\n            flag <= (state == S6 && !in);\n            err <= (state == S6 && in);\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S6 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            disc <= (state == S5) && !in;\n            flag <= (state == S6) && !in;\n            err <= (state == S6) && in;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err\n);\n\n\tparameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n\t\n\treg [2:0] state, next_state;\n\treg disc_r, flag_r, err_r;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdisc_r = 1'b0;\n\t\tflag_r = 1'b0;\n\t\terr_r = 1'b0;\n\t\t\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = S6;\n\t\t\t\t\tdisc_r = 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tflag_r = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS6: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = S6;\n\t\t\t\t\terr_r = 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tflag_r = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\tassign disc = disc_r;\n\tassign flag = flag_r;\n\tassign err = err_r;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n\treg [2:0] state, next_state;\n\tparameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: next_state = in ? S6 : S0;\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tdisc <= (state == S5 && !in);\n\t\tflag <= (state == S6 && !in);\n\t\terr <= (state == S6 && in);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n\tparameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n\treg [2:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = S0;\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: next_state = in ? S6 : S0;\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tdisc <= 0;\n\t\t\tflag <= 0;\n\t\t\terr <= 0;\n\t\tend else begin\n\t\t\tdisc <= (state == S5) && !in;\n\t\t\tflag <= (state == S6) && !in;\n\t\t\terr <= (state == S6) && in;\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset) state <= S0;\n        else state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S6 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            disc <= (state == S5) && !in;\n            flag <= (state == S6) && !in;\n            err <= (state == S6) && in;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n\treg [3:0] state, next_state;\n\tparameter S0 = 4'd0, S1 = 4'd1, S2 = 4'd2, S3 = 4'd3, S4 = 4'd4, S5 = 4'd5, S6 = 4'd6, S7 = 4'd7;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = S0;\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: next_state = in ? S7 : S0;\n\t\t\tS7: next_state = in ? S7 : S0;\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tdisc <= 0;\n\t\t\tflag <= 0;\n\t\t\terr <= 0;\n\t\tend\n\t\telse begin\n\t\t\tdisc <= (state == S5 && !in);\n\t\t\tflag <= (state == S6 && !in);\n\t\t\terr <= (state == S7);\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S6 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            disc <= (state == S5 && !in);\n            flag <= (state == S6 && !in);\n            err <= (state == S6 && in);\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    reg [3:0] state, next_state;\n    parameter S0 = 4'd0, S1 = 4'd1, S2 = 4'd2, S3 = 4'd3, S4 = 4'd4, S5 = 4'd5, S6 = 4'd6, S7 = 4'd7;\n\n    always @(posedge clk) begin\n        if (reset) state <= S0;\n        else state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = S0;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S7 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            disc <= (state == S5) && !in;\n            flag <= (state == S6) && !in;\n            err <= (state == S7);\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    \n    reg [2:0] state, next_state;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    always @(*) begin\n        next_state = state;\n        disc = 1'b0;\n        flag = 1'b0;\n        err = 1'b0;\n        \n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: begin\n                next_state = in ? S6 : S0;\n                disc = ~in;\n            end\n            S6: begin\n                if (in) begin\n                    next_state = S6;\n                    err = 1'b1;\n                end else begin\n                    next_state = S0;\n                    flag = 1'b1;\n                end\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n\tparameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n\treg [2:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: next_state = in ? S6 : S0;\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tdisc <= 0;\n\t\t\tflag <= 0;\n\t\t\terr <= 0;\n\t\tend else begin\n\t\t\tdisc <= (state == S5) && !in;\n\t\t\tflag <= (state == S6) && !in;\n\t\t\terr <= (state == S6) && in;\n\t\tend\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n    reg [3:0] state, next_state;\n    \n    localparam S0 = 4'd0,\n               S1 = 4'd1,\n               S2 = 4'd2,\n               S3 = 4'd3,\n               S4 = 4'd4,\n               S5 = 4'd5,\n               S6 = 4'd6,\n               S7 = 4'd7;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S7 : S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end\n        else begin\n            disc <= (state == S5) && !in;\n            flag <= (state == S6) && !in;\n            err <= (state == S7);\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput reg disc,\n\toutput reg flag,\n\toutput reg err\n);\n\n\tparameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n\treg [2:0] state, next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset) state <= S0;\n\t\telse state <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tnext_state = S0;\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: next_state = in ? S6 : S0;\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tdisc <= 0;\n\t\t\tflag <= 0;\n\t\t\terr <= 0;\n\t\tend else begin\n\t\t\tdisc <= (state == S5) && !in;\n\t\t\tflag <= (state == S6) && !in;\n\t\t\terr <= (state == S6) && in;\n\t\tend\n\tend\n\nendmodule"]}
{"task_id": "review2015_fancytimer", "llmgen_RTL": ["module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    localparam IDLE = 3'd0, DETECT = 3'd1, READ_DELAY = 3'd2, COUNT = 3'd3, FINISH = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] pattern, delay;\n    reg [3:0] delay_counter;\n    reg [9:0] cycle_counter;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            delay_counter <= 4'b0000;\n            cycle_counter <= 10'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: pattern <= {pattern[2:0], data};\n                DETECT: pattern <= {pattern[2:0], data};\n                READ_DELAY: delay <= {delay[2:0], data};\n                COUNT: begin\n                    if (cycle_counter == 10'd999) begin\n                        cycle_counter <= 10'b0;\n                        if (delay_counter == 4'b0) begin\n                            counting <= 1'b0;\n                        end else begin\n                            delay_counter <= delay_counter - 1'b1;\n                        end\n                    end else begin\n                        cycle_counter <= cycle_counter + 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (pattern == 4'b1101) next_state = DETECT;\n            DETECT: next_state = READ_DELAY;\n            READ_DELAY: begin\n                if (delay_counter == 4'b0011) begin\n                    next_state = COUNT;\n                    delay_counter = delay;\n                    counting = 1'b1;\n                end else begin\n                    delay_counter = delay_counter + 1'b1;\n                end\n            end\n            COUNT: if (delay_counter == 4'b0 && cycle_counter == 10'd999) next_state = FINISH;\n            FINISH: if (ack) next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (state == FINISH) done <= 1'b1;\n        else if (ack) done <= 1'b0;\n    end\n\n    assign count = (state == COUNT) ? delay_counter : 4'bxxxx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] state;\n    reg [3:0] delay;\n    reg [3:0] pattern;\n    reg [13:0] timer;\n    reg [3:0] remaining;\n\n    parameter IDLE = 4'd0, READ_PATTERN = 4'd1, READ_DELAY = 4'd2, COUNT = 4'd3, FINISH = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0;\n            delay <= 4'b0;\n            timer <= 14'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            remaining <= 4'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) state <= READ_DELAY;\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:1]) state <= COUNT;\n                end\n                COUNT: begin\n                    if (timer == 14'd0) begin\n                        timer <= (delay + 1'b1) * 1000 - 1'b1;\n                        counting <= 1'b1;\n                        remaining <= delay;\n                    end else if (timer == 14'd999) begin\n                        timer <= timer - 1'b1;\n                        remaining <= remaining - 1'b1;\n                    end else if (timer == 14'd1) begin\n                        timer <= timer - 1'b1;\n                        state <= FINISH;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end else begin\n                        timer <= timer - 1'b1;\n                    end\n                end\n                FINISH: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                        pattern <= 4'b0;\n                    end\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? remaining : 4'bx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] delay;\n    reg [3:0] current_count;\n    reg [11:0] cycle_counter;\n    reg [3:0] shift_reg;\n    reg [2:0] state;\n    \n    localparam IDLE = 3'd0,\n               DETECT = 3'd1,\n               SHIFT = 3'd2,\n               COUNT = 3'd3,\n               FINISH = 3'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            counting <= 0;\n            done <= 0;\n            shift_reg <= 4'b0000;\n            delay <= 4'b0000;\n            current_count <= 4'b0000;\n            cycle_counter <= 12'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    shift_reg <= {shift_reg[2:0], data};\n                end\n                DETECT: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= SHIFT;\n                        delay <= 4'b0000;\n                    end\n                end\n                SHIFT: begin\n                    delay <= {delay[2:0], data};\n                    if (&cycle_counter[1:0]) begin\n                        state <= COUNT;\n                        counting <= 1;\n                        current_count <= delay;\n                        cycle_counter <= 12'd0;\n                    end else begin\n                        cycle_counter <= cycle_counter + 1;\n                    end\n                end\n                COUNT: begin\n                    if (cycle_counter == 12'd999) begin\n                        cycle_counter <= 12'd0;\n                        if (current_count == 4'd0) begin\n                            state <= FINISH;\n                            counting <= 0;\n                            done <= 1;\n                        end else begin\n                            current_count <= current_count - 1;\n                        end\n                    end else begin\n                        cycle_counter <= cycle_counter + 1;\n                    end\n                end\n                FINISH: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? current_count : 4'bxxxx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] delay;\n    reg [3:0] pattern;\n    reg [11:0] counter;\n    reg [3:0] state;\n    reg [3:0] remaining_time;\n\n    parameter IDLE = 4'd0, DETECT = 4'd1, READ_DELAY = 4'd2, COUNT = 4'd3, FINISH = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            counter <= 12'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            remaining_time <= 4'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    pattern <= 4'b0000;\n                    counting <= 1'b0;\n                    done <= 1'b0;\n                end\n                DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) state <= READ_DELAY;\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[2:0]) state <= COUNT;\n                end\n                COUNT: begin\n                    if (counter == 12'd0) begin\n                        counter <= 12'd999;\n                        if (remaining_time == 4'd0) begin\n                            state <= FINISH;\n                            counting <= 1'b0;\n                        end else begin\n                            remaining_time <= remaining_time - 1'b1;\n                        end\n                    end else begin\n                        counter <= counter - 1'b1;\n                    end\n                end\n                FINISH: begin\n                    done <= 1'b1;\n                    if (ack) state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counting <= 1'b0;\n        end else if (state == READ_DELAY && &delay[2:0]) begin\n            counting <= 1'b1;\n            remaining_time <= delay;\n        end\n    end\n\n    assign count = (state == COUNT) ? remaining_time : 4'bxxxx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    parameter IDLE = 3'd0, DETECT = 3'd1, READ_DELAY = 3'd2, COUNTING = 3'd3, FINISHED = 3'd4;\n    \n    reg [2:0] state, next_state;\n    reg [3:0] pattern, delay;\n    reg [3:0] delay_count;\n    reg [9:0] cycle_count;\n    reg [3:0] bit_count;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0;\n            delay <= 4'b0;\n            delay_count <= 4'b0;\n            cycle_count <= 10'b0;\n            bit_count <= 4'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            \n            case (state)\n                IDLE: begin\n                    pattern <= {pattern[2:0], data};\n                end\n                \n                DETECT: begin\n                    if (bit_count < 4) begin\n                        delay <= {delay[2:0], data};\n                        bit_count <= bit_count + 1'b1;\n                    end\n                end\n                \n                COUNTING: begin\n                    if (cycle_count == 10'd999) begin\n                        cycle_count <= 10'd0;\n                        if (delay_count == 4'd0) begin\n                            counting <= 1'b0;\n                        end else begin\n                            delay_count <= delay_count - 1'b1;\n                        end\n                    end else begin\n                        cycle_count <= cycle_count + 1'b1;\n                    end\n                end\n                \n                FINISHED: begin\n                    if (ack) begin\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    always @(*) begin\n        next_state = state;\n        \n        case (state)\n            IDLE: begin\n                if (pattern == 4'b1101) next_state = DETECT;\n            end\n            \n            DETECT: begin\n                if (bit_count == 4'd4) begin\n                    next_state = COUNTING;\n                    counting = 1'b1;\n                end\n            end\n            \n            COUNTING: begin\n                if (delay_count == 4'd0 && cycle_count == 10'd999) begin\n                    next_state = FINISHED;\n                    done = 1'b1;\n                end\n            end\n            \n            FINISHED: begin\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n    \n    assign count = (state == COUNTING) ? delay_count : 4'bx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    localparam IDLE = 3'd0, DETECT = 3'd1, DELAY = 3'd2, COUNT = 3'd3, FINISH = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] pattern, delay;\n    reg [3:0] delay_count;\n    reg [9:0] cycle_count;\n    reg [3:0] remaining_time;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            delay_count <= 4'b0000;\n            cycle_count <= 10'b0;\n            remaining_time <= 4'b0000;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: pattern <= {pattern[2:0], data};\n                DETECT: delay <= {delay[2:0], data};\n                COUNT: begin\n                    if (cycle_count == 10'd999) begin\n                        cycle_count <= 10'b0;\n                        if (delay_count < delay) begin\n                            delay_count <= delay_count + 1'b1;\n                            remaining_time <= remaining_time - 1'b1;\n                        end\n                    end else begin\n                        cycle_count <= cycle_count + 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (pattern == 4'b1101) next_state = DETECT;\n            DETECT: if (delay_count == 4'd3) next_state = DELAY;\n            DELAY: next_state = COUNT;\n            COUNT: if ((delay_count == delay) && (cycle_count == 10'd999)) next_state = FINISH;\n            FINISH: if (ack) next_state = IDLE;\n        endcase\n    end\n\n    always @(*) begin\n        counting = (state == COUNT);\n        done = (state == FINISH);\n    end\n\n    assign count = (state == COUNT) ? remaining_time : 4'bxxxx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    parameter IDLE = 3'd0, DETECT = 3'd1, SHIFT = 3'd2, LOAD = 3'd3, COUNT = 3'd4, FINISH = 3'd5;\n    reg [2:0] state, next_state;\n    reg [3:0] pattern, delay;\n    reg [3:0] counter;\n    reg [13:0] timer;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            counter <= 4'b0000;\n            timer <= 14'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: pattern <= {pattern[2:0], data};\n                DETECT: pattern <= {pattern[2:0], data};\n                SHIFT: delay <= {delay[2:0], data};\n                LOAD: begin\n                    counter <= delay;\n                    timer <= (delay + 1) * 1000;\n                end\n                COUNT: begin\n                    if (timer > 0) begin\n                        timer <= timer - 1;\n                        if (timer % 1000 == 0) counter <= counter - 1;\n                    end\n                end\n                FINISH: if (ack) done <= 1'b0;\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (pattern == 4'b1101) next_state = DETECT;\n            DETECT: next_state = SHIFT;\n            SHIFT: if (delay[3]) next_state = LOAD;\n            LOAD: next_state = COUNT;\n            COUNT: if (timer == 0) next_state = FINISH;\n            FINISH: if (ack) next_state = IDLE;\n        endcase\n    end\n\n    always @(*) begin\n        counting = (state == COUNT);\n        done = (state == FINISH);\n    end\n\n    assign count = (state == COUNT) ? counter : 4'bxxxx;\n\nendmodule", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    reg [3:0] state;\n    reg [3:0] delay;\n    reg [3:0] pattern;\n    reg [19:0] counter;\n    reg [3:0] remaining_time;\n\n    parameter IDLE = 4'd0, DETECT = 4'd1, DELAY_INPUT = 4'd2, COUNT = 4'd3, NOTIFY = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            counting <= 0;\n            done <= 0;\n            counter <= 20'd0;\n            remaining_time <= 4'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    pattern <= 4'b0000;\n                end\n                DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) state <= DELAY_INPUT;\n                end\n                DELAY_INPUT: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:1]) state <= COUNT;\n                end\n                COUNT: begin\n                    if (counter == 0) begin\n                        counting <= 1;\n                        counter <= (delay + 1) * 1000 - 1;\n                        remaining_time <= delay;\n                    end else if (counter % 1000 == 0) begin\n                        remaining_time <= remaining_time - 1;\n                    end\n                    \n                    if (counter == 1) begin\n                        state <= NOTIFY;\n                        counting <= 0;\n                        done <= 1;\n                    end else begin\n                        counter <= counter - 1;\n                    end\n                end\n                NOTIFY: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? remaining_time : 4'bxxxx;\n\nendmodule", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    reg [3:0] state;\n    reg [3:0] pattern;\n    reg [3:0] delay;\n    reg [3:0] counter;\n    reg [13:0] timer;\n\n    parameter IDLE = 4'd0, DETECT = 4'd1, DELAY_READ = 4'd2, COUNT = 4'd3, FINISHED = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            counter <= 4'b0000;\n            timer <= 14'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    pattern <= 4'b0000;\n                end\n                DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        state <= DELAY_READ;\n                        delay <= 4'b0000;\n                        counter <= 4'b0000;\n                    end\n                end\n                DELAY_READ: begin\n                    delay <= {delay[2:0], data};\n                    counter <= counter + 1'b1;\n                    if (counter == 4'b0011) begin\n                        state <= COUNT;\n                        timer <= (delay + 1'b1) * 1000;\n                        counting <= 1'b1;\n                    end\n                end\n                COUNT: begin\n                    if (timer > 0) begin\n                        timer <= timer - 1'b1;\n                    end else begin\n                        state <= FINISHED;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                FINISHED: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? (timer - 1) / 1000 : 4'bxxxx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] state;\n    reg [3:0] delay;\n    reg [3:0] pattern;\n    reg [11:0] counter;\n    reg [3:0] remaining_time;\n\n    parameter IDLE = 4'd0, DETECT = 4'd1, READ_DELAY = 4'd2, COUNTING = 4'd3, FINISHED = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0;\n            delay <= 4'b0;\n            counting <= 0;\n            done <= 0;\n            counter <= 12'd0;\n            remaining_time <= 4'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    pattern <= 4'b0;\n                end\n                DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        state <= READ_DELAY;\n                        delay <= 4'b0;\n                    end\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:1]) begin\n                        state <= COUNTING;\n                        counting <= 1;\n                        counter <= 12'd0;\n                        remaining_time <= delay;\n                    end\n                end\n                COUNTING: begin\n                    counter <= counter + 1;\n                    if (counter == 12'd999) begin\n                        counter <= 12'd0;\n                        if (remaining_time == 4'd0) begin\n                            state <= FINISHED;\n                            counting <= 0;\n                            done <= 1;\n                        end else begin\n                            remaining_time <= remaining_time - 1;\n                        end\n                    end\n                end\n                FINISHED: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (state == COUNTING) ? remaining_time : 4'bx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] delay;\n    reg [3:0] current_count;\n    reg [11:0] cycle_count;\n    reg [3:0] shift_reg;\n    reg [2:0] state;\n    \n    localparam SEARCH = 3'd0, READ_DELAY = 3'd1, COUNT = 3'd2, NOTIFY = 3'd3;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            state <= SEARCH;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            current_count <= 4'b0;\n            cycle_count <= 12'b0;\n        end else begin\n            case (state)\n                SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= READ_DELAY;\n                        delay <= 4'b0;\n                    end\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (&cycle_count[1:0]) begin\n                        state <= COUNT;\n                        counting <= 1'b1;\n                        current_count <= delay;\n                        cycle_count <= 12'd999;\n                    end else begin\n                        cycle_count <= cycle_count + 1'b1;\n                    end\n                end\n                COUNT: begin\n                    if (cycle_count == 12'd0) begin\n                        if (current_count == 4'd0) begin\n                            state <= NOTIFY;\n                            counting <= 1'b0;\n                            done <= 1'b1;\n                        end else begin\n                            current_count <= current_count - 1'b1;\n                            cycle_count <= 12'd999;\n                        end\n                    end else begin\n                        cycle_count <= cycle_count - 1'b1;\n                    end\n                end\n                NOTIFY: begin\n                    if (ack) begin\n                        state <= SEARCH;\n                        shift_reg <= 4'b0;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    assign count = (state == COUNT) ? current_count : 4'bx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] state;\n    reg [3:0] delay;\n    reg [3:0] pattern;\n    reg [11:0] counter;\n    reg [3:0] remaining_time;\n\n    parameter IDLE = 4'd0, DETECT = 4'd1, READ_DELAY = 4'd2, COUNT = 4'd3, FINISHED = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            counting <= 0;\n            done <= 0;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            counter <= 12'd0;\n            remaining_time <= 4'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    pattern <= 4'b0000;\n                end\n                DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) state <= READ_DELAY;\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:1]) begin\n                        state <= COUNT;\n                        counting <= 1;\n                        counter <= 12'd0;\n                        remaining_time <= delay;\n                    end\n                end\n                COUNT: begin\n                    if (counter == 12'd999) begin\n                        counter <= 12'd0;\n                        if (remaining_time == 4'd0) begin\n                            state <= FINISHED;\n                            counting <= 0;\n                            done <= 1;\n                        end else begin\n                            remaining_time <= remaining_time - 1;\n                        end\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end\n                FINISHED: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? remaining_time : 4'bxxxx;\n\nendmodule", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    reg [3:0] state;\n    reg [3:0] delay;\n    reg [3:0] pattern;\n    reg [19:0] counter;\n    reg [3:0] remaining_time;\n\n    localparam IDLE = 4'd0, DETECT = 4'd1, READ_DELAY = 4'd2, COUNT = 4'd3, FINISHED = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            counting <= 1'b0;\n            done <= 1'b0;\n            counter <= 20'd0;\n            remaining_time <= 4'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    pattern <= 4'b0000;\n                end\n                DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) state <= READ_DELAY;\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:1]) begin\n                        state <= COUNT;\n                        counting <= 1'b1;\n                        counter <= (delay + 1) * 1000;\n                        remaining_time <= delay;\n                    end\n                end\n                COUNT: begin\n                    if (counter > 0) begin\n                        counter <= counter - 1;\n                        if (counter % 1000 == 1) remaining_time <= remaining_time - 1;\n                    end else begin\n                        state <= FINISHED;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                FINISHED: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? remaining_time : 4'bxxxx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] state;\n    reg [3:0] delay;\n    reg [3:0] pattern;\n    reg [19:0] timer;\n    reg [3:0] remaining_time;\n\n    localparam IDLE = 4'd0, DETECT = 4'd1, READ_DELAY = 4'd2, COUNT = 4'd3, FINISH = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            timer <= 20'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            remaining_time <= 4'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    pattern <= 4'b0000;\n                end\n                DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        state <= READ_DELAY;\n                        delay <= 4'b0000;\n                    end\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:1]) begin\n                        state <= COUNT;\n                        timer <= 20'd0;\n                        counting <= 1'b1;\n                        remaining_time <= delay;\n                    end\n                end\n                COUNT: begin\n                    if (timer == ((delay + 1) * 1000) - 1) begin\n                        state <= FINISH;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end else begin\n                        timer <= timer + 1;\n                        if (timer[9:0] == 10'd999) begin\n                            remaining_time <= remaining_time - 1;\n                        end\n                    end\n                end\n                FINISH: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                    end\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? remaining_time : 4'bxxxx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] state;\n    reg [3:0] delay;\n    reg [3:0] shift_reg;\n    reg [13:0] counter;\n    reg [3:0] remaining_time;\n\n    localparam IDLE = 4'd0,\n               DETECT = 4'd1,\n               SHIFT = 4'd2,\n               COUNT = 4'd3,\n               NOTIFY = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            delay <= 4'd0;\n            shift_reg <= 4'd0;\n            counter <= 14'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            remaining_time <= 4'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    shift_reg <= {shift_reg[2:0], data};\n                end\n                DETECT: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= SHIFT;\n                        delay <= 4'd0;\n                    end\n                end\n                SHIFT: begin\n                    delay <= {delay[2:0], data};\n                    if (&counter[1:0]) begin\n                        state <= COUNT;\n                        counter <= 14'd0;\n                        counting <= 1'b1;\n                        remaining_time <= delay;\n                    end else begin\n                        counter <= counter + 1'b1;\n                    end\n                end\n                COUNT: begin\n                    if (counter == ((delay + 1'b1) * 1000) - 1) begin\n                        state <= NOTIFY;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end else begin\n                        counter <= counter + 1'b1;\n                        if (counter[9:0] == 10'd999) begin\n                            remaining_time <= remaining_time - 1'b1;\n                        end\n                    end\n                end\n                NOTIFY: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = remaining_time;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    localparam IDLE = 3'd0, DETECT = 3'd1, DELAY_READ = 3'd2, COUNT = 3'd3, DONE = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] pattern, delay;\n    reg [3:0] delay_count;\n    reg [9:0] cycle_count;\n    reg [3:0] remaining_time;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0;\n            delay <= 4'b0;\n            delay_count <= 4'b0;\n            cycle_count <= 10'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: pattern <= {pattern[2:0], data};\n                DETECT: pattern <= {pattern[2:0], data};\n                DELAY_READ: begin\n                    delay <= {delay[2:0], data};\n                    delay_count <= delay_count + 1'b1;\n                end\n                COUNT: begin\n                    if (cycle_count == 10'd999) begin\n                        cycle_count <= 10'd0;\n                        if (remaining_time > 4'd0)\n                            remaining_time <= remaining_time - 1'b1;\n                    end else\n                        cycle_count <= cycle_count + 1'b1;\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (pattern == 4'b1101) next_state = DETECT;\n            DETECT: if (pattern == 4'b1101) next_state = DELAY_READ;\n            DELAY_READ: if (delay_count == 4'd3) next_state = COUNT;\n            COUNT: if (remaining_time == 4'd0 && cycle_count == 10'd999) next_state = DONE;\n            DONE: if (ack) next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (next_state)\n                COUNT: counting <= 1'b1;\n                DONE: begin\n                    counting <= 1'b0;\n                    done <= 1'b1;\n                end\n                IDLE: done <= 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (reset)\n            remaining_time <= 4'd0;\n        else if (state == DELAY_READ && delay_count == 4'd3)\n            remaining_time <= delay + 1'b1;\n    end\n\n    assign count = (state == COUNT) ? remaining_time : 4'bx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] state;\n    reg [3:0] delay;\n    reg [3:0] pattern;\n    reg [13:0] counter;\n    reg [3:0] count_reg;\n\n    localparam IDLE = 4'd0, DETECT = 4'd1, READ_DELAY = 4'd2, COUNT = 4'd3, FINISHED = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            delay <= 4'd0;\n            pattern <= 4'd0;\n            counter <= 14'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            count_reg <= 4'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    state <= DETECT;\n                    pattern <= {pattern[2:0], data};\n                end\n                DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        state <= READ_DELAY;\n                        delay <= 4'd0;\n                    end\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (&counter[1:0]) begin\n                        state <= COUNT;\n                        counter <= 14'd0;\n                        counting <= 1'b1;\n                        count_reg <= delay;\n                    end\n                    counter <= counter + 1'b1;\n                end\n                COUNT: begin\n                    if (counter == 14'd999) begin\n                        counter <= 14'd0;\n                        if (count_reg == 4'd0) begin\n                            state <= FINISHED;\n                            counting <= 1'b0;\n                            done <= 1'b1;\n                        end else begin\n                            count_reg <= count_reg - 1'b1;\n                        end\n                    end else begin\n                        counter <= counter + 1'b1;\n                    end\n                end\n                FINISHED: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                        pattern <= 4'd0;\n                    end\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? count_reg : 4'bx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    localparam [2:0] SEARCH = 3'd0,\n                     READ_DELAY = 3'd1,\n                     COUNT = 3'd2,\n                     NOTIFY = 3'd3;\n\n    reg [2:0] state, next_state;\n    reg [3:0] delay, delay_counter;\n    reg [3:0] pattern;\n    reg [9:0] cycle_counter;\n    reg [3:0] bit_counter;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= SEARCH;\n            pattern <= 4'b0;\n            delay <= 4'b0;\n            bit_counter <= 4'b0;\n            cycle_counter <= 10'b0;\n            delay_counter <= 4'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                SEARCH: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        bit_counter <= 4'd4;\n                    end\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    bit_counter <= bit_counter - 1'b1;\n                end\n                COUNT: begin\n                    if (cycle_counter == 10'd999) begin\n                        cycle_counter <= 10'd0;\n                        if (delay_counter == 4'd0) begin\n                            counting <= 1'b0;\n                        end else begin\n                            delay_counter <= delay_counter - 1'b1;\n                        end\n                    end else begin\n                        cycle_counter <= cycle_counter + 1'b1;\n                    end\n                end\n                NOTIFY: begin\n                    done <= 1'b1;\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            SEARCH: begin\n                if (pattern == 4'b1101) next_state = READ_DELAY;\n            end\n            READ_DELAY: begin\n                if (bit_counter == 4'd0) begin\n                    next_state = COUNT;\n                    counting = 1'b1;\n                end\n            end\n            COUNT: begin\n                if (delay_counter == 4'd0 && cycle_counter == 10'd999) next_state = NOTIFY;\n            end\n            NOTIFY: begin\n                if (ack) begin\n                    next_state = SEARCH;\n                    done = 1'b0;\n                end\n            end\n        endcase\n    end\n\n    assign count = (state == COUNT) ? delay_counter : 4'bx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    localparam IDLE = 3'd0, DETECT = 3'd1, DELAY = 3'd2, COUNT = 3'd3, FINISHED = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] pattern, delay;\n    reg [3:0] counter;\n    reg [13:0] cycle_counter;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            delay <= 4'b0000;\n            counter <= 4'b0000;\n            cycle_counter <= 14'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: pattern <= {pattern[2:0], data};\n                DETECT: delay <= {delay[2:0], data};\n                COUNT: begin\n                    if (cycle_counter == 14'd999) begin\n                        cycle_counter <= 14'd0;\n                        if (counter > 4'd0) counter <= counter - 4'd1;\n                    end else begin\n                        cycle_counter <= cycle_counter + 14'd1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (pattern == 4'b1101) next_state = DETECT;\n            DETECT: if (counter == 4'd3) next_state = COUNT;\n            COUNT: if (counter == 4'd0 && cycle_counter == 14'd999) next_state = FINISHED;\n            FINISHED: if (ack) next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                COUNT: counting <= 1'b1;\n                FINISHED: begin\n                    counting <= 1'b0;\n                    done <= 1'b1;\n                end\n                IDLE: done <= 1'b0;\n            endcase\n        end\n    end\n\n    assign count = (state == COUNT) ? counter : 4'bx;\n\nendmodule", "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    localparam [2:0] IDLE = 3'd0,\n                     DETECT = 3'd1,\n                     READ_DELAY = 3'd2,\n                     COUNT = 3'd3,\n                     FINISHED = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [3:0] pattern, delay;\n    reg [3:0] delay_count;\n    reg [9:0] cycle_count;\n    \n    assign count = (state == COUNT) ? delay_count : 4'bx;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0;\n            delay <= 4'b0;\n            delay_count <= 4'b0;\n            cycle_count <= 10'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            \n            case (state)\n                IDLE, DETECT: begin\n                    pattern <= {pattern[2:0], data};\n                end\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                end\n                COUNT: begin\n                    if (cycle_count == 10'd999) begin\n                        cycle_count <= 10'd0;\n                        if (delay_count > 4'd0)\n                            delay_count <= delay_count - 4'd1;\n                    end else begin\n                        cycle_count <= cycle_count + 10'd1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (pattern == 4'b1101)\n                    next_state = READ_DELAY;\n            end\n            DETECT: begin\n                if (pattern == 4'b1101)\n                    next_state = READ_DELAY;\n            end\n            READ_DELAY: begin\n                if (delay_count == 4'd3)\n                    next_state = COUNT;\n                delay_count = delay_count + 4'd1;\n            end\n            COUNT: begin\n                counting = 1'b1;\n                if (delay_count == 4'd0 && cycle_count == 10'd999)\n                    next_state = FINISHED;\n            end\n            FINISHED: begin\n                done = 1'b1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"]}
{"task_id": "ece241_2013_q4", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\nreg [3:1] prev_s;\nreg [2:0] state;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 3'b000;\n        prev_s <= 3'b000;\n        fr3 <= 1;\n        fr2 <= 1;\n        fr1 <= 1;\n        dfr <= 1;\n    end else begin\n        prev_s <= s;\n        case (s)\n            3'b000: begin\n                state <= 3'b000;\n                fr3 <= 1;\n                fr2 <= 1;\n                fr1 <= 1;\n                dfr <= (prev_s > s) ? 1 : dfr;\n            end\n            3'b001: begin\n                state <= 3'b001;\n                fr3 <= 0;\n                fr2 <= 1;\n                fr1 <= 1;\n                dfr <= (prev_s > s) ? 1 : dfr;\n            end\n            3'b011: begin\n                state <= 3'b011;\n                fr3 <= 0;\n                fr2 <= 0;\n                fr1 <= 1;\n                dfr <= (prev_s > s) ? 1 : dfr;\n            end\n            3'b111: begin\n                state <= 3'b111;\n                fr3 <= 0;\n                fr2 <= 0;\n                fr1 <= 0;\n                dfr <= 0;\n            end\n            default: begin\n                state <= state;\n                fr3 <= fr3;\n                fr2 <= fr2;\n                fr1 <= fr1;\n                dfr <= dfr;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg rising;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n            prev_s <= 3'b000;\n            rising <= 0;\n        end else begin\n            prev_s <= s;\n            \n            if (s > prev_s) \n                rising <= 1;\n            else if (s < prev_s)\n                rising <= 0;\n\n            case (s)\n                3'b111: begin // Above s[3]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin // Between s[3] and s[2]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= rising;\n                end\n                3'b001: begin // Between s[2] and s[1]\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= rising;\n                end\n                3'b000: begin // Below s[1]\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin // Invalid state\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin // Above s[3]\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin // Between s[3] and s[2]\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin // Between s[2] and s[1]\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin // Below s[1]\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin // Invalid state\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\nreg [3:1] prev_s;\nreg [2:0] state;\n\nparameter ABOVE_S3 = 3'b000;\nparameter BETWEEN_S3_S2 = 3'b001;\nparameter BETWEEN_S2_S1 = 3'b010;\nparameter BELOW_S1 = 3'b011;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= BELOW_S1;\n        prev_s <= 3'b000;\n        fr3 <= 1;\n        fr2 <= 1;\n        fr1 <= 1;\n        dfr <= 1;\n    end else begin\n        prev_s <= s;\n        case (s)\n            3'b111: state <= ABOVE_S3;\n            3'b011: state <= BETWEEN_S3_S2;\n            3'b001: state <= BETWEEN_S2_S1;\n            3'b000: state <= BELOW_S1;\n            default: state <= state;\n        endcase\n\n        case (state)\n            ABOVE_S3: begin\n                fr3 <= 0;\n                fr2 <= 0;\n                fr1 <= 0;\n                dfr <= 0;\n            end\n            BETWEEN_S3_S2: begin\n                fr3 <= 0;\n                fr2 <= 0;\n                fr1 <= 1;\n                dfr <= (prev_s < s);\n            end\n            BETWEEN_S2_S1: begin\n                fr3 <= 0;\n                fr2 <= 1;\n                fr1 <= 1;\n                dfr <= (prev_s < s);\n            end\n            BELOW_S1: begin\n                fr3 <= 1;\n                fr2 <= 1;\n                fr1 <= 1;\n                dfr <= 1;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin // Above s[3]\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin // Between s[3] and s[2]\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin // Between s[2] and s[1]\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin // Below s[1]\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin // Invalid state, maintain previous state\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1'b1;\n            fr2 <= 1'b1;\n            fr1 <= 1'b1;\n            dfr <= 1'b1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b0;\n                    dfr <= 1'b0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b1;\n                    dfr <= (prev_s < s) ? 1'b1 : 1'b0;\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= (prev_s < s) ? 1'b1 : 1'b0;\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            case (state)\n                3'b000: begin // Below s[1]\n                    if (s[1]) state <= 3'b001;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin // Between s[2] and s[1]\n                    if (!s[1]) state <= 3'b000;\n                    else if (s[2]) state <= 3'b010;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b010: begin // Between s[3] and s[2]\n                    if (!s[2]) state <= 3'b001;\n                    else if (s[3]) state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b011: begin // Above s[3]\n                    if (!s[3]) state <= 3'b010;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                default: state <= 3'b000;\n            endcase\n            prev_s <= s;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1'b1;\n            fr2 <= 1'b1;\n            fr1 <= 1'b1;\n            dfr <= 1'b1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin\n                    state <= 3'b111;\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b0;\n                    dfr <= 1'b0;\n                end\n                3'b011: begin\n                    state <= 3'b011;\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin\n                    state <= 3'b001;\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin\n                    state <= 3'b000;\n                    fr3 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b1;\n                end\n                default: begin\n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [2:0] state, next_state;\n    reg [3:1] prev_s;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n        end else begin\n            state <= next_state;\n            prev_s <= s;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        fr3 = 1'b0;\n        fr2 = 1'b0;\n        fr1 = 1'b0;\n        dfr = 1'b0;\n\n        case (s)\n            3'b000: begin // Below s[1]\n                next_state = 3'b000;\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = 1'b1;\n            end\n            3'b001: begin // Between s[2] and s[1]\n                next_state = 3'b001;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = (prev_s == 3'b000);\n            end\n            3'b011: begin // Between s[3] and s[2]\n                next_state = 3'b011;\n                fr1 = 1'b1;\n                dfr = (prev_s == 3'b001 || prev_s == 3'b000);\n            end\n            3'b111: begin // Above s[3]\n                next_state = 3'b111;\n            end\n            default: next_state = state;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\nreg [3:1] prev_s;\nreg [2:0] state;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= 3'b000;\n        prev_s <= 3'b000;\n        fr3 <= 1'b1;\n        fr2 <= 1'b1;\n        fr1 <= 1'b1;\n        dfr <= 1'b1;\n    end else begin\n        prev_s <= s;\n        case (s)\n            3'b111: begin\n                state <= 3'b111;\n                fr3 <= 1'b0;\n                fr2 <= 1'b0;\n                fr1 <= 1'b0;\n                dfr <= 1'b0;\n            end\n            3'b011: begin\n                state <= 3'b011;\n                fr3 <= 1'b0;\n                fr2 <= 1'b0;\n                fr1 <= 1'b1;\n                dfr <= (prev_s < s);\n            end\n            3'b001: begin\n                state <= 3'b001;\n                fr3 <= 1'b0;\n                fr2 <= 1'b1;\n                fr1 <= 1'b1;\n                dfr <= (prev_s < s);\n            end\n            3'b000: begin\n                state <= 3'b000;\n                fr3 <= 1'b1;\n                fr2 <= 1'b1;\n                fr1 <= 1'b1;\n                dfr <= 1'b1;\n            end\n            default: begin\n                state <= state;\n                fr3 <= fr3;\n                fr2 <= fr2;\n                fr1 <= fr1;\n                dfr <= dfr;\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n    reg [3:1] prev_s;\n    reg [2:0] state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n            prev_s <= 3'b000;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            prev_s <= s;\n            case (s)\n                3'b111: begin \n                    state <= 3'b111;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin \n                    state <= 3'b011;\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b001: begin \n                    state <= 3'b001;\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s < s);\n                end\n                3'b000: begin \n                    state <= 3'b000;\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin \n                    state <= state;\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule"]}
{"task_id": "fsm_serial", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'b000;\n\tlocalparam START = 3'b001;\n\tlocalparam DATA = 3'b010;\n\tlocalparam STOP = 3'b011;\n\tlocalparam ERROR = 3'b100;\n\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA)\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\telse\n\t\t\t\tbit_count <= 0;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 0;\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (!in)\n\t\t\t\t\tnext_state = START;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA;\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 4'b0111)\n\t\t\t\t\tnext_state = STOP;\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend else\n\t\t\t\t\tnext_state = ERROR;\n\t\t\tend\n\t\t\tERROR: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0;\n\tlocalparam START = 3'd1;\n\tlocalparam DATA = 3'd2;\n\tlocalparam STOP = 3'd3;\n\tlocalparam ERROR = 3'd4;\n\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA)\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\telse\n\t\t\t\tbit_count <= 0;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 1'b0;\n\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (~in) next_state = START;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA;\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 4'd7) begin\n\t\t\t\t\tif (in) next_state = STOP;\n\t\t\t\t\telse next_state = ERROR;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tdone = 1'b1;\n\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tERROR: begin\n\t\t\t\tif (in) next_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    localparam IDLE = 3'd0;\n    localparam START = 3'd1;\n    localparam DATA = 3'd2;\n    localparam STOP = 3'd3;\n    localparam ERROR = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 0;\n\n        case (state)\n            IDLE: begin\n                if (!in)\n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA;\n            end\n            DATA: begin\n                if (bit_count == 4'd7)\n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in) begin\n                    next_state = IDLE;\n                    done = 1;\n                end else\n                    next_state = ERROR;\n            end\n            ERROR: begin\n                if (in)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output done\n);\n\n    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    \n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n    \n    always @(posedge clk) begin\n        if (reset)\n            bit_count <= 0;\n        else if (state == DATA)\n            bit_count <= bit_count + 1;\n        else\n            bit_count <= 0;\n    end\n    \n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in == 0) ? START : IDLE;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 4'd7) ? STOP : DATA;\n            STOP: next_state = (in == 1) ? IDLE : ERROR;\n            ERROR: next_state = (in == 1) ? IDLE : ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    assign done = (state == STOP) && (in == 1);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 0;\n        case (state)\n            IDLE: if (~in) next_state = START;\n            START: next_state = DATA;\n            DATA: begin\n                if (bit_count == 7) begin\n                    if (in) next_state = STOP;\n                    else next_state = ERROR;\n                end\n            end\n            STOP: begin\n                done = 1;\n                next_state = IDLE;\n            end\n            ERROR: if (in) next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    localparam IDLE = 3'd0;\n    localparam START = 3'd1;\n    localparam DATA = 3'd2;\n    localparam STOP = 3'd3;\n    localparam ERROR = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 4'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 4'd0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (!in) next_state = START;\n            end\n            START: begin\n                next_state = DATA;\n            end\n            DATA: begin\n                if (bit_count == 4'd7) begin\n                    if (in) next_state = STOP;\n                    else next_state = ERROR;\n                end\n            end\n            STOP: begin\n                done = 1'b1;\n                next_state = IDLE;\n            end\n            ERROR: begin\n                if (in) next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    localparam IDLE = 3'd0;\n    localparam START = 3'd1;\n    localparam DATA = 3'd2;\n    localparam STOP = 3'd3;\n    localparam ERROR = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 4'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 4'd0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (!in) next_state = START;\n            end\n            START: begin\n                next_state = DATA;\n            end\n            DATA: begin\n                if (bit_count == 4'd7) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                if (in) begin\n                    next_state = IDLE;\n                    done = 1'b1;\n                end else begin\n                    next_state = ERROR;\n                end\n            end\n            ERROR: begin\n                if (in) next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n\n    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    \n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 4'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 4'd0;\n        end\n    end\n    \n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (!in) next_state = START;\n            START: next_state = DATA;\n            DATA: if (bit_count == 4'd7) next_state = STOP;\n            STOP: next_state = in ? IDLE : ERROR;\n            ERROR: if (in) next_state = IDLE;\n        endcase\n    end\n    \n    assign done = (state == STOP) && in;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n\tparameter IDLE = 3'd0;\n\tparameter START = 3'd1;\n\tparameter DATA = 3'd2;\n\tparameter STOP = 3'd3;\n\tparameter ERROR = 3'd4;\n\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 4'd0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA)\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\telse\n\t\t\t\tbit_count <= 4'd0;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 1'b0;\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in == 1'b0)\n\t\t\t\t\tnext_state = START;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA;\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 4'd7)\n\t\t\t\t\tnext_state = STOP;\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\t\tdone = 1'b1;\n\t\t\t\tend else\n\t\t\t\t\tnext_state = ERROR;\n\t\t\tend\n\t\t\tERROR: begin\n\t\t\t\tif (in == 1'b1)\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    reg [3:0] state, next_state;\n    reg [3:0] bit_count;\n\n    localparam IDLE = 4'd0,\n               START = 4'd1,\n               DATA = 4'd2,\n               STOP = 4'd3,\n               ERROR = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (~in) next_state = START;\n            end\n            START: begin\n                next_state = DATA;\n            end\n            DATA: begin\n                if (bit_count == 4'd7) next_state = STOP;\n            end\n            STOP: begin\n                if (in) begin\n                    next_state = IDLE;\n                    done = 1'b1;\n                end else begin\n                    next_state = ERROR;\n                end\n            end\n            ERROR: begin\n                if (in) next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0;\n\tlocalparam START = 3'd1;\n\tlocalparam DATA = 3'd2;\n\tlocalparam STOP = 3'd3;\n\tlocalparam ERROR = 3'd4;\n\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA)\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\telse\n\t\t\t\tbit_count <= 0;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 1'b0;\n\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (!in) next_state = START;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA;\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 4'd7) begin\n\t\t\t\t\tif (in) next_state = STOP;\n\t\t\t\t\telse next_state = ERROR;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tdone = 1'b1;\n\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tERROR: begin\n\t\t\t\tif (in) next_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0,\n\t\t\t   START = 3'd1,\n\t\t\t   DATA = 3'd2,\n\t\t\t   STOP = 3'd3,\n\t\t\t   ERROR = 3'd4;\n\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA)\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\telse\n\t\t\t\tbit_count <= 0;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 1'b0;\n\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (~in) next_state = START;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA;\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 4'd7) begin\n\t\t\t\t\tnext_state = STOP;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tdone = 1'b1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = ERROR;\n\t\t\t\tend\n\t\t\tend\n\t\t\tERROR: begin\n\t\t\t\tif (in) next_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 0;\n        case (state)\n            IDLE: if (~in) next_state = START;\n            START: next_state = DATA;\n            DATA: begin\n                if (bit_count == 4'd7) begin\n                    if (in) next_state = STOP;\n                    else next_state = ERROR;\n                end\n            end\n            STOP: begin\n                if (in) begin\n                    next_state = IDLE;\n                    done = 1;\n                end else begin\n                    next_state = ERROR;\n                end\n            end\n            ERROR: if (in) next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    localparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 0;\n        case (state)\n            IDLE: begin\n                if (~in) next_state = START;\n            end\n            START: begin\n                next_state = DATA;\n            end\n            DATA: begin\n                if (bit_count == 7)\n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in) begin\n                    next_state = IDLE;\n                    done = 1;\n                end else begin\n                    next_state = ERROR;\n                end\n            end\n            ERROR: begin\n                if (in) next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0;\n\tlocalparam START = 3'd1;\n\tlocalparam DATA = 3'd2;\n\tlocalparam STOP = 3'd3;\n\tlocalparam ERROR = 3'd4;\n\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA)\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\telse\n\t\t\t\tbit_count <= 0;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 1'b0;\n\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (~in) next_state = START;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA;\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 4'd7) begin\n\t\t\t\t\tif (in) next_state = STOP;\n\t\t\t\t\telse next_state = ERROR;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tdone = 1'b1;\n\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tERROR: begin\n\t\t\t\tif (in) next_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n\n    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    \n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 4'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 4'd0;\n        end\n    end\n    \n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (!in) next_state = START;\n            START: next_state = DATA;\n            DATA: if (bit_count == 4'd7) next_state = STOP;\n            STOP: next_state = in ? IDLE : ERROR;\n            ERROR: if (in) next_state = IDLE;\n        endcase\n    end\n    \n    assign done = (state == STOP) && in;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n\n    localparam IDLE = 3'd0;\n    localparam START = 3'd1;\n    localparam DATA = 3'd2;\n    localparam STOP = 3'd3;\n    localparam ERROR = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n    reg done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 4'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 4'd0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done_reg = 1'b0;\n        case (state)\n            IDLE: if (!in) next_state = START;\n            START: next_state = DATA;\n            DATA: begin\n                if (bit_count == 4'd7) begin\n                    if (in) next_state = STOP;\n                    else next_state = ERROR;\n                end\n            end\n            STOP: begin\n                done_reg = 1'b1;\n                if (in) next_state = IDLE;\n                else next_state = START;\n            end\n            ERROR: if (in) next_state = IDLE;\n        endcase\n    end\n\n    assign done = done_reg;\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    reg [3:0] state;\n    reg [3:0] bit_count;\n    \n    localparam IDLE = 4'd0,\n               START = 4'd1,\n               DATA = 4'd2,\n               STOP = 4'd3,\n               ERROR = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (!in) state <= START;\n                end\n                START: begin\n                    state <= DATA;\n                    bit_count <= 0;\n                end\n                DATA: begin\n                    if (bit_count == 7) begin\n                        state <= STOP;\n                    end else begin\n                        bit_count <= bit_count + 1;\n                    end\n                end\n                STOP: begin\n                    if (in) begin\n                        state <= IDLE;\n                        done <= 1;\n                    end else begin\n                        state <= ERROR;\n                    end\n                end\n                ERROR: begin\n                    if (in) state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 0;\n        case (state)\n            IDLE: begin\n                if (~in) next_state = START;\n            end\n            START: begin\n                next_state = DATA;\n            end\n            DATA: begin\n                if (bit_count == 4'd7) begin\n                    if (in) next_state = STOP;\n                    else next_state = ERROR;\n                end\n            end\n            STOP: begin\n                done = 1;\n                if (in) next_state = IDLE;\n                else next_state = START;\n            end\n            ERROR: begin\n                if (in) next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg done\n);\n\n    localparam IDLE = 3'd0,\n               START = 3'd1,\n               DATA = 3'd2,\n               STOP = 3'd3,\n               ERROR = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done = 0;\n\n        case (state)\n            IDLE: begin\n                if (!in) next_state = START;\n            end\n            START: begin\n                next_state = DATA;\n            end\n            DATA: begin\n                if (bit_count == 4'd7) begin\n                    if (in) next_state = STOP;\n                    else next_state = ERROR;\n                end\n            end\n            STOP: begin\n                done = 1;\n                next_state = IDLE;\n            end\n            ERROR: begin\n                if (in) next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"]}
{"task_id": "fsm_serialdata", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\nreg [3:0] state;\nreg [3:0] bit_count;\nreg [7:0] shift_reg;\n\nparameter IDLE = 4'd0, START = 4'd1, DATA = 4'd2, STOP = 4'd3, ERROR = 4'd4;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n        bit_count <= 0;\n        shift_reg <= 8'b0;\n        out_byte <= 8'b0;\n        done <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                done <= 0;\n                if (in == 0) begin\n                    state <= START;\n                    bit_count <= 0;\n                end\n            end\n            START: begin\n                state <= DATA;\n                bit_count <= 0;\n                shift_reg <= 8'b0;\n            end\n            DATA: begin\n                shift_reg <= {in, shift_reg[7:1]};\n                bit_count <= bit_count + 1;\n                if (bit_count == 7) begin\n                    state <= STOP;\n                end\n            end\n            STOP: begin\n                if (in == 1) begin\n                    state <= IDLE;\n                    out_byte <= shift_reg;\n                    done <= 1;\n                end else begin\n                    state <= ERROR;\n                end\n            end\n            ERROR: begin\n                if (in == 1) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0,\n\t\t\t   START = 3'd1,\n\t\t\t   DATA = 3'd2,\n\t\t\t   STOP = 3'd3,\n\t\t\t   ERROR = 3'd4;\n\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 8'b0;\n\t\t\tout_byte <= 8'b0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA) begin\n\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\tend else begin\n\t\t\t\tbit_count <= 0;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tdone = 1'b0;\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (!in) next_state = START;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA;\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 4'd7) next_state = STOP;\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\t\tdone = 1'b1;\n\t\t\t\t\tout_byte = shift_reg;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = ERROR;\n\t\t\t\tend\n\t\t\tend\n\t\t\tERROR: begin\n\t\t\t\tif (in) next_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 8'b0;\n\t\t\tdone <= 0;\n\t\t\tout_byte <= 8'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tDATA: begin\n\t\t\t\t\tif (bit_count < 8) begin\n\t\t\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tout_byte <= shift_reg;\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\t\tdone <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: if (!in) next_state = START;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: if (bit_count == 8) next_state = STOP;\n\t\t\tSTOP: next_state = in ? IDLE : ERROR;\n\t\t\tERROR: if (in) next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 8'b0;\n\t\t\tout_byte <= 8'b0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tDATA: begin\n\t\t\t\t\tif (bit_count < 8) begin\n\t\t\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tout_byte <= shift_reg;\n\t\t\t\t\t\tdone <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\t\tdone <= 1'b0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: if (!in) next_state = START;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: if (bit_count == 8) next_state = STOP;\n\t\t\tSTOP: next_state = in ? IDLE : ERROR;\n\t\t\tERROR: if (in) next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 8'b0;\n\t\t\tout_byte <= 8'b0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA) begin\n\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\tend\n\t\t\tif (next_state == STOP && in == 1) begin\n\t\t\t\tout_byte <= shift_reg;\n\t\t\t\tdone <= 1;\n\t\t\tend else begin\n\t\t\t\tdone <= 0;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: next_state = (in == 0) ? START : IDLE;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: next_state = (bit_count == 7) ? STOP : DATA;\n\t\t\tSTOP: next_state = (in == 1) ? IDLE : ERROR;\n\t\t\tERROR: next_state = (in == 1) ? IDLE : ERROR;\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 0;\n\t\t\tout_byte <= 0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tDATA: begin\n\t\t\t\t\tif (bit_count < 8) begin\n\t\t\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tout_byte <= shift_reg;\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\t\tdone <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: if (!in) next_state = START;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: if (bit_count == 8) next_state = STOP;\n\t\t\tSTOP: next_state = in ? IDLE : ERROR;\n\t\t\tERROR: if (in) next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    localparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n    reg [7:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_byte <= 8'd0;\n            done <= 1'b0;\n            bit_count <= 4'd0;\n            shift_reg <= 8'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA) begin\n                shift_reg <= {in, shift_reg[7:1]};\n                bit_count <= bit_count + 1;\n            end\n            if (state == STOP && in == 1'b1) begin\n                out_byte <= shift_reg;\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in == 1'b0) ? START : IDLE;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 4'd7) ? STOP : DATA;\n            STOP: next_state = (in == 1'b1) ? IDLE : ERROR;\n            ERROR: next_state = (in == 1'b1) ? IDLE : ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [2:0] bit_count;\n    reg [7:0] shift_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            out_byte <= 8'd0;\n            done <= 1'b0;\n            bit_count <= 3'd0;\n            shift_reg <= 8'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA) begin\n                shift_reg <= {in, shift_reg[7:1]};\n                bit_count <= bit_count + 1;\n            end\n            if (next_state == STOP && in == 1'b1) begin\n                out_byte <= shift_reg;\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in == 1'b0) ? START : IDLE;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;\n            STOP: next_state = (in == 1'b1) ? IDLE : ERROR;\n            ERROR: next_state = (in == 1'b1) ? IDLE : ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    reg [3:0] state;\n    reg [3:0] bit_count;\n    reg [7:0] shift_reg;\n\n    localparam IDLE = 4'd0,\n               START = 4'd1,\n               DATA = 4'd2,\n               STOP = 4'd3,\n               ERROR = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            shift_reg <= 8'b0;\n            out_byte <= 8'b0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (in == 0) state <= START;\n                end\n                START: begin\n                    bit_count <= 0;\n                    shift_reg <= 8'b0;\n                    state <= DATA;\n                end\n                DATA: begin\n                    shift_reg <= {in, shift_reg[7:1]};\n                    bit_count <= bit_count + 1;\n                    if (bit_count == 4'd7) state <= STOP;\n                end\n                STOP: begin\n                    if (in == 1) begin\n                        out_byte <= shift_reg;\n                        done <= 1;\n                        state <= IDLE;\n                    end else begin\n                        state <= ERROR;\n                    end\n                end\n                ERROR: begin\n                    if (in == 1) state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    reg [3:0] state;\n    reg [3:0] bit_count;\n    reg [7:0] shift_reg;\n\n    localparam IDLE = 4'd0,\n               START = 4'd1,\n               DATA = 4'd2,\n               STOP = 4'd3,\n               ERROR = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            shift_reg <= 8'b0;\n            out_byte <= 8'b0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (!in) state <= START;\n                end\n                START: begin\n                    bit_count <= 0;\n                    shift_reg <= 8'b0;\n                    state <= DATA;\n                end\n                DATA: begin\n                    shift_reg <= {in, shift_reg[7:1]};\n                    bit_count <= bit_count + 1;\n                    if (bit_count == 4'd7) state <= STOP;\n                end\n                STOP: begin\n                    if (in) begin\n                        state <= IDLE;\n                        out_byte <= shift_reg;\n                        done <= 1;\n                    end else begin\n                        state <= ERROR;\n                    end\n                end\n                ERROR: begin\n                    if (in) state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 8'b0;\n\t\t\tout_byte <= 8'b0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tDATA: begin\n\t\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tout_byte <= shift_reg;\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\t\tdone <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: next_state = (in == 0) ? START : IDLE;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: next_state = (bit_count == 7) ? STOP : DATA;\n\t\t\tSTOP: next_state = (in == 1) ? IDLE : ERROR;\n\t\t\tERROR: next_state = (in == 1) ? IDLE : ERROR;\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    reg [3:0] state;\n    reg [3:0] bit_count;\n    reg [7:0] shift_reg;\n\n    localparam IDLE = 4'd0, START = 4'd1, DATA = 4'd2, STOP = 4'd3, ERROR = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            shift_reg <= 0;\n            out_byte <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (!in) state <= START;\n                end\n                START: begin\n                    bit_count <= 0;\n                    shift_reg <= 0;\n                    state <= DATA;\n                end\n                DATA: begin\n                    shift_reg <= {in, shift_reg[7:1]};\n                    bit_count <= bit_count + 1;\n                    if (bit_count == 7) state <= STOP;\n                end\n                STOP: begin\n                    if (in) begin\n                        state <= IDLE;\n                        out_byte <= shift_reg;\n                        done <= 1;\n                    end else begin\n                        state <= ERROR;\n                    end\n                end\n                ERROR: begin\n                    if (in) state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    localparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n    reg [7:0] shift_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            shift_reg <= 8'b0;\n            out_byte <= 8'b0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA) begin\n                shift_reg <= {in, shift_reg[7:1]};\n                bit_count <= bit_count + 1;\n            end\n            if (next_state == STOP && in == 1) begin\n                out_byte <= shift_reg;\n                done <= 1;\n            end else begin\n                done <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in == 0) ? START : IDLE;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 7) ? STOP : DATA;\n            STOP: next_state = (in == 1) ? IDLE : ERROR;\n            ERROR: next_state = (in == 1) ? IDLE : ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\nreg [3:0] state;\nreg [3:0] bit_count;\nreg [7:0] shift_reg;\n\nparameter IDLE = 4'd0, START = 4'd1, DATA = 4'd2, STOP = 4'd3, ERROR = 4'd4;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n        bit_count <= 0;\n        shift_reg <= 8'b0;\n        out_byte <= 8'b0;\n        done <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                done <= 0;\n                if (in == 0) begin\n                    state <= START;\n                end\n            end\n            START: begin\n                state <= DATA;\n                bit_count <= 0;\n                shift_reg <= 8'b0;\n            end\n            DATA: begin\n                shift_reg <= {in, shift_reg[7:1]};\n                bit_count <= bit_count + 1;\n                if (bit_count == 7) begin\n                    state <= STOP;\n                end\n            end\n            STOP: begin\n                if (in == 1) begin\n                    state <= IDLE;\n                    out_byte <= shift_reg;\n                    done <= 1;\n                end else begin\n                    state <= ERROR;\n                end\n            end\n            ERROR: begin\n                if (in == 1) begin\n                    state <= IDLE;\n                    done <= 1;\n                end\n            end\n            default: state <= IDLE;\n        endcase\n    end\nend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n    reg [7:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n            out_byte <= 8'b0;\n            bit_count <= 0;\n            shift_reg <= 8'b0;\n        end else begin\n            state <= next_state;\n            if (state == DATA) begin\n                shift_reg <= {in, shift_reg[7:1]};\n                bit_count <= bit_count + 1;\n            end\n            if (next_state == STOP && in == 1) begin\n                done <= 1;\n                out_byte <= shift_reg;\n            end else begin\n                done <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in == 0) ? START : IDLE;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 4'd7) ? STOP : DATA;\n            STOP: next_state = (in == 1) ? IDLE : ERROR;\n            ERROR: next_state = (in == 1) ? IDLE : ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 0;\n\t\t\tout_byte <= 0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tDATA: begin\n\t\t\t\t\tif (bit_count < 8) begin\n\t\t\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tout_byte <= shift_reg;\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\t\tdone <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: if (~in) next_state = START;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: if (bit_count == 8) next_state = STOP;\n\t\t\tSTOP: next_state = in ? IDLE : ERROR;\n\t\t\tERROR: if (in) next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    reg [3:0] state;\n    reg [3:0] bit_count;\n    reg [7:0] shift_reg;\n\n    localparam IDLE = 4'd0, START = 4'd1, DATA = 4'd2, STOP = 4'd3, ERROR = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            shift_reg <= 8'b0;\n            done <= 0;\n            out_byte <= 8'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (in == 0) begin\n                        state <= START;\n                    end\n                end\n                START: begin\n                    state <= DATA;\n                    bit_count <= 0;\n                    shift_reg <= 8'b0;\n                end\n                DATA: begin\n                    shift_reg <= {in, shift_reg[7:1]};\n                    bit_count <= bit_count + 1;\n                    if (bit_count == 7) begin\n                        state <= STOP;\n                    end\n                end\n                STOP: begin\n                    if (in == 1) begin\n                        state <= IDLE;\n                        done <= 1;\n                        out_byte <= shift_reg;\n                    end else begin\n                        state <= ERROR;\n                    end\n                end\n                ERROR: begin\n                    if (in == 1) begin\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 8'b0;\n\t\t\tdone <= 0;\n\t\t\tout_byte <= 8'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tDATA: begin\n\t\t\t\t\tif (bit_count < 8) begin\n\t\t\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tout_byte <= shift_reg;\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\t\tdone <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: if (!in) next_state = START;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: if (bit_count == 8) next_state = STOP;\n\t\t\tSTOP: next_state = in ? IDLE : ERROR;\n\t\t\tERROR: if (in) next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n    localparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n    reg [2:0] state, next_state;\n    reg [2:0] bit_count;\n    reg [7:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_byte <= 8'd0;\n            done <= 1'b0;\n            bit_count <= 3'd0;\n            shift_reg <= 8'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA) begin\n                shift_reg <= {in, shift_reg[7:1]};\n                bit_count <= bit_count + 1'b1;\n            end\n            if (state == STOP && in == 1'b1) begin\n                out_byte <= shift_reg;\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in == 1'b0) ? START : IDLE;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;\n            STOP: next_state = (in == 1'b1) ? IDLE : ERROR;\n            ERROR: next_state = (in == 1'b1) ? IDLE : ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\tlocalparam IDLE = 3'd0, START = 3'd1, DATA = 3'd2, STOP = 3'd3, ERROR = 3'd4;\n\treg [2:0] state, next_state;\n\treg [3:0] bit_count;\n\treg [7:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 8'b0;\n\t\t\tdone <= 0;\n\t\t\tout_byte <= 8'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tDATA: begin\n\t\t\t\t\tif (bit_count < 8) begin\n\t\t\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tout_byte <= shift_reg;\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\t\tdone <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: if (!in) next_state = START;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: if (bit_count == 8) next_state = STOP;\n\t\t\tSTOP: next_state = in ? IDLE : ERROR;\n\t\t\tERROR: if (in) next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule"]}
{"task_id": "gshare", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b01;\n        end else begin\n            if (train_valid && train_mispredicted)\n                global_history <= {train_history[5:0], train_taken};\n            else if (predict_valid)\n                global_history <= {global_history[5:0], predict_taken};\n                \n            if (train_valid) begin\n                case (pht[train_index])\n                    2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken) begin\n                    pht[train_index] <= (pht[train_index] == 2'b11) ? 2'b11 : pht[train_index] + 1;\n                end else begin\n                    pht[train_index] <= (pht[train_index] == 2'b00) ? 2'b00 : pht[train_index] - 1;\n                end\n                \n                if (train_mispredicted) begin\n                    global_history <= {train_history[5:0], train_taken};\n                end else if (predict_valid) begin\n                    global_history <= {global_history[5:0], predict_taken};\n                end\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    \n    wire [6:0] predict_index = predict_pc ^ global_history;\n    wire [6:0] train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n                \n                if (train_mispredicted)\n                    global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    \n    wire [6:0] predict_index = predict_pc ^ predict_history;\n    wire [6:0] train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken) begin\n                    pht[train_index] <= (pht[train_index] == 2'b11) ? 2'b11 : pht[train_index] + 1;\n                end else begin\n                    pht[train_index] <= (pht[train_index] == 2'b00) ? 2'b00 : pht[train_index] - 1;\n                end\n                \n                if (train_mispredicted) begin\n                    global_history <= {train_history[5:0], train_taken};\n                end\n            end\n            \n            if (predict_valid && !train_mispredicted) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n\n    wire [6:0] predict_index = predict_pc ^ predict_history;\n    wire [6:0] train_index = train_pc ^ train_history;\n\n    assign predict_history = global_history;\n    assign predict_taken = pht[predict_index][1];\n\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n\n                if (train_mispredicted)\n                    global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n                \n                if (train_mispredicted)\n                    global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    assign predict_history = global_history;\n    assign predict_taken = pht[predict_index][1];\n\n    integer i;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid && train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n\n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n\n    wire [6:0] predict_index = predict_pc ^ predict_history;\n    wire [6:0] train_index = train_pc ^ train_history;\n\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (integer i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid && train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n\n            if (train_valid) begin\n                case (pht[train_index])\n                    2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    reg [1:0] predict_counter, train_counter;\n\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    assign predict_taken = predict_counter[1];\n    assign predict_history = global_history;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid && train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n\n            if (train_valid) begin\n                if (train_taken && train_counter != 2'b11)\n                    pht[train_index] <= train_counter + 1;\n                else if (!train_taken && train_counter != 2'b00)\n                    pht[train_index] <= train_counter - 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        predict_counter = pht[predict_index];\n        train_counter = pht[train_index];\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [6:0] global_history;\n    reg [1:0] pht [127:0];\n    wire [6:0] predict_index, train_index;\n    reg [1:0] predict_counter, train_counter;\n\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    assign predict_taken = predict_counter[1];\n    assign predict_history = global_history;\n\n    integer i;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid && train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n\n            if (train_valid) begin\n                if (train_taken && train_counter != 2'b11)\n                    pht[train_index] <= train_counter + 1;\n                else if (!train_taken && train_counter != 2'b00)\n                    pht[train_index] <= train_counter - 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        predict_counter = pht[predict_index];\n        train_counter = pht[train_index];\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken) begin\n                    pht[train_index] <= (pht[train_index] == 2'b11) ? 2'b11 : pht[train_index] + 1;\n                end else begin\n                    pht[train_index] <= (pht[train_index] == 2'b00) ? 2'b00 : pht[train_index] - 1;\n                end\n                \n                if (train_mispredicted) begin\n                    global_history <= {train_history[5:0], train_taken};\n                end\n            end\n            \n            if (predict_valid && !train_mispredicted) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid && train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid && !train_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n            \n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    \n    wire [6:0] predict_index = predict_pc ^ predict_history;\n    wire [6:0] train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n                \n                if (train_mispredicted)\n                    global_history <= {train_history[5:0], train_taken};\n            end\n            else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    assign predict_history = global_history;\n    assign predict_taken = pht[predict_index][1];\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (integer i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b01;\n        end else begin\n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n\n                if (train_mispredicted)\n                    global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n                \n                if (train_mispredicted)\n                    global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid && train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n            \n            if (train_valid) begin\n                case (pht[train_index])\n                    2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (integer i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b01;\n        end\n        else begin\n            if (train_valid && train_mispredicted)\n                global_history <= {train_history[5:0], train_taken};\n            else if (predict_valid)\n                global_history <= {global_history[5:0], predict_taken};\n\n            if (train_valid) begin\n                case (pht[train_index])\n                    2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    \n    wire [6:0] predict_index = predict_pc ^ predict_history;\n    wire [6:0] train_index = train_pc ^ train_history;\n    \n    assign predict_history = global_history;\n    assign predict_taken = pht[predict_index][1];\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_taken) begin\n                    pht[train_index] <= (pht[train_index] == 2'b11) ? 2'b11 : pht[train_index] + 1;\n                end else begin\n                    pht[train_index] <= (pht[train_index] == 2'b00) ? 2'b00 : pht[train_index] - 1;\n                end\n                \n                if (train_mispredicted) begin\n                    global_history <= {train_history[5:0], train_taken};\n                end else if (predict_valid) begin\n                    global_history <= {global_history[5:0], predict_taken};\n                end\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid && train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n            \n            if (train_valid) begin\n                case (pht[train_index])\n                    2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n    wire [6:0] predict_index, train_index;\n    \n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n    \n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n    \n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid && train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else if (predict_valid && !train_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n            \n            if (train_valid) begin\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;\n            end\n        end\n    end\n\nendmodule"]}
{"task_id": "lemmings4", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg [4:0] fall_counter;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL) begin\n                if (fall_counter < 20)\n                    fall_counter <= fall_counter + 1;\n            end else begin\n                fall_counter <= 0;\n            end\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == LEFT) ? 0 : 1;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = FALL;\n                    else\n                        next_state = direction ? RIGHT : LEFT;\n                end\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b110;\n    \n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= (fall_counter == 5'd20) ? fall_counter : fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n    \n    always @(*) begin\n        next_state = state;\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n        \n        case (state)\n            LEFT: begin\n                walk_left = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n            end\n            RIGHT: begin\n                walk_right = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n            end\n            FALL_LEFT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter >= 5'd20)\n                        next_state = SPLAT;\n                    else\n                        next_state = LEFT;\n                end\n            end\n            FALL_RIGHT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter >= 5'd20)\n                        next_state = SPLAT;\n                    else\n                        next_state = RIGHT;\n                end\n            end\n            DIG_LEFT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n            end\n            SPLAT: begin\n                // Do nothing, stay in SPLAT state\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b110;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            LEFT: begin\n                walk_left = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n            end\n            RIGHT: begin\n                walk_right = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n            end\n            FALL_LEFT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = SPLAT;\n                    else\n                        next_state = LEFT;\n                end\n            end\n            FALL_RIGHT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = SPLAT;\n                    else\n                        next_state = RIGHT;\n                end\n            end\n            DIG_LEFT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n            end\n            SPLAT: begin\n                // Do nothing, stay in SPLAT state\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b110;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = SPLAT;\n                    else\n                        next_state = LEFT;\n                end else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = SPLAT;\n                    else\n                        next_state = RIGHT;\n                end else\n                    next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else\n                    next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else\n                    next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n        digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b110;\n    \n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n    \n    always @(*) begin\n        next_state = state;\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n        \n        case (state)\n            LEFT: begin\n                walk_left = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n            end\n            RIGHT: begin\n                walk_right = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n            end\n            FALL_LEFT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = SPLAT;\n                    else\n                        next_state = LEFT;\n                end\n            end\n            FALL_RIGHT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = SPLAT;\n                    else\n                        next_state = RIGHT;\n                end\n            end\n            DIG_LEFT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n            end\n            SPLAT: begin\n                // Do nothing, stay in SPLAT state\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b110;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            LEFT: begin\n                walk_left = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n            end\n            RIGHT: begin\n                walk_right = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n            end\n            FALL_LEFT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = SPLAT;\n                    else\n                        next_state = LEFT;\n                end\n            end\n            FALL_RIGHT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = SPLAT;\n                    else\n                        next_state = RIGHT;\n                end\n            end\n            DIG_LEFT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n            end\n            SPLAT: begin\n                // Do nothing, stay in SPLAT state\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_L = 3'b010, FALL_R = 3'b011, DIG_L = 3'b100, DIG_R = 3'b101, SPLAT = 3'b110;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= (fall_counter == 5'd20) ? fall_counter : fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_L;\n                else if (dig) next_state = DIG_L;\n                else if (bump_left) next_state = RIGHT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_R;\n                else if (dig) next_state = DIG_R;\n                else if (bump_right) next_state = LEFT;\n            end\n            FALL_L: begin\n                if (ground) begin\n                    if (fall_counter > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n            end\n            FALL_R: begin\n                if (ground) begin\n                    if (fall_counter > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n            end\n            DIG_L: begin\n                if (!ground) next_state = FALL_L;\n            end\n            DIG_R: begin\n                if (!ground) next_state = FALL_R;\n            end\n            SPLAT: next_state = SPLAT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_L) || (state == FALL_R);\n        digging = (state == DIG_L) || (state == DIG_R);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b110;\n    \n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT)\n                fall_counter <= (fall_counter == 5'd20) ? fall_counter : fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = (fall_counter > 5'd20) ? SPLAT : LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = (fall_counter > 5'd20) ? SPLAT : RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n        digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter WALK_LEFT = 3'b000;\n    parameter WALK_RIGHT = 3'b001;\n    parameter FALL_LEFT = 3'b010;\n    parameter FALL_RIGHT = 3'b011;\n    parameter DIG_LEFT = 3'b100;\n    parameter DIG_RIGHT = 3'b101;\n    parameter SPLAT = 3'b110;\n\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT)\n                fall_counter <= (fall_counter < 20) ? fall_counter + 1 : fall_counter;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground && fall_counter > 20) next_state = SPLAT;\n                else if (ground) next_state = WALK_LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground && fall_counter > 20) next_state = SPLAT;\n                else if (ground) next_state = WALK_RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n        digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg [4:0] fall_counter;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL)\n                fall_counter <= (fall_counter == 31) ? 31 : fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT && ground);\n        walk_right = (state == RIGHT && ground);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            direction <= 0;\n        else if ((state == LEFT || state == RIGHT) && ground)\n            direction <= (state == RIGHT);\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            walk_left <= 1;\n            walk_right <= 0;\n            aaah <= 0;\n            digging <= 0;\n        end else if (fall_counter > 20 && ground) begin\n            walk_left <= 0;\n            walk_right <= 0;\n            aaah <= 0;\n            digging <= 0;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b110;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n        digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg [4:0] fall_counter;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL)\n                fall_counter <= (fall_counter == 31) ? fall_counter : fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = FALL;\n                    else\n                        next_state = direction ? RIGHT : LEFT;\n                end\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n\n        if (state == LEFT || state == RIGHT)\n            direction = (state == RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg [4:0] fall_counter;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL)\n                fall_counter <= (fall_counter == 31) ? 31 : fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT && ground);\n        walk_right = (state == RIGHT && ground);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n\n        if (state == LEFT || state == RIGHT)\n            direction = (state == RIGHT);\n        \n        if (fall_counter > 20 && ground && state == FALL) begin\n            walk_left = 0;\n            walk_right = 0;\n            aaah = 0;\n            digging = 0;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b111;\n    \n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= (fall_counter == 5'd20) ? fall_counter : fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n    \n    always @(*) begin\n        next_state = state;\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n        \n        case (state)\n            LEFT: begin\n                walk_left = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n            end\n            RIGHT: begin\n                walk_right = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n            end\n            FALL_LEFT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter >= 5'd20)\n                        next_state = SPLAT;\n                    else\n                        next_state = LEFT;\n                end\n            end\n            FALL_RIGHT: begin\n                aaah = 1;\n                if (ground) begin\n                    if (fall_counter >= 5'd20)\n                        next_state = SPLAT;\n                    else\n                        next_state = RIGHT;\n                end\n            end\n            DIG_LEFT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                digging = 1;\n                if (!ground)\n                    next_state = FALL_RIGHT;\n            end\n            SPLAT: begin\n                // Do nothing, stay in SPLAT state\n            end\n        endcase\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg [4:0] fall_counter;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL)\n                fall_counter <= (fall_counter == 5'd20) ? fall_counter : fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground) begin\n                    if (fall_counter > 5'd20)\n                        next_state = FALL;\n                    else\n                        next_state = direction ? RIGHT : LEFT;\n                end\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n\n        if (state == LEFT || state == RIGHT)\n            direction = (state == RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter WALK_LEFT = 3'd0, WALK_RIGHT = 3'd1, FALL_LEFT = 3'd2, FALL_RIGHT = 3'd3, DIG_LEFT = 3'd4, DIG_RIGHT = 3'd5, SPLAT = 3'd6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            WALK_LEFT:\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = WALK_RIGHT;\n            WALK_RIGHT:\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = WALK_LEFT;\n            FALL_LEFT:\n                if (ground) next_state = (fall_counter > 20) ? SPLAT : WALK_LEFT;\n            FALL_RIGHT:\n                if (ground) next_state = (fall_counter > 20) ? SPLAT : WALK_RIGHT;\n            DIG_LEFT:\n                if (!ground) next_state = FALL_LEFT;\n            DIG_RIGHT:\n                if (!ground) next_state = FALL_RIGHT;\n            SPLAT:\n                next_state = SPLAT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n        digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter WALK_LEFT = 3'b000;\n    parameter WALK_RIGHT = 3'b001;\n    parameter FALL_LEFT = 3'b010;\n    parameter FALL_RIGHT = 3'b011;\n    parameter DIG_LEFT = 3'b100;\n    parameter DIG_RIGHT = 3'b101;\n    parameter SPLAT = 3'b110;\n\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                if (fall_counter < 20)\n                    fall_counter <= fall_counter + 1;\n            end else begin\n                fall_counter <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT:\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            WALK_RIGHT:\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            FALL_LEFT:\n                if (ground && fall_counter > 20) next_state = SPLAT;\n                else if (ground) next_state = WALK_LEFT;\n                else next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground && fall_counter > 20) next_state = SPLAT;\n                else if (ground) next_state = WALK_RIGHT;\n                else next_state = FALL_RIGHT;\n            DIG_LEFT:\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            DIG_RIGHT:\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            SPLAT:\n                next_state = SPLAT;\n            default:\n                next_state = WALK_LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n        digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 3'b000, RIGHT = 3'b001, FALL_LEFT = 3'b010, FALL_RIGHT = 3'b011, DIG_LEFT = 3'b100, DIG_RIGHT = 3'b101, SPLAT = 3'b110;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n        digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg [4:0] fall_counter;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_counter <= 0;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL) begin\n                if (fall_counter < 21) fall_counter <= fall_counter + 1;\n            end else begin\n                fall_counter <= 0;\n            end\n            if (state == LEFT || state == RIGHT) direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right)) next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground) next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground) next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT && ground);\n        walk_right = (state == RIGHT && ground);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n        if (fall_counter > 20 && ground) begin\n            walk_left = 0;\n            walk_right = 0;\n            aaah = 0;\n            digging = 0;\n        end\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter WALK_LEFT = 3'b000;\n    parameter WALK_RIGHT = 3'b001;\n    parameter FALL_LEFT = 3'b010;\n    parameter FALL_RIGHT = 3'b011;\n    parameter DIG_LEFT = 3'b100;\n    parameter DIG_RIGHT = 3'b101;\n    parameter SPLAT = 3'b110;\n\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            WALK_LEFT:\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = WALK_RIGHT;\n            WALK_RIGHT:\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = WALK_LEFT;\n            FALL_LEFT:\n                if (ground && fall_counter > 20) next_state = SPLAT;\n                else if (ground) next_state = WALK_LEFT;\n            FALL_RIGHT:\n                if (ground && fall_counter > 20) next_state = SPLAT;\n                else if (ground) next_state = WALK_RIGHT;\n            DIG_LEFT:\n                if (!ground) next_state = FALL_LEFT;\n            DIG_RIGHT:\n                if (!ground) next_state = FALL_RIGHT;\n            SPLAT:\n                next_state = SPLAT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n        digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    end\n\nendmodule"]}
{"task_id": "review2015_fsm", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    reg [3:0] state;\n    reg [3:0] pattern;\n    reg [2:0] shift_count;\n\n    parameter IDLE = 4'd0,\n              DETECT = 4'd1,\n              SHIFT = 4'd2,\n              COUNT = 4'd3,\n              TIMEOUT = 4'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            shift_count <= 3'd0;\n            shift_ena <= 1'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        state <= SHIFT;\n                        shift_ena <= 1'b1;\n                        shift_count <= 3'd0;\n                    end\n                end\n                SHIFT: begin\n                    pattern <= {pattern[2:0], data};\n                    shift_count <= shift_count + 1'b1;\n                    if (shift_count == 3'd3) begin\n                        state <= COUNT;\n                        shift_ena <= 1'b0;\n                        counting <= 1'b1;\n                    end\n                end\n                COUNT: begin\n                    if (done_counting) begin\n                        state <= TIMEOUT;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                TIMEOUT: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                    end\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    reg [3:0] state;\n    reg [3:0] pattern;\n    reg [2:0] shift_count;\n\n    parameter IDLE = 4'd0, CHECK_1 = 4'd1, CHECK_11 = 4'd2, CHECK_110 = 4'd3,\n              SHIFT = 4'd4, WAIT_COUNT = 4'd5, NOTIFY = 4'd6;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            shift_count <= 3'd0;\n            shift_ena <= 1'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (data) state <= CHECK_1;\n                    pattern <= {pattern[2:0], data};\n                end\n                CHECK_1: begin\n                    if (data) state <= CHECK_11;\n                    else state <= IDLE;\n                    pattern <= {pattern[2:0], data};\n                end\n                CHECK_11: begin\n                    if (!data) state <= CHECK_110;\n                    else state <= CHECK_11;\n                    pattern <= {pattern[2:0], data};\n                end\n                CHECK_110: begin\n                    if (data) state <= SHIFT;\n                    else state <= IDLE;\n                    pattern <= {pattern[2:0], data};\n                    shift_ena <= 1'b1;\n                    shift_count <= 3'd0;\n                end\n                SHIFT: begin\n                    if (shift_count == 3'd3) begin\n                        state <= WAIT_COUNT;\n                        shift_ena <= 1'b0;\n                        counting <= 1'b1;\n                    end else begin\n                        shift_count <= shift_count + 1'b1;\n                    end\n                end\n                WAIT_COUNT: begin\n                    if (done_counting) begin\n                        state <= NOTIFY;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                NOTIFY: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                    end\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    localparam IDLE = 3'd0,\n               DETECT1 = 3'd1,\n               DETECT11 = 3'd2,\n               DETECT110 = 3'd3,\n               DETECT1101 = 3'd4,\n               SHIFT = 3'd5,\n               COUNT = 3'd6,\n               DONE = 3'd7;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: next_state = data ? DETECT1 : IDLE;\n            DETECT1: next_state = data ? DETECT11 : IDLE;\n            DETECT11: next_state = data ? DETECT11 : DETECT110;\n            DETECT110: next_state = data ? DETECT1101 : IDLE;\n            DETECT1101: next_state = SHIFT;\n            SHIFT: begin\n                shift_ena = 1'b1;\n                if (shift_count == 3'd3)\n                    next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1'b1;\n                if (done_counting)\n                    next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 3'd0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1'b1;\n        else\n            shift_count <= 3'd0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, S1 = 3'd1, S11 = 3'd2, S110 = 3'd3, S1101 = 3'd4;\n    parameter SHIFT = 3'd5, COUNT = 3'd6, DONE = 3'd7;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (data) next_state = S1;\n            S1: next_state = data ? S11 : IDLE;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : IDLE;\n            S1101: next_state = SHIFT;\n            SHIFT: if (shift_count == 3) next_state = COUNT;\n            COUNT: if (done_counting) next_state = DONE;\n            DONE: if (ack) next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n            shift_count <= 0;\n        end else begin\n            shift_ena <= (state == SHIFT);\n            counting <= (state == COUNT);\n            done <= (state == DONE);\n            \n            if (state == SHIFT)\n                shift_count <= shift_count + 1;\n            else\n                shift_count <= 0;\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, \n              DETECT_1 = 3'd1, \n              DETECT_11 = 3'd2, \n              DETECT_110 = 3'd3, \n              SHIFT = 3'd4, \n              COUNT = 3'd5, \n              DONE = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: \n                if (data) next_state = DETECT_1;\n            DETECT_1: \n                if (data) next_state = DETECT_11;\n                else next_state = IDLE;\n            DETECT_11: \n                if (data) next_state = DETECT_11;\n                else next_state = DETECT_110;\n            DETECT_110: \n                if (data) next_state = SHIFT;\n                else next_state = IDLE;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, SEQ_1 = 3'd1, SEQ_11 = 3'd2, SEQ_110 = 3'd3, SHIFT = 3'd4, COUNT = 3'd5, NOTIFY = 3'd6;\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: next_state = data ? SEQ_1 : IDLE;\n            SEQ_1: next_state = data ? SEQ_11 : IDLE;\n            SEQ_11: next_state = data ? SEQ_11 : SEQ_110;\n            SEQ_110: next_state = data ? SHIFT : IDLE;\n            SHIFT: next_state = (shift_count == 3) ? COUNT : SHIFT;\n            COUNT: next_state = done_counting ? NOTIFY : COUNT;\n            NOTIFY: next_state = ack ? IDLE : NOTIFY;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n            shift_count <= 0;\n        end else begin\n            case (state)\n                SHIFT: begin\n                    shift_ena <= 1;\n                    shift_count <= shift_count + 1;\n                end\n                COUNT: begin\n                    shift_ena <= 0;\n                    counting <= 1;\n                end\n                NOTIFY: begin\n                    counting <= 0;\n                    done <= 1;\n                end\n                default: begin\n                    shift_ena <= 0;\n                    counting <= 0;\n                    done <= 0;\n                    shift_count <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0,\n              DETECT_1 = 3'd1,\n              DETECT_11 = 3'd2,\n              DETECT_110 = 3'd3,\n              SHIFT = 3'd4,\n              COUNT = 3'd5,\n              DONE = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: \n                if (data) next_state = DETECT_1;\n            DETECT_1: \n                if (data) next_state = DETECT_11;\n                else next_state = IDLE;\n            DETECT_11:\n                if (data) next_state = DETECT_110;\n                else next_state = IDLE;\n            DETECT_110:\n                if (!data) next_state = SHIFT;\n                else next_state = DETECT_11;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    parameter IDLE = 3'd0;\n    parameter DETECT_1 = 3'd1;\n    parameter DETECT_11 = 3'd2;\n    parameter DETECT_110 = 3'd3;\n    parameter SHIFT = 3'd4;\n    parameter COUNT = 3'd5;\n    parameter NOTIFY = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: \n                if (data) next_state = DETECT_1;\n            DETECT_1: \n                if (data) next_state = DETECT_11;\n                else next_state = IDLE;\n            DETECT_11: \n                if (data) next_state = DETECT_11;\n                else next_state = DETECT_110;\n            DETECT_110: \n                if (data) next_state = SHIFT;\n                else next_state = IDLE;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = NOTIFY;\n            end\n            NOTIFY: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    reg [3:0] state;\n    reg [3:0] pattern;\n    reg [2:0] shift_count;\n\n    parameter IDLE = 4'b0000;\n    parameter DETECT = 4'b0001;\n    parameter SHIFT = 4'b0010;\n    parameter COUNT = 4'b0011;\n    parameter FINISH = 4'b0100;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern <= 4'b0000;\n            shift_count <= 3'b000;\n            shift_ena <= 1'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        state <= SHIFT;\n                        shift_ena <= 1'b1;\n                        shift_count <= 3'b000;\n                    end\n                end\n                SHIFT: begin\n                    shift_count <= shift_count + 1'b1;\n                    if (shift_count == 3'b011) begin\n                        state <= COUNT;\n                        shift_ena <= 1'b0;\n                        counting <= 1'b1;\n                    end\n                end\n                COUNT: begin\n                    if (done_counting) begin\n                        state <= FINISH;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                FINISH: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                        pattern <= 4'b0000;\n                    end\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0,\n              DETECT_1 = 3'd1,\n              DETECT_11 = 3'd2,\n              DETECT_110 = 3'd3,\n              SHIFT = 3'd4,\n              COUNT = 3'd5,\n              DONE = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: \n                if (data) next_state = DETECT_1;\n            DETECT_1:\n                if (data) next_state = DETECT_11;\n                else next_state = IDLE;\n            DETECT_11:\n                if (data) next_state = DETECT_110;\n                else next_state = IDLE;\n            DETECT_110:\n                if (!data) next_state = SHIFT;\n                else next_state = DETECT_11;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, DETECT1 = 3'd1, DETECT11 = 3'd2, DETECT110 = 3'd3, SHIFT = 3'd4, COUNT = 3'd5, TIMEOUT = 3'd6;\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: if (data) next_state = DETECT1;\n            DETECT1: if (data) next_state = DETECT11; else next_state = IDLE;\n            DETECT11: if (data) next_state = DETECT110; else next_state = DETECT1;\n            DETECT110: begin\n                if (!data) next_state = SHIFT;\n                else next_state = DETECT11;\n            end\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = TIMEOUT;\n            end\n            TIMEOUT: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, DETECT1 = 3'd1, DETECT11 = 3'd2, DETECT110 = 3'd3, SHIFT = 3'd4, COUNT = 3'd5, NOTIFY = 3'd6;\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: if (data) next_state = DETECT1;\n            DETECT1: if (data) next_state = DETECT11; else next_state = IDLE;\n            DETECT11: if (data) next_state = DETECT110; else next_state = DETECT1;\n            DETECT110: begin\n                if (!data) next_state = SHIFT;\n                else next_state = DETECT11;\n            end\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = NOTIFY;\n            end\n            NOTIFY: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0,\n              DETECT_1 = 3'd1,\n              DETECT_11 = 3'd2,\n              DETECT_110 = 3'd3,\n              SHIFT = 3'd4,\n              COUNT = 3'd5,\n              DONE = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: \n                if (data) next_state = DETECT_1;\n            DETECT_1:\n                if (data) next_state = DETECT_11;\n                else next_state = IDLE;\n            DETECT_11:\n                if (data) next_state = DETECT_110;\n                else next_state = IDLE;\n            DETECT_110:\n                if (!data) next_state = SHIFT;\n                else next_state = DETECT_11;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0,\n              DETECT_1 = 3'd1,\n              DETECT_11 = 3'd2,\n              DETECT_110 = 3'd3,\n              SHIFT = 3'd4,\n              COUNT = 3'd5,\n              DONE = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: \n                if (data) next_state = DETECT_1;\n            DETECT_1: \n                if (data) next_state = DETECT_11;\n                else next_state = IDLE;\n            DETECT_11: \n                if (data) next_state = DETECT_11;\n                else next_state = DETECT_110;\n            DETECT_110: \n                if (data) next_state = SHIFT;\n                else next_state = IDLE;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, DETECT_1 = 3'd1, DETECT_11 = 3'd2, DETECT_110 = 3'd3,\n              SHIFT = 3'd4, COUNT = 3'd5, NOTIFY = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == SHIFT)\n                shift_count <= shift_count + 1;\n            else\n                shift_count <= 0;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: if (data) next_state = DETECT_1;\n            DETECT_1: if (data) next_state = DETECT_11; else next_state = IDLE;\n            DETECT_11: if (data) next_state = DETECT_110; else next_state = DETECT_1;\n            DETECT_110: begin\n                if (!data) next_state = SHIFT;\n                else next_state = DETECT_11;\n            end\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = NOTIFY;\n            end\n            NOTIFY: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, S1 = 3'd1, S11 = 3'd2, S110 = 3'd3, S1101 = 3'd4, \n              SHIFT = 3'd5, COUNT = 3'd6, DONE = 3'd7;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: next_state = data ? S1 : IDLE;\n            S1: next_state = data ? S11 : IDLE;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : IDLE;\n            S1101: begin\n                next_state = SHIFT;\n                shift_ena = 1;\n            end\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset || state != SHIFT)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, DETECT1 = 3'd1, DETECT11 = 3'd2, DETECT110 = 3'd3, SHIFT = 3'd4, COUNT = 3'd5, DONE = 3'd6;\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: \n                if (data) next_state = DETECT1;\n            DETECT1: \n                if (data) next_state = DETECT11;\n                else next_state = IDLE;\n            DETECT11:\n                if (data) next_state = DETECT11;\n                else next_state = DETECT110;\n            DETECT110:\n                if (data) begin\n                    next_state = SHIFT;\n                    shift_ena = 1;\n                end\n                else next_state = IDLE;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, S1 = 3'd1, S11 = 3'd2, S110 = 3'd3, S1101 = 3'd4, SHIFT = 3'd5, COUNT = 3'd6, DONE = 3'd7;\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE:  next_state = data ? S1 : IDLE;\n            S1:    next_state = data ? S11 : IDLE;\n            S11:   next_state = data ? S11 : S110;\n            S110:  next_state = data ? S1101 : IDLE;\n            S1101: next_state = SHIFT;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3)\n                    next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting)\n                    next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset || state != SHIFT)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, SEQ1 = 3'd1, SEQ2 = 3'd2, SEQ3 = 3'd3, SHIFT = 3'd4, COUNT = 3'd5, NOTIFY = 3'd6;\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: if (data) next_state = SEQ1;\n            SEQ1: next_state = data ? SEQ1 : SEQ2;\n            SEQ2: next_state = data ? SEQ3 : IDLE;\n            SEQ3: next_state = data ? SHIFT : IDLE;\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting) next_state = NOTIFY;\n            end\n            NOTIFY: begin\n                done = 1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset || state != SHIFT)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    parameter IDLE = 3'd0, S1 = 3'd1, S11 = 3'd2, S110 = 3'd3, S1101 = 3'd4, \n              SHIFT = 3'd5, COUNT = 3'd6, NOTIFY = 3'd7;\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_count;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: next_state = data ? S1 : IDLE;\n            S1: next_state = data ? S11 : IDLE;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? S1101 : IDLE;\n            S1101: begin\n                next_state = SHIFT;\n                shift_ena = 1;\n            end\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3)\n                    next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting)\n                    next_state = NOTIFY;\n            end\n            NOTIFY: begin\n                done = 1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset)\n            shift_count <= 0;\n        else if (state == SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 0;\n    end\n\nendmodule"]}
{"task_id": "conwaylife", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbors;\n                neighbors = \n                    q[((i-1+16)%16)*16 + ((j-1+16)%16)] +\n                    q[((i-1+16)%16)*16 + j] +\n                    q[((i-1+16)%16)*16 + ((j+1)%16)] +\n                    q[i*16 + ((j-1+16)%16)] +\n                    q[i*16 + ((j+1)%16)] +\n                    q[((i+1)%16)*16 + ((j-1+16)%16)] +\n                    q[((i+1)%16)*16 + j] +\n                    q[((i+1)%16)*16 + ((j+1)%16)];\n\n                case (neighbors)\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                    default: next_q[i*16 + j] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j, row, col, live_neighbors;\n\n    always @(*) begin\n        for (i = 0; i < 256; i = i + 1) begin\n            row = i / 16;\n            col = i % 16;\n            live_neighbors = 0;\n\n            for (j = -1; j <= 1; j = j + 1) begin\n                live_neighbors = live_neighbors + q[((row + 16 + j) % 16) * 16 + ((col + 15) % 16)];\n                live_neighbors = live_neighbors + q[((row + 16 + j) % 16) * 16 + ((col + 1) % 16)];\n            end\n            live_neighbors = live_neighbors + q[((row + 15) % 16) * 16 + col];\n            live_neighbors = live_neighbors + q[((row + 1) % 16) * 16 + col];\n            live_neighbors = live_neighbors - q[i];\n\n            case (live_neighbors)\n                2: next_q[i] = q[i];\n                3: next_q[i] = 1'b1;\n                default: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer count;\n                count = 0;\n\n                // Count live neighbors\n                count = count + q[((i-1+16)%16)*16 + ((j-1+16)%16)] +\n                               q[((i-1+16)%16)*16 + j] +\n                               q[((i-1+16)%16)*16 + ((j+1)%16)] +\n                               q[i*16 + ((j-1+16)%16)] +\n                               q[i*16 + ((j+1)%16)] +\n                               q[((i+1)%16)*16 + ((j-1+16)%16)] +\n                               q[((i+1)%16)*16 + j] +\n                               q[((i+1)%16)*16 + ((j+1)%16)];\n\n                // Apply rules\n                case (count)\n                    2: next_q[i*16+j] = q[i*16+j];\n                    3: next_q[i*16+j] = 1'b1;\n                    default: next_q[i*16+j] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j, row, col, neighbors;\n\n    always @(*) begin\n        for (i = 0; i < 256; i = i + 1) begin\n            row = i / 16;\n            col = i % 16;\n            neighbors = 0;\n\n            for (j = 0; j < 8; j = j + 1) begin\n                case (j)\n                    0: neighbors = neighbors + q[((row - 1 + 16) % 16) * 16 + ((col - 1 + 16) % 16)];\n                    1: neighbors = neighbors + q[((row - 1 + 16) % 16) * 16 + col];\n                    2: neighbors = neighbors + q[((row - 1 + 16) % 16) * 16 + ((col + 1) % 16)];\n                    3: neighbors = neighbors + q[row * 16 + ((col - 1 + 16) % 16)];\n                    4: neighbors = neighbors + q[row * 16 + ((col + 1) % 16)];\n                    5: neighbors = neighbors + q[((row + 1) % 16) * 16 + ((col - 1 + 16) % 16)];\n                    6: neighbors = neighbors + q[((row + 1) % 16) * 16 + col];\n                    7: neighbors = neighbors + q[((row + 1) % 16) * 16 + ((col + 1) % 16)];\n                endcase\n            end\n\n            case (neighbors)\n                0, 1: next_q[i] = 1'b0;\n                2: next_q[i] = q[i];\n                3: next_q[i] = 1'b1;\n                default: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbors = 0;\n                integer x, y;\n\n                for (x = -1; x <= 1; x = x + 1) begin\n                    for (y = -1; y <= 1; y = y + 1) begin\n                        if (x != 0 || y != 0) begin\n                            neighbors = neighbors + q[((i+x+16)%16)*16 + (j+y+16)%16];\n                        end\n                    end\n                end\n\n                case (neighbors)\n                    0, 1: next_q[i*16+j] = 1'b0;\n                    2: next_q[i*16+j] = q[i*16+j];\n                    3: next_q[i*16+j] = 1'b1;\n                    default: next_q[i*16+j] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbors;\n                neighbors = \n                    q[((i-1+16)%16)*16 + ((j-1+16)%16)] +\n                    q[((i-1+16)%16)*16 + j] +\n                    q[((i-1+16)%16)*16 + ((j+1)%16)] +\n                    q[i*16 + ((j-1+16)%16)] +\n                    q[i*16 + ((j+1)%16)] +\n                    q[((i+1)%16)*16 + ((j-1+16)%16)] +\n                    q[((i+1)%16)*16 + j] +\n                    q[((i+1)%16)*16 + ((j+1)%16)];\n\n                case (neighbors)\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                    default: next_q[i*16 + j] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\ninteger i, j;\nreg [3:0] neighbors;\n\nalways @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbors = q[((i-1+16)%16)*16 + ((j-1+16)%16)] +\n                            q[((i-1+16)%16)*16 + j] +\n                            q[((i-1+16)%16)*16 + ((j+1)%16)] +\n                            q[i*16 + ((j-1+16)%16)] +\n                            q[i*16 + ((j+1)%16)] +\n                            q[((i+1)%16)*16 + ((j-1+16)%16)] +\n                            q[((i+1)%16)*16 + j] +\n                            q[((i+1)%16)*16 + ((j+1)%16)];\n\n                case (neighbors)\n                    4'b0000, 4'b0001: q[i*16+j] <= 1'b0;\n                    4'b0010: q[i*16+j] <= q[i*16+j];\n                    4'b0011: q[i*16+j] <= 1'b1;\n                    default: q[i*16+j] <= 1'b0;\n                endcase\n            end\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j, row, col;\n    reg [3:0] neighbors;\n\n    always @(*) begin\n        for (i = 0; i < 256; i = i + 1) begin\n            row = i / 16;\n            col = i % 16;\n            neighbors = 0;\n\n            for (j = -1; j <= 1; j = j + 1) begin\n                neighbors = neighbors + q[((row + 16 - 1) % 16) * 16 + ((col + 16 + j) % 16)];\n                neighbors = neighbors + q[((row + 16 + 1) % 16) * 16 + ((col + 16 + j) % 16)];\n            end\n            neighbors = neighbors + q[row * 16 + ((col + 16 - 1) % 16)];\n            neighbors = neighbors + q[row * 16 + ((col + 16 + 1) % 16)];\n\n            case (neighbors)\n                4'h2: next_q[i] = q[i];\n                4'h3: next_q[i] = 1'b1;\n                default: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j, row, col, count;\n\n    always @(*) begin\n        for (i = 0; i < 256; i = i + 1) begin\n            row = i / 16;\n            col = i % 16;\n            count = 0;\n\n            for (j = -1; j <= 1; j = j + 1) begin\n                count = count + q[((row + 16 + j) % 16) * 16 + ((col + 15) % 16)];\n                count = count + q[((row + 16 + j) % 16) * 16 + col];\n                count = count + q[((row + 16 + j) % 16) * 16 + ((col + 17) % 16)];\n            end\n\n            count = count - q[i];\n\n            case (count)\n                2: next_q[i] = q[i];\n                3: next_q[i] = 1'b1;\n                default: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\ninteger i, j;\nreg [3:0] neighbor_count;\n\nalways @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbor_count = q[((i-1+16)%16)*16 + ((j-1+16)%16)] +\n                                 q[((i-1+16)%16)*16 + j] +\n                                 q[((i-1+16)%16)*16 + ((j+1)%16)] +\n                                 q[i*16 + ((j-1+16)%16)] +\n                                 q[i*16 + ((j+1)%16)] +\n                                 q[((i+1)%16)*16 + ((j-1+16)%16)] +\n                                 q[((i+1)%16)*16 + j] +\n                                 q[((i+1)%16)*16 + ((j+1)%16)];\n\n                case (neighbor_count)\n                    4'b0000, 4'b0001: q[i*16 + j] <= 1'b0;\n                    4'b0010: q[i*16 + j] <= q[i*16 + j];\n                    4'b0011: q[i*16 + j] <= 1'b1;\n                    default: q[i*16 + j] <= 1'b0;\n                endcase\n            end\n        end\n    end\nend\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer count;\n                integer row, col;\n                count = 0;\n\n                for (row = -1; row <= 1; row = row + 1) begin\n                    for (col = -1; col <= 1; col = col + 1) begin\n                        if (row != 0 || col != 0) begin\n                            integer neighbor_row, neighbor_col;\n                            neighbor_row = (i + row + 16) % 16;\n                            neighbor_col = (j + col + 16) % 16;\n                            count = count + q[neighbor_row * 16 + neighbor_col];\n                        end\n                    end\n                end\n\n                case (count)\n                    2: next_q[i * 16 + j] = q[i * 16 + j];\n                    3: next_q[i * 16 + j] = 1'b1;\n                    default: next_q[i * 16 + j] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j, row, col, count;\n\n    always @(*) begin\n        for (i = 0; i < 256; i = i + 1) begin\n            row = i / 16;\n            col = i % 16;\n            count = 0;\n\n            for (j = 0; j < 8; j = j + 1) begin\n                case (j)\n                    0: count = count + q[((row-1+16)%16)*16 + ((col-1+16)%16)];\n                    1: count = count + q[((row-1+16)%16)*16 + col];\n                    2: count = count + q[((row-1+16)%16)*16 + ((col+1)%16)];\n                    3: count = count + q[row*16 + ((col-1+16)%16)];\n                    4: count = count + q[row*16 + ((col+1)%16)];\n                    5: count = count + q[((row+1)%16)*16 + ((col-1+16)%16)];\n                    6: count = count + q[((row+1)%16)*16 + col];\n                    7: count = count + q[((row+1)%16)*16 + ((col+1)%16)];\n                endcase\n            end\n\n            case (count)\n                0, 1: next_q[i] = 1'b0;\n                2: next_q[i] = q[i];\n                3: next_q[i] = 1'b1;\n                default: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer count;\n                integer row, col, index;\n                count = 0;\n\n                for (row = -1; row <= 1; row = row + 1) begin\n                    for (col = -1; col <= 1; col = col + 1) begin\n                        if (row != 0 || col != 0) begin\n                            index = ((i + row + 16) % 16) * 16 + ((j + col + 16) % 16);\n                            count = count + q[index];\n                        end\n                    end\n                end\n\n                case (count)\n                    0, 1: next_q[i*16 + j] = 1'b0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                    default: next_q[i*16 + j] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j, row, col, count;\n\n    always @(*) begin\n        for (i = 0; i < 256; i = i + 1) begin\n            row = i / 16;\n            col = i % 16;\n            count = 0;\n\n            for (j = -1; j <= 1; j = j + 1) begin\n                count = count + q[((row + 16 - 1) % 16) * 16 + ((col + 16 + j) % 16)];\n                count = count + q[((row + 16 + 1) % 16) * 16 + ((col + 16 + j) % 16)];\n            end\n            count = count + q[row * 16 + ((col + 16 - 1) % 16)];\n            count = count + q[row * 16 + ((col + 16 + 1) % 16)];\n\n            case (count)\n                2: next_q[i] = q[i];\n                3: next_q[i] = 1'b1;\n                default: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbors = 0;\n                integer x, y;\n\n                for (x = -1; x <= 1; x = x + 1) begin\n                    for (y = -1; y <= 1; y = y + 1) begin\n                        if (x != 0 || y != 0) begin\n                            integer nx = (i + x + 16) % 16;\n                            integer ny = (j + y + 16) % 16;\n                            neighbors = neighbors + q[nx*16 + ny];\n                        end\n                    end\n                end\n\n                case (neighbors)\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                    default: next_q[i*16 + j] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j, row, col, neighbors;\n\n    always @(*) begin\n        for (i = 0; i < 256; i = i + 1) begin\n            row = i / 16;\n            col = i % 16;\n            neighbors = 0;\n\n            for (j = 0; j < 8; j = j + 1) begin\n                case (j)\n                    0: neighbors = neighbors + q[((row-1+16)%16)*16 + ((col-1+16)%16)];\n                    1: neighbors = neighbors + q[((row-1+16)%16)*16 + col];\n                    2: neighbors = neighbors + q[((row-1+16)%16)*16 + ((col+1)%16)];\n                    3: neighbors = neighbors + q[row*16 + ((col-1+16)%16)];\n                    4: neighbors = neighbors + q[row*16 + ((col+1)%16)];\n                    5: neighbors = neighbors + q[((row+1)%16)*16 + ((col-1+16)%16)];\n                    6: neighbors = neighbors + q[((row+1)%16)*16 + col];\n                    7: neighbors = neighbors + q[((row+1)%16)*16 + ((col+1)%16)];\n                endcase\n            end\n\n            case (neighbors)\n                2: next_q[i] = q[i];\n                3: next_q[i] = 1'b1;\n                default: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbors = 0;\n                integer row, col;\n\n                for (row = -1; row <= 1; row = row + 1) begin\n                    for (col = -1; col <= 1; col = col + 1) begin\n                        if (row != 0 || col != 0) begin\n                            neighbors = neighbors + q[((i + row + 16) % 16) * 16 + ((j + col + 16) % 16)];\n                        end\n                    end\n                end\n\n                case (neighbors)\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1;\n                    default: next_q[i*16 + j] = 0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n    \n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbors = 0;\n                integer x, y;\n                \n                for (x = -1; x <= 1; x = x + 1) begin\n                    for (y = -1; y <= 1; y = y + 1) begin\n                        if (x != 0 || y != 0) begin\n                            integer nx = (i + x + 16) % 16;\n                            integer ny = (j + y + 16) % 16;\n                            neighbors = neighbors + q[nx * 16 + ny];\n                        end\n                    end\n                end\n                \n                case (neighbors)\n                    0, 1: next_q[i * 16 + j] = 1'b0;\n                    2: next_q[i * 16 + j] = q[i * 16 + j];\n                    3: next_q[i * 16 + j] = 1'b1;\n                    default: next_q[i * 16 + j] = 1'b0;\n                endcase\n            end\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n    \n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer count;\n                count = \n                    q[((i-1+16)%16)*16 + ((j-1+16)%16)] +\n                    q[((i-1+16)%16)*16 + j] +\n                    q[((i-1+16)%16)*16 + ((j+1)%16)] +\n                    q[i*16 + ((j-1+16)%16)] +\n                    q[i*16 + ((j+1)%16)] +\n                    q[((i+1)%16)*16 + ((j-1+16)%16)] +\n                    q[((i+1)%16)*16 + j] +\n                    q[((i+1)%16)*16 + ((j+1)%16)];\n                \n                case (count)\n                    2: next_q[i*16+j] = q[i*16+j];\n                    3: next_q[i*16+j] = 1'b1;\n                    default: next_q[i*16+j] = 1'b0;\n                endcase\n            end\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer i, j;\n\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer count;\n                integer x, y;\n                count = 0;\n\n                for (x = -1; x <= 1; x = x + 1) begin\n                    for (y = -1; y <= 1; y = y + 1) begin\n                        if (x != 0 || y != 0) begin\n                            integer nx, ny;\n                            nx = (i + x + 16) % 16;\n                            ny = (j + y + 16) % 16;\n                            count = count + q[nx*16 + ny];\n                        end\n                    end\n                end\n\n                case (count)\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                    default: next_q[i*16 + j] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"]}
{"task_id": "lemmings3", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n                else\n                    next_state = state;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg last_direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            last_direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                last_direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if (bump_left) next_state = RIGHT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if (bump_right) next_state = LEFT;\n            end\n            FALL: begin\n                if (ground) next_state = last_direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground) next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            direction <= 0;\n        end else if (state == LEFT || state == RIGHT) begin\n            if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                direction <= ~direction;\n        end\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;  // 0 for left, 1 for right\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if ((state == LEFT || state == RIGHT) && ground)\n                direction <= (bump_left && !bump_right) ? 1 :\n                             (bump_right && !bump_left) ? 0 : direction;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT:\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else\n                    next_state = direction ? RIGHT : LEFT;\n            FALL:\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            DIG:\n                if (!ground)\n                    next_state = FALL;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam WALK_LEFT = 2'b00;\n    localparam WALK_RIGHT = 2'b01;\n    localparam FALL = 2'b10;\n    localparam DIG = 2'b11;\n\n    reg [1:0] state, next_state;\n    reg last_direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            last_direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == WALK_LEFT || state == WALK_RIGHT)\n                last_direction <= state[0];\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = last_direction ? WALK_RIGHT : WALK_LEFT;\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg last_direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            last_direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                last_direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if (bump_left) next_state = RIGHT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if (bump_right) next_state = LEFT;\n            end\n            FALL: begin\n                if (ground) next_state = last_direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground) next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg last_direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            last_direction <= 1'b0; // 0 for left, 1 for right\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                last_direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = last_direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n                else\n                    next_state = state;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state != FALL && state != DIG)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n                else\n                    next_state = state;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n    reg direction;  // 0 for left, 1 for right\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            direction <= 0;\n        end else begin\n            state <= next_state;\n            if (state == LEFT || state == RIGHT)\n                direction <= (state == RIGHT);\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            LEFT, RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if ((state == LEFT && bump_left) || (state == RIGHT && bump_right))\n                    next_state = (state == LEFT) ? RIGHT : LEFT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = direction ? RIGHT : LEFT;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule"]}
{"task_id": "count_clock", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end\n                            else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end\n                            else if (hh[3:0] == 4'd9) begin\n                                hh <= {4'h1, 4'h0};\n                            end\n                            else begin\n                                hh <= hh + 8'h01;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 4'd1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 4'd1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 4'd1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 4'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n        end else if (ena) begin\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm;\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                    end else begin\n                        hh[3:0] <= hh[3:0] + 1'b1;\n                        if (hh[3:0] == 4'h9) begin\n                            hh[3:0] <= 4'h0;\n                            hh[7:4] <= hh[7:4] + 1'b1;\n                        end\n                    end\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1'b1;\n                    if (mm[3:0] == 4'h9) begin\n                        mm[3:0] <= 4'h0;\n                        mm[7:4] <= mm[7:4] + 1'b1;\n                    end\n                end\n            end else begin\n                ss[3:0] <= ss[3:0] + 1'b1;\n                if (ss[3:0] == 4'h9) begin\n                    ss[3:0] <= 4'h0;\n                    ss[7:4] <= ss[7:4] + 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n        end else if (ena) begin\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm;\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                    end else if (hh[3:0] == 4'h9) begin\n                        hh <= {hh[7:4] + 1'b1, 4'h0};\n                    end else begin\n                        hh[3:0] <= hh[3:0] + 1'b1;\n                    end\n                end else if (mm[3:0] == 4'h9) begin\n                    mm <= {mm[7:4] + 1'b1, 4'h0};\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1'b1;\n                end\n            end else if (ss[3:0] == 4'h9) begin\n                ss <= {ss[7:4] + 1'b1, 4'h0};\n            end else begin\n                ss[3:0] <= ss[3:0] + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    reg [3:0] hh_ones, hh_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] ss_ones, ss_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n        end else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh_ones == 4'd2 && hh_tens == 4'd1) begin\n                                hh_ones <= 4'd1;\n                                hh_tens <= 4'd0;\n                                pm <= ~pm;\n                            end else if (hh_ones == 4'd9) begin\n                                hh_ones <= 4'd0;\n                                hh_tens <= hh_tens + 1'd1;\n                            end else begin\n                                hh_ones <= hh_ones + 1'd1;\n                            end\n                        end else begin\n                            mm_tens <= mm_tens + 1'd1;\n                        end\n                    end else begin\n                        mm_ones <= mm_ones + 1'd1;\n                    end\n                end else begin\n                    ss_tens <= ss_tens + 1'd1;\n                end\n            end else begin\n                ss_ones <= ss_ones + 1'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        hh = {hh_tens, hh_ones};\n        mm = {mm_tens, mm_ones};\n        ss = {ss_tens, ss_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end\n                            else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end\n                            else if (hh[3:0] == 4'd9) begin\n                                hh[7:4] <= hh[7:4] + 1'b1;\n                                hh[3:0] <= 4'd0;\n                            end\n                            else begin\n                                hh[3:0] <= hh[3:0] + 1'b1;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 1'b1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 1'b1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 1'b1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end\n                            else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end\n                            else if (hh[3:0] == 4'd9) begin\n                                hh <= {4'h1, 4'h0};\n                            end\n                            else begin\n                                hh <= hh + 8'h01;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 4'd1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 4'd1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 4'd1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 4'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n            pm <= 1'b0;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh_ones == 4'd2 && hh_tens == 4'd1) begin\n                                hh_ones <= 4'd1;\n                                hh_tens <= 4'd0;\n                                pm <= ~pm;\n                            end\n                            else if (hh_ones == 4'd9) begin\n                                hh_ones <= 4'd0;\n                                hh_tens <= hh_tens + 1'b1;\n                            end\n                            else begin\n                                hh_ones <= hh_ones + 1'b1;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 1'b1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 1'b1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 1'b1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end\n                            else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end\n                            else if (hh[3:0] == 4'd9) begin\n                                hh <= {4'h1, 4'h0};\n                            end\n                            else begin\n                                hh[3:0] <= hh[3:0] + 1'd1;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 1'd1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 1'd1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 1'd1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 1'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n        end else if (ena) begin\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm;\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                    end else begin\n                        hh[3:0] <= hh[3:0] + 1'b1;\n                        if (hh[3:0] == 4'h9) begin\n                            hh[3:0] <= 4'h0;\n                            hh[7:4] <= hh[7:4] + 1'b1;\n                        end\n                    end\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1'b1;\n                    if (mm[3:0] == 4'h9) begin\n                        mm[3:0] <= 4'h0;\n                        mm[7:4] <= mm[7:4] + 1'b1;\n                    end\n                end\n            end else begin\n                ss[3:0] <= ss[3:0] + 1'b1;\n                if (ss[3:0] == 4'h9) begin\n                    ss[3:0] <= 4'h0;\n                    ss[7:4] <= ss[7:4] + 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end\n                            else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end\n                            else if (hh[3:0] == 4'd9) begin\n                                hh <= {4'h1, 4'h0};\n                            end\n                            else begin\n                                hh[3:0] <= hh[3:0] + 1'd1;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 1'd1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 1'd1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 1'd1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 1'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n            pm <= 1'b0;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh_ones == 4'd2 && hh_tens == 4'd1) begin\n                                hh_ones <= 4'd1;\n                                hh_tens <= 4'd0;\n                                pm <= ~pm;\n                            end\n                            else if (hh_ones == 4'd9) begin\n                                hh_ones <= 4'd0;\n                                hh_tens <= hh_tens + 1'd1;\n                            end\n                            else begin\n                                hh_ones <= hh_ones + 1'd1;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 1'd1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 1'd1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 1'd1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 1'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n            pm <= 1'b0;\n        end else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh_ones == 4'd2 && hh_tens == 4'd1) begin\n                                hh_ones <= 4'd1;\n                                hh_tens <= 4'd0;\n                                pm <= ~pm;\n                            end else if (hh_ones == 4'd9) begin\n                                hh_ones <= 4'd0;\n                                hh_tens <= hh_tens + 1'b1;\n                            end else begin\n                                hh_ones <= hh_ones + 1'b1;\n                            end\n                        end else begin\n                            mm_tens <= mm_tens + 1'b1;\n                        end\n                    end else begin\n                        mm_ones <= mm_ones + 1'b1;\n                    end\n                end else begin\n                    ss_tens <= ss_tens + 1'b1;\n                end\n            end else begin\n                ss_ones <= ss_ones + 1'b1;\n            end\n        end\n    end\n\n    always @* begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n        end else if (ena) begin\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                        pm <= ~pm;\n                    end else if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                    end else begin\n                        hh <= hh + 8'h01;\n                    end\n                end else begin\n                    mm <= (mm[3:0] == 4'h9) ? {mm[7:4] + 4'h1, 4'h0} : {mm[7:4], mm[3:0] + 4'h1};\n                end\n            end else begin\n                ss <= (ss[3:0] == 4'h9) ? {ss[7:4] + 4'h1, 4'h0} : {ss[7:4], ss[3:0] + 4'h1};\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n        end else if (ena) begin\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm;\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                    end else begin\n                        hh[3:0] <= hh[3:0] + 1'b1;\n                        if (hh[3:0] == 4'h9) begin\n                            hh[3:0] <= 4'h0;\n                            hh[7:4] <= hh[7:4] + 1'b1;\n                        end\n                    end\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1'b1;\n                    if (mm[3:0] == 4'h9) begin\n                        mm[3:0] <= 4'h0;\n                        mm[7:4] <= mm[7:4] + 1'b1;\n                    end\n                end\n            end else begin\n                ss[3:0] <= ss[3:0] + 1'b1;\n                if (ss[3:0] == 4'h9) begin\n                    ss[3:0] <= 4'h0;\n                    ss[7:4] <= ss[7:4] + 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            ss_ones <= 4'h0;\n            ss_tens <= 4'h0;\n            mm_ones <= 4'h0;\n            mm_tens <= 4'h0;\n            hh_ones <= 4'h2;\n            hh_tens <= 4'h1;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'h9) begin\n                ss_ones <= 4'h0;\n                if (ss_tens == 4'h5) begin\n                    ss_tens <= 4'h0;\n                    if (mm_ones == 4'h9) begin\n                        mm_ones <= 4'h0;\n                        if (mm_tens == 4'h5) begin\n                            mm_tens <= 4'h0;\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end\n                            else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end\n                            else if (hh[3:0] == 4'h9) begin\n                                hh <= {4'h1, 4'h0};\n                            end\n                            else begin\n                                hh <= hh + 8'h01;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 4'h1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 4'h1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 4'h1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 4'h1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n            pm <= 1'b0;\n        end else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh_ones == 4'd2 && hh_tens == 4'd1) begin\n                                hh_ones <= 4'd1;\n                                hh_tens <= 4'd0;\n                                pm <= ~pm;\n                            end else if (hh_ones == 4'd9) begin\n                                hh_ones <= 4'd0;\n                                hh_tens <= hh_tens + 1'b1;\n                            end else begin\n                                hh_ones <= hh_ones + 1'b1;\n                            end\n                        end else begin\n                            mm_tens <= mm_tens + 1'b1;\n                        end\n                    end else begin\n                        mm_ones <= mm_ones + 1'b1;\n                    end\n                end else begin\n                    ss_tens <= ss_tens + 1'b1;\n                end\n            end else begin\n                ss_ones <= ss_ones + 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n    reg [3:0] hh_ones, hh_tens, mm_ones, mm_tens, ss_ones, ss_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n        end else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh_ones == 4'd2 && hh_tens == 4'd1) begin\n                                hh_ones <= 4'd1;\n                                hh_tens <= 4'd0;\n                                pm <= ~pm;\n                            end else if (hh_ones == 4'd9) begin\n                                hh_ones <= 4'd0;\n                                hh_tens <= hh_tens + 1'd1;\n                            end else begin\n                                hh_ones <= hh_ones + 1'd1;\n                            end\n                        end else begin\n                            mm_tens <= mm_tens + 1'd1;\n                        end\n                    end else begin\n                        mm_ones <= mm_ones + 1'd1;\n                    end\n                end else begin\n                    ss_tens <= ss_tens + 1'd1;\n                end\n            end else begin\n                ss_ones <= ss_ones + 1'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        hh = {hh_tens, hh_ones};\n        mm = {mm_tens, mm_ones};\n        ss = {ss_tens, ss_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n    reg [3:0] ss_ones, ss_tens, mm_ones, mm_tens, hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end\n                            else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end\n                            else if (hh[3:0] == 4'd9) begin\n                                hh <= {hh[7:4] + 4'd1, 4'd0};\n                            end\n                            else begin\n                                hh <= hh + 8'h01;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 4'd1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 4'd1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 4'd1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 4'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    reg [3:0] ss_ones, ss_tens;\n    reg [3:0] mm_ones, mm_tens;\n    reg [3:0] hh_ones, hh_tens;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            ss_ones <= 4'd0;\n            ss_tens <= 4'd0;\n            mm_ones <= 4'd0;\n            mm_tens <= 4'd0;\n            hh_ones <= 4'd2;\n            hh_tens <= 4'd1;\n        end\n        else if (ena) begin\n            if (ss_ones == 4'd9) begin\n                ss_ones <= 4'd0;\n                if (ss_tens == 4'd5) begin\n                    ss_tens <= 4'd0;\n                    if (mm_ones == 4'd9) begin\n                        mm_ones <= 4'd0;\n                        if (mm_tens == 4'd5) begin\n                            mm_tens <= 4'd0;\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end\n                            else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end\n                            else if (hh[3:0] == 4'd9) begin\n                                hh <= {4'h1, 4'h0};\n                            end\n                            else begin\n                                hh <= hh + 8'h01;\n                            end\n                        end\n                        else begin\n                            mm_tens <= mm_tens + 4'd1;\n                        end\n                    end\n                    else begin\n                        mm_ones <= mm_ones + 4'd1;\n                    end\n                end\n                else begin\n                    ss_tens <= ss_tens + 4'd1;\n                end\n            end\n            else begin\n                ss_ones <= ss_ones + 4'd1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ss = {ss_tens, ss_ones};\n        mm = {mm_tens, mm_ones};\n        hh = {hh_tens, hh_ones};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n        end else if (ena) begin\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                        pm <= ~pm;\n                    end else if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                    end else begin\n                        hh <= hh + 8'h01;\n                    end\n                end else begin\n                    mm <= (mm[3:0] == 4'h9) ? {mm[7:4] + 4'h1, 4'h0} : {mm[7:4], mm[3:0] + 4'h1};\n                end\n            end else begin\n                ss <= (ss[3:0] == 4'h9) ? {ss[7:4] + 4'h1, 4'h0} : {ss[7:4], ss[3:0] + 4'h1};\n            end\n        end\n    end\n\nendmodule"]}
{"task_id": "lemmings2", "llmgen_RTL": ["module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n\tlocalparam LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n\treg [1:0] state, next_state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= LEFT;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tLEFT: \n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\t\telse if (bump_left)\n\t\t\t\t\tnext_state = RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = LEFT;\n\t\t\tRIGHT:\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\t\telse if (bump_right)\n\t\t\t\t\tnext_state = LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = RIGHT;\n\t\t\tFALL_LEFT:\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\tFALL_RIGHT:\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\tdefault: next_state = LEFT;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\twalk_left = (state == LEFT);\n\t\twalk_right = (state == RIGHT);\n\t\taaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\tend\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT:\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default:\n                next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    localparam LEFT = 2'b00;\n    localparam RIGHT = 2'b01;\n    localparam FALL_LEFT = 2'b10;\n    localparam FALL_RIGHT = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    parameter WALK_LEFT = 2'b00;\n    parameter WALK_RIGHT = 2'b01;\n    parameter FALL_LEFT = 2'b10;\n    parameter FALL_RIGHT = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT: \n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah\n);\n\n    localparam LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            LEFT:\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT:\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            FALL_LEFT:\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            FALL_RIGHT:\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            default:\n                next_state = LEFT;\n        endcase\n    end\n\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    end\n\nendmodule"]}
{"task_id": "countbcd", "llmgen_RTL": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0;\n                    if (q[11:8] == 4'd9) begin\n                        q[11:8] <= 4'd0;\n                        if (q[15:12] == 4'd9) begin\n                            q[15:12] <= 4'd0;\n                        end else begin\n                            q[15:12] <= q[15:12] + 1;\n                        end\n                    end else begin\n                        q[11:8] <= q[11:8] + 1;\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 1;\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 1;\n            end\n        end\n    end\n    \n    assign ena[1] = (q[3:0] == 4'd9);\n    assign ena[2] = (q[7:4] == 4'd9) && (q[3:0] == 4'd9);\n    assign ena[3] = (q[11:8] == 4'd9) && (q[7:4] == 4'd9) && (q[3:0] == 4'd9);\n    \nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q\n);\n\n    reg [3:0] digit0, digit1, digit2, digit3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            digit0 <= 4'd0;\n            digit1 <= 4'd0;\n            digit2 <= 4'd0;\n            digit3 <= 4'd0;\n        end else begin\n            if (digit0 == 4'd9) begin\n                digit0 <= 4'd0;\n                if (digit1 == 4'd9) begin\n                    digit1 <= 4'd0;\n                    if (digit2 == 4'd9) begin\n                        digit2 <= 4'd0;\n                        if (digit3 == 4'd9) begin\n                            digit3 <= 4'd0;\n                        end else begin\n                            digit3 <= digit3 + 1;\n                        end\n                    end else begin\n                        digit2 <= digit2 + 1;\n                    end\n                end else begin\n                    digit1 <= digit1 + 1;\n                end\n            end else begin\n                digit0 <= digit0 + 1;\n            end\n        end\n    end\n\n    assign ena[1] = (digit0 == 4'd9);\n    assign ena[2] = (digit0 == 4'd9) && (digit1 == 4'd9);\n    assign ena[3] = (digit0 == 4'd9) && (digit1 == 4'd9) && (digit2 == 4'd9);\n\n    always @(*) begin\n        q = {digit3, digit2, digit1, digit0};\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] ena_internal;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (ena_internal[0]) begin\n                if (q[3:0] == 4'd9) q[3:0] <= 4'd0;\n                else q[3:0] <= q[3:0] + 1'd1;\n            end\n            if (ena_internal[1]) begin\n                if (q[7:4] == 4'd9) q[7:4] <= 4'd0;\n                else q[7:4] <= q[7:4] + 1'd1;\n            end\n            if (ena_internal[2]) begin\n                if (q[11:8] == 4'd9) q[11:8] <= 4'd0;\n                else q[11:8] <= q[11:8] + 1'd1;\n            end\n            if (ena_internal[3]) begin\n                if (q[15:12] == 4'd9) q[15:12] <= 4'd0;\n                else q[15:12] <= q[15:12] + 1'd1;\n            end\n        end\n    end\n\n    assign ena_internal[0] = 1'b1;\n    assign ena_internal[1] = (q[3:0] == 4'd9);\n    assign ena_internal[2] = (q[7:4] == 4'd9) & ena_internal[1];\n    assign ena_internal[3] = (q[11:8] == 4'd9) & ena_internal[2];\n\n    assign ena = ena_internal[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'h0000;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'h9) ? 4'h0 : q[3:0] + 1'b1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'h9) ? 4'h0 : q[7:4] + 1'b1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'h9) ? 4'h0 : q[11:8] + 1'b1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'h9) ? 4'h0 : q[15:12] + 1'b1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'h9);\n    assign digit_ena[2] = (q[7:4] == 4'h9) & (q[3:0] == 4'h9);\n    assign digit_ena[3] = (q[11:8] == 4'h9) & (q[7:4] == 4'h9) & (q[3:0] == 4'h9);\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'h0000;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) && (q[3:0] == 4'd9);\n    assign digit_ena[3] = (q[11:8] == 4'd9) && (q[7:4] == 4'd9) && (q[3:0] == 4'd9);\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q\n);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    // Enable signals for each digit\n    assign digit_ena[0] = 1'b1; // Ones digit always enabled\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            // Ones digit\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n            end else begin\n                q[3:0] <= q[3:0] + 1'b1;\n            end\n\n            // Tens digit\n            if (digit_ena[1]) begin\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0;\n                end else begin\n                    q[7:4] <= q[7:4] + 1'b1;\n                end\n            end\n\n            // Hundreds digit\n            if (digit_ena[2]) begin\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                end else begin\n                    q[11:8] <= q[11:8] + 1'b1;\n                end\n            end\n\n            // Thousands digit\n            if (digit_ena[3]) begin\n                if (q[15:12] == 4'd9) begin\n                    q[15:12] <= 4'd0;\n                end else begin\n                    q[15:12] <= q[15:12] + 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    // Enable signals for each digit\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            // Ones digit\n            if (digit_ena[0]) begin\n                if (q[3:0] == 4'd9)\n                    q[3:0] <= 4'd0;\n                else\n                    q[3:0] <= q[3:0] + 1'b1;\n            end\n\n            // Tens digit\n            if (digit_ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 1'b1;\n            end\n\n            // Hundreds digit\n            if (digit_ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 1'b1;\n            end\n\n            // Thousands digit\n            if (digit_ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 1'b1;\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] dig_ena;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (dig_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (dig_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (dig_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (dig_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign dig_ena[0] = 1'b1;\n    assign dig_ena[1] = (q[3:0] == 4'd9);\n    assign dig_ena[2] = (q[7:4] == 4'd9) && (q[3:0] == 4'd9);\n    assign dig_ena[3] = (q[11:8] == 4'd9) && (q[7:4] == 4'd9) && (q[3:0] == 4'd9);\n\n    assign ena = dig_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] ena_internal;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (ena_internal[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (ena_internal[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (ena_internal[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (ena_internal[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign ena_internal[0] = 1'b1;\n    assign ena_internal[1] = (q[3:0] == 4'd9);\n    assign ena_internal[2] = (q[7:4] == 4'd9) & ena_internal[1];\n    assign ena_internal[3] = (q[11:8] == 4'd9) & ena_internal[2];\n\n    assign ena = ena_internal[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 1'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 1'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 1'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 1'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) && (q[3:0] == 4'd9);\n    assign digit_ena[3] = (q[11:8] == 4'd9) && (q[7:4] == 4'd9) && (q[3:0] == 4'd9);\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    // Enable signals for each digit\n    assign digit_ena[0] = 1'b1; // Ones digit always enabled\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            // Ones digit\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n            end else begin\n                q[3:0] <= q[3:0] + 1'b1;\n            end\n\n            // Tens digit\n            if (digit_ena[1]) begin\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0;\n                end else begin\n                    q[7:4] <= q[7:4] + 1'b1;\n                end\n            end\n\n            // Hundreds digit\n            if (digit_ena[2]) begin\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                end else begin\n                    q[11:8] <= q[11:8] + 1'b1;\n                end\n            end\n\n            // Thousands digit\n            if (digit_ena[3]) begin\n                if (q[15:12] == 4'd9) begin\n                    q[15:12] <= 4'd0;\n                end else begin\n                    q[15:12] <= q[15:12] + 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            if (digit_ena[0]) q[3:0] <= (q[3:0] == 4'd9) ? 4'd0 : q[3:0] + 4'd1;\n            if (digit_ena[1]) q[7:4] <= (q[7:4] == 4'd9) ? 4'd0 : q[7:4] + 4'd1;\n            if (digit_ena[2]) q[11:8] <= (q[11:8] == 4'd9) ? 4'd0 : q[11:8] + 4'd1;\n            if (digit_ena[3]) q[15:12] <= (q[15:12] == 4'd9) ? 4'd0 : q[15:12] + 4'd1;\n        end\n    end\n\n    assign digit_ena[0] = 1'b1;\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\nendmodule", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n    wire [3:0] digit_ena;\n\n    // Generate enable signals\n    assign digit_ena[0] = 1'b1; // Ones digit always increments\n    assign digit_ena[1] = (q[3:0] == 4'd9);\n    assign digit_ena[2] = (q[7:4] == 4'd9) & digit_ena[1];\n    assign digit_ena[3] = (q[11:8] == 4'd9) & digit_ena[2];\n\n    assign ena = digit_ena[3:1];\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            // Ones digit\n            if (digit_ena[0]) begin\n                if (q[3:0] == 4'd9)\n                    q[3:0] <= 4'd0;\n                else\n                    q[3:0] <= q[3:0] + 1'b1;\n            end\n\n            // Tens digit\n            if (digit_ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 1'b1;\n            end\n\n            // Hundreds digit\n            if (digit_ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 1'b1;\n            end\n\n            // Thousands digit\n            if (digit_ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 1'b1;\n            end\n        end\n    end\n\nendmodule"]}
